{"version":3,"file":"thinknetmaps.js","sources":["../node_modules/pbf/index.js","../src/style/parse_glyph_pbf.js","../src/util/actor.js","../node_modules/@mapbox/whoots-js/index.mjs","../src/geo/lng_lat_bounds.js","../src/geo/lng_lat.js","../src/geo/mercator_coordinate.js","../src/source/tile_id.js","../src/data/dem_data.js","../src/util/dictionary_coder.js","../src/util/vectortile_to_geojson.js","../src/source/source_state.js","../src/data/feature_index.js","../src/util/util.js","../src/source/tile.js","../src/data/bucket.js","../src/style-spec/util/ref_properties.js","../src/symbol/shaping.js","../src/util/verticalize_punctuation.js","../src/util/script_detection.js","../src/util/ajax.js","../src/util/mapbox.js","../node_modules/gl-matrix/lib/gl-matrix/mat4.js","../src/style-spec/group_by_layout.js","../src/style/style_layer_index.js","../src/symbol/check_max_angle.js","../src/symbol/get_anchors.js","../src/symbol/collision_feature.js","../node_modules/tinyqueue/index.js","../src/util/find_pole_of_inaccessibility.js","../node_modules/murmurhash-js/murmurhash3_gc.js","../node_modules/murmurhash-js/murmurhash2_gc.js","../node_modules/murmurhash-js/index.js","../src/symbol/symbol_layout.js","../src/symbol/quads.js","../src/symbol/clip_line.js","../src/render/glyph_atlas.js","../src/source/worker_tile.js","../src/util/performance.js","../src/source/vector_tile_worker_source.js","../src/source/raster_dem_tile_worker_source.js","../node_modules/wgs84/index.js","../node_modules/@mapbox/geojson-area/index.js","../node_modules/geojson-rewind/index.js","../src/source/geojson_wrapper.js","../node_modules/vt-pbf/lib/geojson_wrapper.js","../node_modules/vt-pbf/index.js","../src/source/source_cache.js","../src/util/worker_pool.js","../src/render/draw_debug.js","../src/ui/control/logo_control.js","../src/util/task_queue.js","../src/ui/map.js","../src/ui/bind_handlers.js","../src/ui/marker.js","../src/ui/control/geolocate_control.js","../src/ui/control/scale_control.js","../src/ui/control/fullscreen_control.js","../rollup/thinknetmaps.js"],"sourcesContent":["'use strict';\n\nmodule.exports = Pbf;\n\nvar ieee754 = require('ieee754');\n\nfunction Pbf(buf) {\n    this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);\n    this.pos = 0;\n    this.type = 0;\n    this.length = this.buf.length;\n}\n\nPbf.Varint  = 0; // varint: int32, int64, uint32, uint64, sint32, sint64, bool, enum\nPbf.Fixed64 = 1; // 64-bit: double, fixed64, sfixed64\nPbf.Bytes   = 2; // length-delimited: string, bytes, embedded messages, packed repeated fields\nPbf.Fixed32 = 5; // 32-bit: float, fixed32, sfixed32\n\nvar SHIFT_LEFT_32 = (1 << 16) * (1 << 16),\n    SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;\n\nPbf.prototype = {\n\n    destroy: function() {\n        this.buf = null;\n    },\n\n    // === READING =================================================================\n\n    readFields: function(readField, result, end) {\n        end = end || this.length;\n\n        while (this.pos < end) {\n            var val = this.readVarint(),\n                tag = val >> 3,\n                startPos = this.pos;\n\n            this.type = val & 0x7;\n            readField(tag, result, this);\n\n            if (this.pos === startPos) this.skip(val);\n        }\n        return result;\n    },\n\n    readMessage: function(readField, result) {\n        return this.readFields(readField, result, this.readVarint() + this.pos);\n    },\n\n    readFixed32: function() {\n        var val = readUInt32(this.buf, this.pos);\n        this.pos += 4;\n        return val;\n    },\n\n    readSFixed32: function() {\n        var val = readInt32(this.buf, this.pos);\n        this.pos += 4;\n        return val;\n    },\n\n    // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)\n\n    readFixed64: function() {\n        var val = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;\n        this.pos += 8;\n        return val;\n    },\n\n    readSFixed64: function() {\n        var val = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;\n        this.pos += 8;\n        return val;\n    },\n\n    readFloat: function() {\n        var val = ieee754.read(this.buf, this.pos, true, 23, 4);\n        this.pos += 4;\n        return val;\n    },\n\n    readDouble: function() {\n        var val = ieee754.read(this.buf, this.pos, true, 52, 8);\n        this.pos += 8;\n        return val;\n    },\n\n    readVarint: function(isSigned) {\n        var buf = this.buf,\n            val, b;\n\n        b = buf[this.pos++]; val  =  b & 0x7f;        if (b < 0x80) return val;\n        b = buf[this.pos++]; val |= (b & 0x7f) << 7;  if (b < 0x80) return val;\n        b = buf[this.pos++]; val |= (b & 0x7f) << 14; if (b < 0x80) return val;\n        b = buf[this.pos++]; val |= (b & 0x7f) << 21; if (b < 0x80) return val;\n        b = buf[this.pos];   val |= (b & 0x0f) << 28;\n\n        return readVarintRemainder(val, isSigned, this);\n    },\n\n    readVarint64: function() { // for compatibility with v2.0.1\n        return this.readVarint(true);\n    },\n\n    readSVarint: function() {\n        var num = this.readVarint();\n        return num % 2 === 1 ? (num + 1) / -2 : num / 2; // zigzag encoding\n    },\n\n    readBoolean: function() {\n        return Boolean(this.readVarint());\n    },\n\n    readString: function() {\n        var end = this.readVarint() + this.pos,\n            str = readUtf8(this.buf, this.pos, end);\n        this.pos = end;\n        return str;\n    },\n\n    readBytes: function() {\n        var end = this.readVarint() + this.pos,\n            buffer = this.buf.subarray(this.pos, end);\n        this.pos = end;\n        return buffer;\n    },\n\n    // verbose for performance reasons; doesn't affect gzipped size\n\n    readPackedVarint: function(arr, isSigned) {\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readVarint(isSigned));\n        return arr;\n    },\n    readPackedSVarint: function(arr) {\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readSVarint());\n        return arr;\n    },\n    readPackedBoolean: function(arr) {\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readBoolean());\n        return arr;\n    },\n    readPackedFloat: function(arr) {\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readFloat());\n        return arr;\n    },\n    readPackedDouble: function(arr) {\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readDouble());\n        return arr;\n    },\n    readPackedFixed32: function(arr) {\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readFixed32());\n        return arr;\n    },\n    readPackedSFixed32: function(arr) {\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readSFixed32());\n        return arr;\n    },\n    readPackedFixed64: function(arr) {\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readFixed64());\n        return arr;\n    },\n    readPackedSFixed64: function(arr) {\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readSFixed64());\n        return arr;\n    },\n\n    skip: function(val) {\n        var type = val & 0x7;\n        if (type === Pbf.Varint) while (this.buf[this.pos++] > 0x7f) {}\n        else if (type === Pbf.Bytes) this.pos = this.readVarint() + this.pos;\n        else if (type === Pbf.Fixed32) this.pos += 4;\n        else if (type === Pbf.Fixed64) this.pos += 8;\n        else throw new Error('Unimplemented type: ' + type);\n    },\n\n    // === WRITING =================================================================\n\n    writeTag: function(tag, type) {\n        this.writeVarint((tag << 3) | type);\n    },\n\n    realloc: function(min) {\n        var length = this.length || 16;\n\n        while (length < this.pos + min) length *= 2;\n\n        if (length !== this.length) {\n            var buf = new Uint8Array(length);\n            buf.set(this.buf);\n            this.buf = buf;\n            this.length = length;\n        }\n    },\n\n    finish: function() {\n        this.length = this.pos;\n        this.pos = 0;\n        return this.buf.subarray(0, this.length);\n    },\n\n    writeFixed32: function(val) {\n        this.realloc(4);\n        writeInt32(this.buf, val, this.pos);\n        this.pos += 4;\n    },\n\n    writeSFixed32: function(val) {\n        this.realloc(4);\n        writeInt32(this.buf, val, this.pos);\n        this.pos += 4;\n    },\n\n    writeFixed64: function(val) {\n        this.realloc(8);\n        writeInt32(this.buf, val & -1, this.pos);\n        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);\n        this.pos += 8;\n    },\n\n    writeSFixed64: function(val) {\n        this.realloc(8);\n        writeInt32(this.buf, val & -1, this.pos);\n        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);\n        this.pos += 8;\n    },\n\n    writeVarint: function(val) {\n        val = +val || 0;\n\n        if (val > 0xfffffff || val < 0) {\n            writeBigVarint(val, this);\n            return;\n        }\n\n        this.realloc(4);\n\n        this.buf[this.pos++] =           val & 0x7f  | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;\n        this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;\n        this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;\n        this.buf[this.pos++] =   (val >>> 7) & 0x7f;\n    },\n\n    writeSVarint: function(val) {\n        this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);\n    },\n\n    writeBoolean: function(val) {\n        this.writeVarint(Boolean(val));\n    },\n\n    writeString: function(str) {\n        str = String(str);\n        this.realloc(str.length * 4);\n\n        this.pos++; // reserve 1 byte for short string length\n\n        var startPos = this.pos;\n        // write the string directly to the buffer and see how much was written\n        this.pos = writeUtf8(this.buf, str, this.pos);\n        var len = this.pos - startPos;\n\n        if (len >= 0x80) makeRoomForExtraLength(startPos, len, this);\n\n        // finally, write the message length in the reserved place and restore the position\n        this.pos = startPos - 1;\n        this.writeVarint(len);\n        this.pos += len;\n    },\n\n    writeFloat: function(val) {\n        this.realloc(4);\n        ieee754.write(this.buf, val, this.pos, true, 23, 4);\n        this.pos += 4;\n    },\n\n    writeDouble: function(val) {\n        this.realloc(8);\n        ieee754.write(this.buf, val, this.pos, true, 52, 8);\n        this.pos += 8;\n    },\n\n    writeBytes: function(buffer) {\n        var len = buffer.length;\n        this.writeVarint(len);\n        this.realloc(len);\n        for (var i = 0; i < len; i++) this.buf[this.pos++] = buffer[i];\n    },\n\n    writeRawMessage: function(fn, obj) {\n        this.pos++; // reserve 1 byte for short message length\n\n        // write the message directly to the buffer and see how much was written\n        var startPos = this.pos;\n        fn(obj, this);\n        var len = this.pos - startPos;\n\n        if (len >= 0x80) makeRoomForExtraLength(startPos, len, this);\n\n        // finally, write the message length in the reserved place and restore the position\n        this.pos = startPos - 1;\n        this.writeVarint(len);\n        this.pos += len;\n    },\n\n    writeMessage: function(tag, fn, obj) {\n        this.writeTag(tag, Pbf.Bytes);\n        this.writeRawMessage(fn, obj);\n    },\n\n    writePackedVarint:   function(tag, arr) { this.writeMessage(tag, writePackedVarint, arr);   },\n    writePackedSVarint:  function(tag, arr) { this.writeMessage(tag, writePackedSVarint, arr);  },\n    writePackedBoolean:  function(tag, arr) { this.writeMessage(tag, writePackedBoolean, arr);  },\n    writePackedFloat:    function(tag, arr) { this.writeMessage(tag, writePackedFloat, arr);    },\n    writePackedDouble:   function(tag, arr) { this.writeMessage(tag, writePackedDouble, arr);   },\n    writePackedFixed32:  function(tag, arr) { this.writeMessage(tag, writePackedFixed32, arr);  },\n    writePackedSFixed32: function(tag, arr) { this.writeMessage(tag, writePackedSFixed32, arr); },\n    writePackedFixed64:  function(tag, arr) { this.writeMessage(tag, writePackedFixed64, arr);  },\n    writePackedSFixed64: function(tag, arr) { this.writeMessage(tag, writePackedSFixed64, arr); },\n\n    writeBytesField: function(tag, buffer) {\n        this.writeTag(tag, Pbf.Bytes);\n        this.writeBytes(buffer);\n    },\n    writeFixed32Field: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed32);\n        this.writeFixed32(val);\n    },\n    writeSFixed32Field: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed32);\n        this.writeSFixed32(val);\n    },\n    writeFixed64Field: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed64);\n        this.writeFixed64(val);\n    },\n    writeSFixed64Field: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed64);\n        this.writeSFixed64(val);\n    },\n    writeVarintField: function(tag, val) {\n        this.writeTag(tag, Pbf.Varint);\n        this.writeVarint(val);\n    },\n    writeSVarintField: function(tag, val) {\n        this.writeTag(tag, Pbf.Varint);\n        this.writeSVarint(val);\n    },\n    writeStringField: function(tag, str) {\n        this.writeTag(tag, Pbf.Bytes);\n        this.writeString(str);\n    },\n    writeFloatField: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed32);\n        this.writeFloat(val);\n    },\n    writeDoubleField: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed64);\n        this.writeDouble(val);\n    },\n    writeBooleanField: function(tag, val) {\n        this.writeVarintField(tag, Boolean(val));\n    }\n};\n\nfunction readVarintRemainder(l, s, p) {\n    var buf = p.buf,\n        h, b;\n\n    b = buf[p.pos++]; h  = (b & 0x70) >> 4;  if (b < 0x80) return toNum(l, h, s);\n    b = buf[p.pos++]; h |= (b & 0x7f) << 3;  if (b < 0x80) return toNum(l, h, s);\n    b = buf[p.pos++]; h |= (b & 0x7f) << 10; if (b < 0x80) return toNum(l, h, s);\n    b = buf[p.pos++]; h |= (b & 0x7f) << 17; if (b < 0x80) return toNum(l, h, s);\n    b = buf[p.pos++]; h |= (b & 0x7f) << 24; if (b < 0x80) return toNum(l, h, s);\n    b = buf[p.pos++]; h |= (b & 0x01) << 31; if (b < 0x80) return toNum(l, h, s);\n\n    throw new Error('Expected varint not more than 10 bytes');\n}\n\nfunction readPackedEnd(pbf) {\n    return pbf.type === Pbf.Bytes ?\n        pbf.readVarint() + pbf.pos : pbf.pos + 1;\n}\n\nfunction toNum(low, high, isSigned) {\n    if (isSigned) {\n        return high * 0x100000000 + (low >>> 0);\n    }\n\n    return ((high >>> 0) * 0x100000000) + (low >>> 0);\n}\n\nfunction writeBigVarint(val, pbf) {\n    var low, high;\n\n    if (val >= 0) {\n        low  = (val % 0x100000000) | 0;\n        high = (val / 0x100000000) | 0;\n    } else {\n        low  = ~(-val % 0x100000000);\n        high = ~(-val / 0x100000000);\n\n        if (low ^ 0xffffffff) {\n            low = (low + 1) | 0;\n        } else {\n            low = 0;\n            high = (high + 1) | 0;\n        }\n    }\n\n    if (val >= 0x10000000000000000 || val < -0x10000000000000000) {\n        throw new Error('Given varint doesn\\'t fit into 10 bytes');\n    }\n\n    pbf.realloc(10);\n\n    writeBigVarintLow(low, high, pbf);\n    writeBigVarintHigh(high, pbf);\n}\n\nfunction writeBigVarintLow(low, high, pbf) {\n    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;\n    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;\n    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;\n    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;\n    pbf.buf[pbf.pos]   = low & 0x7f;\n}\n\nfunction writeBigVarintHigh(high, pbf) {\n    var lsb = (high & 0x07) << 4;\n\n    pbf.buf[pbf.pos++] |= lsb         | ((high >>>= 3) ? 0x80 : 0); if (!high) return;\n    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;\n    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;\n    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;\n    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;\n    pbf.buf[pbf.pos++]  = high & 0x7f;\n}\n\nfunction makeRoomForExtraLength(startPos, len, pbf) {\n    var extraLen =\n        len <= 0x3fff ? 1 :\n        len <= 0x1fffff ? 2 :\n        len <= 0xfffffff ? 3 : Math.ceil(Math.log(len) / (Math.LN2 * 7));\n\n    // if 1 byte isn't enough for encoding message length, shift the data to the right\n    pbf.realloc(extraLen);\n    for (var i = pbf.pos - 1; i >= startPos; i--) pbf.buf[i + extraLen] = pbf.buf[i];\n}\n\nfunction writePackedVarint(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeVarint(arr[i]);   }\nfunction writePackedSVarint(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeSVarint(arr[i]);  }\nfunction writePackedFloat(arr, pbf)    { for (var i = 0; i < arr.length; i++) pbf.writeFloat(arr[i]);    }\nfunction writePackedDouble(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeDouble(arr[i]);   }\nfunction writePackedBoolean(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeBoolean(arr[i]);  }\nfunction writePackedFixed32(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed32(arr[i]);  }\nfunction writePackedSFixed32(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed32(arr[i]); }\nfunction writePackedFixed64(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed64(arr[i]);  }\nfunction writePackedSFixed64(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed64(arr[i]); }\n\n// Buffer code below from https://github.com/feross/buffer, MIT-licensed\n\nfunction readUInt32(buf, pos) {\n    return ((buf[pos]) |\n        (buf[pos + 1] << 8) |\n        (buf[pos + 2] << 16)) +\n        (buf[pos + 3] * 0x1000000);\n}\n\nfunction writeInt32(buf, val, pos) {\n    buf[pos] = val;\n    buf[pos + 1] = (val >>> 8);\n    buf[pos + 2] = (val >>> 16);\n    buf[pos + 3] = (val >>> 24);\n}\n\nfunction readInt32(buf, pos) {\n    return ((buf[pos]) |\n        (buf[pos + 1] << 8) |\n        (buf[pos + 2] << 16)) +\n        (buf[pos + 3] << 24);\n}\n\nfunction readUtf8(buf, pos, end) {\n    var str = '';\n    var i = pos;\n\n    while (i < end) {\n        var b0 = buf[i];\n        var c = null; // codepoint\n        var bytesPerSequence =\n            b0 > 0xEF ? 4 :\n            b0 > 0xDF ? 3 :\n            b0 > 0xBF ? 2 : 1;\n\n        if (i + bytesPerSequence > end) break;\n\n        var b1, b2, b3;\n\n        if (bytesPerSequence === 1) {\n            if (b0 < 0x80) {\n                c = b0;\n            }\n        } else if (bytesPerSequence === 2) {\n            b1 = buf[i + 1];\n            if ((b1 & 0xC0) === 0x80) {\n                c = (b0 & 0x1F) << 0x6 | (b1 & 0x3F);\n                if (c <= 0x7F) {\n                    c = null;\n                }\n            }\n        } else if (bytesPerSequence === 3) {\n            b1 = buf[i + 1];\n            b2 = buf[i + 2];\n            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80) {\n                c = (b0 & 0xF) << 0xC | (b1 & 0x3F) << 0x6 | (b2 & 0x3F);\n                if (c <= 0x7FF || (c >= 0xD800 && c <= 0xDFFF)) {\n                    c = null;\n                }\n            }\n        } else if (bytesPerSequence === 4) {\n            b1 = buf[i + 1];\n            b2 = buf[i + 2];\n            b3 = buf[i + 3];\n            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {\n                c = (b0 & 0xF) << 0x12 | (b1 & 0x3F) << 0xC | (b2 & 0x3F) << 0x6 | (b3 & 0x3F);\n                if (c <= 0xFFFF || c >= 0x110000) {\n                    c = null;\n                }\n            }\n        }\n\n        if (c === null) {\n            c = 0xFFFD;\n            bytesPerSequence = 1;\n\n        } else if (c > 0xFFFF) {\n            c -= 0x10000;\n            str += String.fromCharCode(c >>> 10 & 0x3FF | 0xD800);\n            c = 0xDC00 | c & 0x3FF;\n        }\n\n        str += String.fromCharCode(c);\n        i += bytesPerSequence;\n    }\n\n    return str;\n}\n\nfunction writeUtf8(buf, str, pos) {\n    for (var i = 0, c, lead; i < str.length; i++) {\n        c = str.charCodeAt(i); // code point\n\n        if (c > 0xD7FF && c < 0xE000) {\n            if (lead) {\n                if (c < 0xDC00) {\n                    buf[pos++] = 0xEF;\n                    buf[pos++] = 0xBF;\n                    buf[pos++] = 0xBD;\n                    lead = c;\n                    continue;\n                } else {\n                    c = lead - 0xD800 << 10 | c - 0xDC00 | 0x10000;\n                    lead = null;\n                }\n            } else {\n                if (c > 0xDBFF || (i + 1 === str.length)) {\n                    buf[pos++] = 0xEF;\n                    buf[pos++] = 0xBF;\n                    buf[pos++] = 0xBD;\n                } else {\n                    lead = c;\n                }\n                continue;\n            }\n        } else if (lead) {\n            buf[pos++] = 0xEF;\n            buf[pos++] = 0xBF;\n            buf[pos++] = 0xBD;\n            lead = null;\n        }\n\n        if (c < 0x80) {\n            buf[pos++] = c;\n        } else {\n            if (c < 0x800) {\n                buf[pos++] = c >> 0x6 | 0xC0;\n            } else {\n                if (c < 0x10000) {\n                    buf[pos++] = c >> 0xC | 0xE0;\n                } else {\n                    buf[pos++] = c >> 0x12 | 0xF0;\n                    buf[pos++] = c >> 0xC & 0x3F | 0x80;\n                }\n                buf[pos++] = c >> 0x6 & 0x3F | 0x80;\n            }\n            buf[pos++] = c & 0x3F | 0x80;\n        }\n    }\n    return pos;\n}\n","// @flow\n\nimport { AlphaImage } from '../util/image';\n\nimport Protobuf from 'pbf';\nconst border = 3;\n\nimport type {StyleGlyph} from './style_glyph';\n\nfunction readFontstacks(tag: number, glyphs: Array<StyleGlyph>, pbf: Protobuf) {\n    if (tag === 1) {\n        pbf.readMessage(readFontstack, glyphs);\n    }\n}\n\nfunction readFontstack(tag: number, glyphs: Array<StyleGlyph>, pbf: Protobuf) {\n    if (tag === 3) {\n        const {id, bitmap, width, height, left, top, advance} = pbf.readMessage(readGlyph, {});\n        glyphs.push({\n            id,\n            bitmap: new AlphaImage({\n                width: width + 2 * border,\n                height: height + 2 * border\n            }, bitmap),\n            metrics: {width, height, left, top, advance}\n        });\n    }\n}\n\nfunction readGlyph(tag: number, glyph: Object, pbf: Protobuf) {\n    if (tag === 1) glyph.id = pbf.readVarint();\n    else if (tag === 2) glyph.bitmap = pbf.readBytes();\n    else if (tag === 3) glyph.width = pbf.readVarint();\n    else if (tag === 4) glyph.height = pbf.readVarint();\n    else if (tag === 5) glyph.left = pbf.readSVarint();\n    else if (tag === 6) glyph.top = pbf.readSVarint();\n    else if (tag === 7) glyph.advance = pbf.readVarint();\n}\n\nexport default function (data: ArrayBuffer | Uint8Array): Array<StyleGlyph> {\n    return new Protobuf(data).readFields(readFontstacks, []);\n}\n\nexport const GLYPH_PBF_BORDER = border;\n","// @flow\n\nimport { bindAll } from './util';\nimport { serialize, deserialize } from './web_worker_transfer';\n\nimport type {Transferable} from '../types/transferable';\n\n/**\n * An implementation of the [Actor design pattern](http://en.wikipedia.org/wiki/Actor_model)\n * that maintains the relationship between asynchronous tasks and the objects\n * that spin them off - in this case, tasks like parsing parts of styles,\n * owned by the styles\n *\n * @param {WebWorker} target\n * @param {WebWorker} parent\n * @param {string|number} mapId A unique identifier for the Map instance using this Actor.\n * @private\n */\nclass Actor {\n    target: any;\n    parent: any;\n    mapId: string;\n    callbacks: any;\n    callbackID: number;\n    name: string;\n\n    constructor(target: any, parent: any, mapId: any) {\n        this.target = target;\n        this.parent = parent;\n        this.mapId = mapId;\n        this.callbacks = {};\n        this.callbackID = 0;\n        bindAll(['receive'], this);\n        this.target.addEventListener('message', this.receive, false);\n    }\n\n    /**\n     * Sends a message from a main-thread map to a Worker or from a Worker back to\n     * a main-thread map instance.\n     *\n     * @param type The name of the target method to invoke or '[source-type].[source-name].name' for a method on a WorkerSource.\n     * @param targetMapId A particular mapId to which to send this message.\n     * @private\n     */\n    send(type: string, data: mixed, callback: ?Function, targetMapId: ?string) {\n        const id = callback ? `${this.mapId}:${this.callbackID++}` : null;\n        if (callback) this.callbacks[id] = callback;\n        const buffers: Array<Transferable> = [];\n        this.target.postMessage({\n            targetMapId,\n            sourceMapId: this.mapId,\n            type,\n            id: String(id),\n            data: serialize(data, buffers)\n        }, buffers);\n    }\n\n    receive(message: Object) {\n        const data = message.data,\n            id = data.id;\n        let callback;\n\n        if (data.targetMapId && this.mapId !== data.targetMapId)\n            return;\n\n        const done = (err, data) => {\n            const buffers: Array<Transferable> = [];\n            this.target.postMessage({\n                sourceMapId: this.mapId,\n                type: '<response>',\n                id: String(id),\n                error: err ? serialize(err) : null,\n                data: serialize(data, buffers)\n            }, buffers);\n        };\n\n        if (data.type === '<response>') {\n            callback = this.callbacks[data.id];\n            delete this.callbacks[data.id];\n            if (callback && data.error) {\n                callback(deserialize(data.error));\n            } else if (callback) {\n                callback(null, deserialize(data.data));\n            }\n        } else if (typeof data.id !== 'undefined' && this.parent[data.type]) {\n            // data.type == 'loadTile', 'removeTile', etc.\n            this.parent[data.type](data.sourceMapId, deserialize(data.data), done);\n        } else if (typeof data.id !== 'undefined' && this.parent.getWorkerSource) {\n            // data.type == sourcetype.method\n            const keys = data.type.split('.');\n            const params = (deserialize(data.data): any);\n            const workerSource = (this.parent: any).getWorkerSource(data.sourceMapId, keys[0], params.source);\n            workerSource[keys[1]](params, done);\n        } else {\n            this.parent[data.type](deserialize(data.data));\n        }\n    }\n\n    remove() {\n        this.target.removeEventListener('message', this.receive, false);\n    }\n}\n\nexport default Actor;\n","export { getURL, getTileBBox, getMercCoords };\n\n\n/**\n * getURL\n *\n * @param    {String}  baseUrl  Base url of the WMS server\n * @param    {String}  layer    Layer name\n * @param    {Number}  x        Tile coordinate x\n * @param    {Number}  y        Tile coordinate y\n * @param    {Number}  z        Tile zoom\n * @param    {Object}  [options]\n * @param    {String}  [options.format='image/png']\n * @param    {String}  [options.service='WMS']\n * @param    {String}  [options.version='1.1.1']\n * @param    {String}  [options.request='GetMap']\n * @param    {String}  [options.srs='EPSG:3857']\n * @param    {Number}  [options.width='256']\n * @param    {Number}  [options.height='256']\n * @returns  {String}  url\n * @example\n * var baseUrl = 'http://geodata.state.nj.us/imagerywms/Natural2015';\n * var layer = 'Natural2015';\n * var url = whoots.getURL(baseUrl, layer, 154308, 197167, 19);\n */\nfunction getURL(baseUrl, layer, x, y, z, options) {\n    options = options || {};\n\n    var url = baseUrl + '?' + [\n        'bbox='    + getTileBBox(x, y, z),\n        'format='  + (options.format || 'image/png'),\n        'service=' + (options.service || 'WMS'),\n        'version=' + (options.version || '1.1.1'),\n        'request=' + (options.request || 'GetMap'),\n        'srs='     + (options.srs || 'EPSG:3857'),\n        'width='   + (options.width || 256),\n        'height='  + (options.height || 256),\n        'layers='  + layer\n    ].join('&');\n\n    return url;\n}\n\n\n/**\n * getTileBBox\n *\n * @param    {Number}  x  Tile coordinate x\n * @param    {Number}  y  Tile coordinate y\n * @param    {Number}  z  Tile zoom\n * @returns  {String}  String of the bounding box\n */\nfunction getTileBBox(x, y, z) {\n    // for Google/OSM tile scheme we need to alter the y\n    y = (Math.pow(2, z) - y - 1);\n\n    var min = getMercCoords(x * 256, y * 256, z),\n        max = getMercCoords((x + 1) * 256, (y + 1) * 256, z);\n\n    return min[0] + ',' + min[1] + ',' + max[0] + ',' + max[1];\n}\n\n\n/**\n * getMercCoords\n *\n * @param    {Number}  x  Pixel coordinate x\n * @param    {Number}  y  Pixel coordinate y\n * @param    {Number}  z  Tile zoom\n * @returns  {Array}   [x, y]\n */\nfunction getMercCoords(x, y, z) {\n    var resolution = (2 * Math.PI * 6378137 / 256) / Math.pow(2, z),\n        merc_x = (x * resolution - 2 * Math.PI  * 6378137 / 2.0),\n        merc_y = (y * resolution - 2 * Math.PI  * 6378137 / 2.0);\n\n    return [merc_x, merc_y];\n}\n","// @flow\n\nimport LngLat from './lng_lat';\n\nimport type {LngLatLike} from './lng_lat';\n\n/**\n * A `LngLatBounds` object represents a geographical bounding box,\n * defined by its southwest and northeast points in longitude and latitude.\n *\n * If no arguments are provided to the constructor, a `null` bounding box is created.\n *\n * Note that any Mapbox GL method that accepts a `LngLatBounds` object as an argument or option\n * can also accept an `Array` of two {@link LngLatLike} constructs and will perform an implicit conversion.\n * This flexible type is documented as {@link LngLatBoundsLike}.\n *\n * @param {LngLatLike} [sw] The southwest corner of the bounding box.\n * @param {LngLatLike} [ne] The northeast corner of the bounding box.\n * @example\n * var sw = new mapboxgl.LngLat(-73.9876, 40.7661);\n * var ne = new mapboxgl.LngLat(-73.9397, 40.8002);\n * var llb = new mapboxgl.LngLatBounds(sw, ne);\n */\nclass LngLatBounds {\n    _ne: LngLat;\n    _sw: LngLat;\n\n    // This constructor is too flexible to type. It should not be so flexible.\n    constructor(sw: any, ne: any) {\n        if (!sw) {\n            // noop\n        } else if (ne) {\n            this.setSouthWest(sw).setNorthEast(ne);\n        } else if (sw.length === 4) {\n            this.setSouthWest([sw[0], sw[1]]).setNorthEast([sw[2], sw[3]]);\n        } else {\n            this.setSouthWest(sw[0]).setNorthEast(sw[1]);\n        }\n    }\n\n    /**\n     * Set the northeast corner of the bounding box\n     *\n     * @param {LngLatLike} ne\n     * @returns {LngLatBounds} `this`\n     */\n    setNorthEast(ne: LngLatLike) {\n        this._ne = ne instanceof LngLat ? new LngLat(ne.lng, ne.lat) : LngLat.convert(ne);\n        return this;\n    }\n\n    /**\n     * Set the southwest corner of the bounding box\n     *\n     * @param {LngLatLike} sw\n     * @returns {LngLatBounds} `this`\n     */\n    setSouthWest(sw: LngLatLike) {\n        this._sw = sw instanceof LngLat ? new LngLat(sw.lng, sw.lat) : LngLat.convert(sw);\n        return this;\n    }\n\n    /**\n     * Extend the bounds to include a given LngLat or LngLatBounds.\n     *\n     * @param {LngLat|LngLatBounds} obj object to extend to\n     * @returns {LngLatBounds} `this`\n     */\n    extend(obj: LngLat | LngLatBounds) {\n        const sw = this._sw,\n            ne = this._ne;\n        let sw2, ne2;\n\n        if (obj instanceof LngLat) {\n            sw2 = obj;\n            ne2 = obj;\n\n        } else if (obj instanceof LngLatBounds) {\n            sw2 = obj._sw;\n            ne2 = obj._ne;\n\n            if (!sw2 || !ne2) return this;\n\n        } else {\n            if (Array.isArray(obj)) {\n                if (obj.every(Array.isArray)) {\n                    return this.extend(LngLatBounds.convert(obj));\n                } else {\n                    return this.extend(LngLat.convert(obj));\n                }\n            }\n            return this;\n        }\n\n        if (!sw && !ne) {\n            this._sw = new LngLat(sw2.lng, sw2.lat);\n            this._ne = new LngLat(ne2.lng, ne2.lat);\n\n        } else {\n            sw.lng = Math.min(sw2.lng, sw.lng);\n            sw.lat = Math.min(sw2.lat, sw.lat);\n            ne.lng = Math.max(ne2.lng, ne.lng);\n            ne.lat = Math.max(ne2.lat, ne.lat);\n        }\n\n        return this;\n    }\n\n    /**\n     * Returns the geographical coordinate equidistant from the bounding box's corners.\n     *\n     * @returns {LngLat} The bounding box's center.\n     * @example\n     * var llb = new mapboxgl.LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n     * llb.getCenter(); // = LngLat {lng: -73.96365, lat: 40.78315}\n     */\n    getCenter(): LngLat {\n        return new LngLat((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);\n    }\n\n    /**\n     * Returns the southwest corner of the bounding box.\n     *\n     * @returns {LngLat} The southwest corner of the bounding box.\n     */\n    getSouthWest(): LngLat { return this._sw; }\n\n    /**\n    * Returns the northeast corner of the bounding box.\n    *\n    * @returns {LngLat} The northeast corner of the bounding box.\n     */\n    getNorthEast(): LngLat { return this._ne; }\n\n    /**\n    * Returns the northwest corner of the bounding box.\n    *\n    * @returns {LngLat} The northwest corner of the bounding box.\n     */\n    getNorthWest(): LngLat { return new LngLat(this.getWest(), this.getNorth()); }\n\n    /**\n    * Returns the southeast corner of the bounding box.\n    *\n    * @returns {LngLat} The southeast corner of the bounding box.\n     */\n    getSouthEast(): LngLat { return new LngLat(this.getEast(), this.getSouth()); }\n\n    /**\n    * Returns the west edge of the bounding box.\n    *\n    * @returns {number} The west edge of the bounding box.\n     */\n    getWest(): number { return this._sw.lng; }\n\n    /**\n    * Returns the south edge of the bounding box.\n    *\n    * @returns {number} The south edge of the bounding box.\n     */\n    getSouth(): number { return this._sw.lat; }\n\n    /**\n    * Returns the east edge of the bounding box.\n    *\n    * @returns {number} The east edge of the bounding box.\n     */\n    getEast(): number { return this._ne.lng; }\n\n    /**\n    * Returns the north edge of the bounding box.\n    *\n    * @returns {number} The north edge of the bounding box.\n     */\n    getNorth(): number { return this._ne.lat; }\n\n    /**\n     * Returns the bounding box represented as an array.\n     *\n     * @returns {Array<Array<number>>} The bounding box represented as an array, consisting of the\n     *   southwest and northeast coordinates of the bounding represented as arrays of numbers.\n     * @example\n     * var llb = new mapboxgl.LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n     * llb.toArray(); // = [[-73.9876, 40.7661], [-73.9397, 40.8002]]\n     */\n    toArray() {\n        return [this._sw.toArray(), this._ne.toArray()];\n    }\n\n    /**\n     * Return the bounding box represented as a string.\n     *\n     * @returns {string} The bounding box represents as a string of the format\n     *   `'LngLatBounds(LngLat(lng, lat), LngLat(lng, lat))'`.\n     * @example\n     * var llb = new mapboxgl.LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n     * llb.toString(); // = \"LngLatBounds(LngLat(-73.9876, 40.7661), LngLat(-73.9397, 40.8002))\"\n     */\n    toString() {\n        return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;\n    }\n\n    /**\n     * Check if the bounding box is an empty/`null`-type box.\n     *\n     * @returns {boolean} True if bounds have been defined, otherwise false.\n     */\n    isEmpty() {\n        return !(this._sw && this._ne);\n    }\n\n    /**\n     * Converts an array to a `LngLatBounds` object.\n     *\n     * If a `LngLatBounds` object is passed in, the function returns it unchanged.\n     *\n     * Internally, the function calls `LngLat#convert` to convert arrays to `LngLat` values.\n     *\n     * @param {LngLatBoundsLike} input An array of two coordinates to convert, or a `LngLatBounds` object to return.\n     * @returns {LngLatBounds} A new `LngLatBounds` object, if a conversion occurred, or the original `LngLatBounds` object.\n     * @example\n     * var arr = [[-73.9876, 40.7661], [-73.9397, 40.8002]];\n     * var llb = mapboxgl.LngLatBounds.convert(arr);\n     * llb;   // = LngLatBounds {_sw: LngLat {lng: -73.9876, lat: 40.7661}, _ne: LngLat {lng: -73.9397, lat: 40.8002}}\n     */\n    static convert(input: LngLatBoundsLike): LngLatBounds {\n        if (!input || input instanceof LngLatBounds) return input;\n        return new LngLatBounds(input);\n    }\n}\n\n/**\n * A {@link LngLatBounds} object, an array of {@link LngLatLike} objects in [sw, ne] order,\n * or an array of numbers in [west, south, east, north] order.\n *\n * @typedef {LngLatBounds | [LngLatLike, LngLatLike] | [number, number, number, number]} LngLatBoundsLike\n * @example\n * var v1 = new mapboxgl.LngLatBounds(\n *   new mapboxgl.LngLat(-73.9876, 40.7661),\n *   new mapboxgl.LngLat(-73.9397, 40.8002)\n * );\n * var v2 = new mapboxgl.LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002])\n * var v3 = [[-73.9876, 40.7661], [-73.9397, 40.8002]];\n */\nexport type LngLatBoundsLike = LngLatBounds | [LngLatLike, LngLatLike] | [number, number, number, number];\n\nexport default LngLatBounds;\n","// @flow\n\nimport { wrap } from '../util/util';\nimport LngLatBounds from './lng_lat_bounds';\n\n/**\n * A `LngLat` object represents a given longitude and latitude coordinate, measured in degrees.\n *\n * Mapbox GL uses longitude, latitude coordinate order (as opposed to latitude, longitude) to match GeoJSON.\n *\n * Note that any Mapbox GL method that accepts a `LngLat` object as an argument or option\n * can also accept an `Array` of two numbers and will perform an implicit conversion.\n * This flexible type is documented as {@link LngLatLike}.\n *\n * @param {number} lng Longitude, measured in degrees.\n * @param {number} lat Latitude, measured in degrees.\n * @example\n * var ll = new mapboxgl.LngLat(-73.9749, 40.7736);\n * @see [Get coordinates of the mouse pointer](https://www.mapbox.com/mapbox-gl-js/example/mouse-position/)\n * @see [Display a popup](https://www.mapbox.com/mapbox-gl-js/example/popup/)\n * @see [Highlight features within a bounding box](https://www.mapbox.com/mapbox-gl-js/example/using-box-queryrenderedfeatures/)\n * @see [Create a timeline animation](https://www.mapbox.com/mapbox-gl-js/example/timeline-animation/)\n */\nclass LngLat {\n    lng: number;\n    lat: number;\n\n    constructor(lng: number, lat: number) {\n        if (isNaN(lng) || isNaN(lat)) {\n            throw new Error(`Invalid LngLat object: (${lng}, ${lat})`);\n        }\n        this.lng = +lng;\n        this.lat = +lat;\n        if (this.lat > 90 || this.lat < -90) {\n            throw new Error('Invalid LngLat latitude value: must be between -90 and 90');\n        }\n    }\n\n    /**\n     * Returns a new `LngLat` object whose longitude is wrapped to the range (-180, 180).\n     *\n     * @returns {LngLat} The wrapped `LngLat` object.\n     * @example\n     * var ll = new mapboxgl.LngLat(286.0251, 40.7736);\n     * var wrapped = ll.wrap();\n     * wrapped.lng; // = -73.9749\n     */\n    wrap() {\n        return new LngLat(wrap(this.lng, -180, 180), this.lat);\n    }\n\n    /**\n     * Returns the coordinates represented as an array of two numbers.\n     *\n     * @returns {Array<number>} The coordinates represeted as an array of longitude and latitude.\n     * @example\n     * var ll = new mapboxgl.LngLat(-73.9749, 40.7736);\n     * ll.toArray(); // = [-73.9749, 40.7736]\n     */\n    toArray() {\n        return [this.lng, this.lat];\n    }\n\n    /**\n     * Returns the coordinates represent as a string.\n     *\n     * @returns {string} The coordinates represented as a string of the format `'LngLat(lng, lat)'`.\n     * @example\n     * var ll = new mapboxgl.LngLat(-73.9749, 40.7736);\n     * ll.toString(); // = \"LngLat(-73.9749, 40.7736)\"\n     */\n    toString() {\n        return `LngLat(${this.lng}, ${this.lat})`;\n    }\n\n    /**\n     * Returns a `LngLatBounds` from the coordinates extended by a given `radius`.\n     *\n     * @param {number} [radius=0] Distance in meters from the coordinates to extend the bounds.\n     * @returns {LngLatBounds} A new `LngLatBounds` object representing the coordinates extended by the `radius`.\n     * @example\n     * var ll = new mapboxgl.LngLat(-73.9749, 40.7736);\n     * ll.toBounds(100).toArray(); // = [[-73.97501862141328, 40.77351016847229], [-73.97478137858673, 40.77368983152771]]\n     */\n    toBounds(radius?: number = 0) {\n        const earthCircumferenceInMetersAtEquator = 40075017;\n        const latAccuracy = 360 * radius / earthCircumferenceInMetersAtEquator,\n            lngAccuracy = latAccuracy / Math.cos((Math.PI / 180) * this.lat);\n\n        return new LngLatBounds(new LngLat(this.lng - lngAccuracy, this.lat - latAccuracy),\n            new LngLat(this.lng + lngAccuracy, this.lat + latAccuracy));\n    }\n\n    /**\n     * Converts an array of two numbers or an object with `lng` and `lat` or `lon` and `lat` properties\n     * to a `LngLat` object.\n     *\n     * If a `LngLat` object is passed in, the function returns it unchanged.\n     *\n     * @param {LngLatLike} input An array of two numbers or object to convert, or a `LngLat` object to return.\n     * @returns {LngLat} A new `LngLat` object, if a conversion occurred, or the original `LngLat` object.\n     * @example\n     * var arr = [-73.9749, 40.7736];\n     * var ll = mapboxgl.LngLat.convert(arr);\n     * ll;   // = LngLat {lng: -73.9749, lat: 40.7736}\n     */\n    static convert(input: LngLatLike): LngLat {\n        if (input instanceof LngLat) {\n            return input;\n        }\n        if (Array.isArray(input) && (input.length === 2 || input.length === 3)) {\n            return new LngLat(Number(input[0]), Number(input[1]));\n        }\n        if (!Array.isArray(input) && typeof input === 'object' && input !== null) {\n            return new LngLat(\n                // flow can't refine this to have one of lng or lat, so we have to cast to any\n                Number('lng' in input ? (input: any).lng : (input: any).lon),\n                Number(input.lat)\n            );\n        }\n        throw new Error(\"`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]\");\n    }\n}\n\n/**\n * A {@link LngLat} object, an array of two numbers representing longitude and latitude,\n * or an object with `lng` and `lat` or `lon` and `lat` properties.\n *\n * @typedef {LngLat | {lng: number, lat: number} | {lon: number, lat: number} | [number, number]} LngLatLike\n * @example\n * var v1 = new mapboxgl.LngLat(-122.420679, 37.772537);\n * var v2 = [-122.420679, 37.772537];\n * var v3 = {lon: -122.420679, lat: 37.772537};\n */\nexport type LngLatLike = LngLat | {lng: number, lat: number} | {lon: number, lat: number} | [number, number];\n\nexport default LngLat;\n","// @flow\n\nimport LngLat from '../geo/lng_lat';\nimport type {LngLatLike} from '../geo/lng_lat';\n\n/*\n * The circumference of the world in meters at the given latitude.\n */\nfunction circumferenceAtLatitude(latitude: number) {\n    const circumference = 2 * Math.PI * 6378137;\n    return circumference * Math.cos(latitude * Math.PI / 180);\n}\n\nexport function mercatorXfromLng(lng: number) {\n    return (180 + lng) / 360;\n}\n\nexport function mercatorYfromLat(lat: number) {\n    return (180 - (180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360)))) / 360;\n}\n\nexport function mercatorZfromAltitude(altitude: number, lat: number) {\n    return altitude / circumferenceAtLatitude(lat);\n}\n\nexport function lngFromMercatorX(x: number) {\n    return x * 360 - 180;\n}\n\nexport function latFromMercatorY(y: number) {\n    const y2 = 180 - y * 360;\n    return 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90;\n}\n\nexport function altitudeFromMercatorZ(z: number, y: number) {\n    return z * circumferenceAtLatitude(latFromMercatorY(y));\n}\n\n/**\n * A `MercatorCoordinate` object represents a projected three dimensional position.\n *\n * `MercatorCoordinate` uses the web mercator projection ([EPSG:3857](https://epsg.io/3857)) with slightly different units:\n * - the size of 1 unit is the width of the projected world instead of the \"mercator meter\"\n * - the origin of the coordinate space is at the north-west corner instead of the middle\n *\n * For example, `MercatorCoordinate(0, 0, 0)` is the north-west corner of the mercator world and\n * `MercatorCoordinate(1, 1, 0)` is the south-east corner. If you are familiar with\n * [vector tiles](https://github.com/mapbox/vector-tile-spec) it may be helpful to think\n * of the coordinate space as the `0/0/0` tile with an extent of `1`.\n *\n * The `z` dimension of `MercatorCoordinate` is conformal. A cube in the mercator coordinate space would be rendered as a cube.\n *\n * @param {number} x The x component of the position.\n * @param {number} y The y component of the position.\n * @param {number} z The z component of the position.\n * @example\n * var nullIsland = new mapboxgl.MercatorCoordinate(0.5, 0.5, 0);\n *\n * @see [Add a custom style layer](https://www.mapbox.com/mapbox-gl-js/example/custom-style-layer/)\n */\nclass MercatorCoordinate {\n    x: number;\n    y: number;\n    z: number;\n\n    constructor(x: number, y: number, z: number = 0) {\n        this.x = +x;\n        this.y = +y;\n        this.z = +z;\n    }\n\n    /**\n     * Project a `LngLat` to a `MercatorCoordinate`.\n     *\n     * @param {LngLatLike} lngLatLike The location to project.\n     * @param {number} altitude The altitude in meters of the position.\n     * @returns {MercatorCoordinate} The projected mercator coordinate.\n     * @example\n     * var coord = mapboxgl.MercatorCoordinate.fromLngLat({ lng: 0, lat: 0}, 0);\n     * coord; // MercatorCoordinate(0.5, 0.5, 0)\n     */\n    static fromLngLat(lngLatLike: LngLatLike, altitude: number = 0) {\n        const lngLat = LngLat.convert(lngLatLike);\n\n        return new MercatorCoordinate(\n                mercatorXfromLng(lngLat.lng),\n                mercatorYfromLat(lngLat.lat),\n                mercatorZfromAltitude(altitude, lngLat.lat));\n    }\n\n    /**\n     * Returns the `LngLat` for the coordinate.\n     *\n     * @returns {LngLat} The `LngLat` object.\n     * @example\n     * var coord = new mapboxgl.MercatorCoordinate(0.5, 0.5, 0);\n     * var latLng = coord.toLngLat(); // LngLat(0, 0)\n     */\n    toLngLat() {\n        return new LngLat(\n                lngFromMercatorX(this.x),\n                latFromMercatorY(this.y));\n    }\n\n    /**\n     * Returns the altitude in meters of the coordinate.\n     *\n     * @returns {number} The altitude in meters.\n     * @example\n     * var coord = new mapboxgl.MercatorCoordinate(0, 0, 0.02);\n     * coord.toAltitude(); // 6914.281956295339\n     */\n    toAltitude() {\n        return altitudeFromMercatorZ(this.z, this.y);\n    }\n}\n\nexport default MercatorCoordinate;\n","// @flow\n\nimport {getTileBBox} from '@mapbox/whoots-js';\nimport EXTENT from '../data/extent';\nimport Point from '@mapbox/point-geometry';\nimport MercatorCoordinate from '../geo/mercator_coordinate';\n\nimport assert from 'assert';\nimport { register } from '../util/web_worker_transfer';\n\nexport class CanonicalTileID {\n    z: number;\n    x: number;\n    y: number;\n    key: number;\n\n    constructor(z: number, x: number, y: number) {\n        assert(z >= 0 && z <= 25);\n        assert(x >= 0 && x < Math.pow(2, z));\n        assert(y >= 0 && y < Math.pow(2, z));\n        this.z = z;\n        this.x = x;\n        this.y = y;\n        this.key = calculateKey(0, z, x, y);\n    }\n\n    equals(id: CanonicalTileID) {\n        return this.z === id.z && this.x === id.x && this.y === id.y;\n    }\n\n    // given a list of urls, choose a url template and return a tile URL\n    url(urls: Array<string>, scheme: ?string) {\n        const bbox = getTileBBox(this.x, this.y, this.z);\n        const quadkey = getQuadkey(this.z, this.x, this.y);\n\n        return urls[(this.x + this.y) % urls.length]\n            .replace('{prefix}', (this.x % 16).toString(16) + (this.y % 16).toString(16))\n            .replace('{z}', String(this.z))\n            .replace('{x}', String(this.x))\n            .replace('{y}', String(scheme === 'tms' ? (Math.pow(2, this.z) - this.y - 1) : this.y))\n            .replace('{quadkey}', quadkey)\n            .replace('{bbox-epsg-3857}', bbox);\n    }\n\n    getTilePoint(coord: MercatorCoordinate) {\n        const tilesAtZoom = Math.pow(2, this.z);\n        return new Point(\n            (coord.x * tilesAtZoom - this.x) * EXTENT,\n            (coord.y * tilesAtZoom - this.y) * EXTENT);\n    }\n}\n\nexport class UnwrappedTileID {\n    wrap: number;\n    canonical: CanonicalTileID;\n    key: number;\n\n    constructor(wrap: number, canonical: CanonicalTileID) {\n        this.wrap = wrap;\n        this.canonical = canonical;\n        this.key = calculateKey(wrap, canonical.z, canonical.x, canonical.y);\n    }\n}\n\nexport class OverscaledTileID {\n    overscaledZ: number;\n    wrap: number;\n    canonical: CanonicalTileID;\n    key: number;\n    posMatrix: Float32Array;\n\n    constructor(overscaledZ: number, wrap: number, z: number, x: number, y: number) {\n        assert(overscaledZ >= z);\n        this.overscaledZ = overscaledZ;\n        this.wrap = wrap;\n        this.canonical = new CanonicalTileID(z, +x, +y);\n        this.key = calculateKey(wrap, overscaledZ, x, y);\n    }\n\n    equals(id: OverscaledTileID) {\n        return this.overscaledZ === id.overscaledZ && this.wrap === id.wrap && this.canonical.equals(id.canonical);\n    }\n\n    scaledTo(targetZ: number) {\n        assert(targetZ <= this.overscaledZ);\n        const zDifference = this.canonical.z - targetZ;\n        if (targetZ > this.canonical.z) {\n            return new OverscaledTileID(targetZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);\n        } else {\n            return new OverscaledTileID(targetZ, this.wrap, targetZ, this.canonical.x >> zDifference, this.canonical.y >> zDifference);\n        }\n    }\n\n    isChildOf(parent: OverscaledTileID) {\n        if (parent.wrap !== this.wrap) {\n            // We can't be a child if we're in a different world copy\n            return false;\n        }\n        const zDifference = this.canonical.z - parent.canonical.z;\n        // We're first testing for z == 0, to avoid a 32 bit shift, which is undefined.\n        return parent.overscaledZ === 0 || (\n            parent.overscaledZ < this.overscaledZ &&\n                parent.canonical.x === (this.canonical.x >> zDifference) &&\n                parent.canonical.y === (this.canonical.y >> zDifference));\n    }\n\n    children(sourceMaxZoom: number) {\n        if (this.overscaledZ >= sourceMaxZoom) {\n            // return a single tile coord representing a an overscaled tile\n            return [new OverscaledTileID(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];\n        }\n\n        const z = this.canonical.z + 1;\n        const x = this.canonical.x * 2;\n        const y = this.canonical.y * 2;\n        return [\n            new OverscaledTileID(z, this.wrap, z, x, y),\n            new OverscaledTileID(z, this.wrap, z, x + 1, y),\n            new OverscaledTileID(z, this.wrap, z, x, y + 1),\n            new OverscaledTileID(z, this.wrap, z, x + 1, y + 1)\n        ];\n    }\n\n    isLessThan(rhs: OverscaledTileID) {\n        if (this.wrap < rhs.wrap) return true;\n        if (this.wrap > rhs.wrap) return false;\n\n        if (this.overscaledZ < rhs.overscaledZ) return true;\n        if (this.overscaledZ > rhs.overscaledZ) return false;\n\n        if (this.canonical.x < rhs.canonical.x) return true;\n        if (this.canonical.x > rhs.canonical.x) return false;\n\n        if (this.canonical.y < rhs.canonical.y) return true;\n        return false;\n    }\n\n    wrapped() {\n        return new OverscaledTileID(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);\n    }\n\n    unwrapTo(wrap: number) {\n        return new OverscaledTileID(this.overscaledZ, wrap, this.canonical.z, this.canonical.x, this.canonical.y);\n    }\n\n    overscaleFactor() {\n        return Math.pow(2, this.overscaledZ - this.canonical.z);\n    }\n\n    toUnwrapped() {\n        return new UnwrappedTileID(this.wrap, this.canonical);\n    }\n\n    toString() {\n        return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;\n    }\n\n    getTilePoint(coord: MercatorCoordinate) {\n        return this.canonical.getTilePoint(new MercatorCoordinate(coord.x - this.wrap, coord.y));\n    }\n}\n\nfunction calculateKey(wrap: number, z: number, x: number, y: number) {\n    wrap *= 2;\n    if (wrap < 0) wrap = wrap * -1 - 1;\n    const dim = 1 << z;\n    return ((dim * dim * wrap + dim * y + x) * 32) + z;\n}\n\n\nfunction getQuadkey(z, x, y) {\n    let quadkey = '', mask;\n    for (let i = z; i > 0; i--) {\n        mask = 1 << (i - 1);\n        quadkey += ((x & mask ? 1 : 0) + (y & mask ? 2 : 0));\n    }\n    return quadkey;\n}\n\nregister('CanonicalTileID', CanonicalTileID);\nregister('OverscaledTileID', OverscaledTileID, {omit: ['posMatrix']});\n","// @flow\nimport { RGBAImage } from '../util/image';\n\nimport { warnOnce } from '../util/util';\nimport { register } from '../util/web_worker_transfer';\n\n// DEMData is a data structure for decoding, backfilling, and storing elevation data for processing in the hillshade shaders\n// data can be populated either from a pngraw image tile or from serliazed data sent back from a worker. When data is initially\n// loaded from a image tile, we decode the pixel values using the appropriate decoding formula, but we store the\n// elevation data as an Int32 value. we add 65536 (2^16) to eliminate negative values and enable the use of\n// integer overflow when creating the texture used in the hillshadePrepare step.\n\n// DEMData also handles the backfilling of data from a tile's neighboring tiles. This is necessary because we use a pixel's 8\n// surrounding pixel values to compute the slope at that pixel, and we cannot accurately calculate the slope at pixels on a\n// tile's edge without backfilling from neighboring tiles.\n\nexport default class DEMData {\n    uid: string;\n    data: Int32Array;\n    stride: number;\n    dim: number;\n\n    constructor(uid: string, data: RGBAImage, encoding: \"mapbox\" | \"terrarium\") {\n        this.uid = uid;\n        if (data.height !== data.width) throw new RangeError('DEM tiles must be square');\n        if (encoding && encoding !== \"mapbox\" && encoding !== \"terrarium\") return warnOnce(\n            `\"${encoding}\" is not a valid encoding type. Valid types include \"mapbox\" and \"terrarium\".`\n        );\n        const dim = this.dim = data.height;\n        this.stride = this.dim + 2;\n        this.data = new Int32Array(this.stride * this.stride);\n\n        const pixels = data.data;\n        const unpack = encoding === \"terrarium\" ? this._unpackTerrarium : this._unpackMapbox;\n        for (let y = 0; y < dim; y++) {\n            for (let x = 0; x < dim; x++) {\n                const i = y * dim + x;\n                const j = i * 4;\n                this.set(x, y, unpack(pixels[j], pixels[j + 1], pixels[j + 2]));\n            }\n        }\n\n        // in order to avoid flashing seams between tiles, here we are initially populating a 1px border of pixels around the image\n        // with the data of the nearest pixel from the image. this data is eventually replaced when the tile's neighboring\n        // tiles are loaded and the accurate data can be backfilled using DEMData#backfillBorder\n        for (let x = 0; x < dim; x++) {\n            // left vertical border\n            this.set(-1, x, this.get(0, x));\n            // right vertical border\n            this.set(dim, x, this.get(dim - 1, x));\n            // left horizontal border\n            this.set(x, -1, this.get(x, 0));\n            // right horizontal border\n            this.set(x, dim, this.get(x, dim - 1));\n        }\n        // corners\n        this.set(-1, -1, this.get(0, 0));\n        this.set(dim, -1, this.get(dim - 1, 0));\n        this.set(-1, dim, this.get(0, dim - 1));\n        this.set(dim, dim, this.get(dim - 1, dim - 1));\n    }\n\n    set(x: number, y: number, value: number) {\n        this.data[this._idx(x, y)] = value + 65536;\n    }\n\n    get(x: number, y: number) {\n        return this.data[this._idx(x, y)] - 65536;\n    }\n\n    _idx(x: number, y: number) {\n        if (x < -1 || x >= this.dim + 1 ||  y < -1 || y >= this.dim + 1) throw new RangeError('out of range source coordinates for DEM data');\n        return (y + 1) * this.stride + (x + 1);\n    }\n\n    _unpackMapbox(r: number, g: number, b: number) {\n        // unpacking formula for mapbox.terrain-rgb:\n        // https://www.mapbox.com/help/access-elevation-data/#mapbox-terrain-rgb\n        return ((r * 256 * 256 + g * 256.0 + b) / 10.0 - 10000.0);\n    }\n\n    _unpackTerrarium(r: number, g: number, b: number) {\n        // unpacking formula for mapzen terrarium:\n        // https://aws.amazon.com/public-datasets/terrain/\n        return ((r * 256 + g + b / 256) - 32768.0);\n    }\n\n    getPixels() {\n        return new RGBAImage({width: this.stride, height: this.stride}, new Uint8Array(this.data.buffer));\n    }\n\n    backfillBorder(borderTile: DEMData, dx: number, dy: number) {\n        if (this.dim !== borderTile.dim) throw new Error('dem dimension mismatch');\n\n        let xMin = dx * this.dim,\n            xMax = dx * this.dim + this.dim,\n            yMin = dy * this.dim,\n            yMax = dy * this.dim + this.dim;\n\n        switch (dx) {\n        case -1:\n            xMin = xMax - 1;\n            break;\n        case 1:\n            xMax = xMin + 1;\n            break;\n        }\n\n        switch (dy) {\n        case -1:\n            yMin = yMax - 1;\n            break;\n        case 1:\n            yMax = yMin + 1;\n            break;\n        }\n\n        const ox = -dx * this.dim;\n        const oy = -dy * this.dim;\n        for (let y = yMin; y < yMax; y++) {\n            for (let x = xMin; x < xMax; x++) {\n                this.set(x, y, borderTile.get(x + ox, y + oy));\n            }\n        }\n    }\n}\n\nregister('DEMData', DEMData);\n","// @flow\n\nimport assert from 'assert';\n\nclass DictionaryCoder {\n    _stringToNumber: { [string]: number };\n    _numberToString: Array<string>;\n\n    constructor(strings: Array<string>) {\n        this._stringToNumber = {};\n        this._numberToString = [];\n        for (let i = 0; i < strings.length; i++) {\n            const string = strings[i];\n            this._stringToNumber[string] = i;\n            this._numberToString[i] = string;\n        }\n    }\n\n    encode(string: string) {\n        assert(string in this._stringToNumber);\n        return this._stringToNumber[string];\n    }\n\n    decode(n: number) {\n        assert(n < this._numberToString.length);\n        return this._numberToString[n];\n    }\n}\n\nexport default DictionaryCoder;\n","// @flow\nimport type {GeoJSONGeometry} from '@mapbox/geojson-types';\n\nclass Feature {\n    type: 'Feature';\n    _geometry: ?GeoJSONGeometry;\n    properties: {};\n    id: number | string | void;\n\n    _vectorTileFeature: VectorTileFeature;\n\n    constructor(vectorTileFeature: VectorTileFeature, z: number, x: number, y: number) {\n        this.type = 'Feature';\n\n        this._vectorTileFeature = vectorTileFeature;\n        (vectorTileFeature: any)._z = z;\n        (vectorTileFeature: any)._x = x;\n        (vectorTileFeature: any)._y = y;\n\n        this.properties = vectorTileFeature.properties;\n\n        if (vectorTileFeature.id != null) {\n            this.id = vectorTileFeature.id;\n        }\n    }\n\n    get geometry(): ?GeoJSONGeometry {\n        if (this._geometry === undefined) {\n            this._geometry = this._vectorTileFeature.toGeoJSON(\n                (this._vectorTileFeature: any)._x,\n                (this._vectorTileFeature: any)._y,\n                (this._vectorTileFeature: any)._z).geometry;\n        }\n        return this._geometry;\n    }\n\n    set geometry(g: ?GeoJSONGeometry) {\n        this._geometry = g;\n    }\n\n    toJSON() {\n        const json = {\n            geometry: this.geometry\n        };\n        for (const i in this) {\n            if (i === '_geometry' || i === '_vectorTileFeature') continue;\n            json[i] = (this: any)[i];\n        }\n        return json;\n    }\n}\n\nexport default Feature;\n","// @flow\n\nimport { extend } from '../util/util';\nimport Tile from './tile';\nimport type {FeatureState} from '../style-spec/expression';\n\nexport type FeatureStates = {[feature_id: string]: FeatureState};\nexport type LayerFeatureStates = {[layer: string]: FeatureStates};\n\n/**\n * SourceFeatureState manages the state and state changes\n * to features in a source, separated by source layer.\n *\n * @private\n*/\nclass SourceFeatureState {\n    state: LayerFeatureStates;\n    stateChanges: LayerFeatureStates;\n\n    constructor() {\n        this.state = {};\n        this.stateChanges = {};\n    }\n\n    updateState(sourceLayer: string, featureId: number, state: Object) {\n        const feature = String(featureId);\n        this.stateChanges[sourceLayer] = this.stateChanges[sourceLayer] || {};\n        this.stateChanges[sourceLayer][feature] = this.stateChanges[sourceLayer][feature] || {};\n        extend(this.stateChanges[sourceLayer][feature], state);\n    }\n\n    getState(sourceLayer: string, featureId: number) {\n        const feature = String(featureId);\n        const base = this.state[sourceLayer] || {};\n        const changes = this.stateChanges[sourceLayer] || {};\n        return extend({}, base[feature], changes[feature]);\n    }\n\n    initializeTileState(tile: Tile, painter: any) {\n        tile.setFeatureState(this.state, painter);\n    }\n\n    coalesceChanges(tiles: {[any]: Tile}, painter: any) {\n        const changes: LayerFeatureStates = {};\n        for (const sourceLayer in this.stateChanges) {\n            this.state[sourceLayer]  = this.state[sourceLayer] || {};\n            const layerStates = {};\n            for (const id in this.stateChanges[sourceLayer]) {\n                if (!this.state[sourceLayer][id]) {\n                    this.state[sourceLayer][id] = {};\n                }\n                extend(this.state[sourceLayer][id], this.stateChanges[sourceLayer][id]);\n                layerStates[id] = this.state[sourceLayer][id];\n            }\n            changes[sourceLayer] = layerStates;\n        }\n        this.stateChanges = {};\n        if (Object.keys(changes).length === 0) return;\n\n        for (const id in tiles) {\n            const tile = tiles[id];\n            tile.setFeatureState(changes, painter);\n        }\n    }\n}\n\nexport default SourceFeatureState;\n","// @flow\n\nimport Point from '@mapbox/point-geometry';\n\nimport loadGeometry from './load_geometry';\nimport EXTENT from './extent';\nimport featureFilter from '../style-spec/feature_filter';\nimport Grid from 'grid-index';\nimport DictionaryCoder from '../util/dictionary_coder';\nimport vt from '@mapbox/vector-tile';\nimport Protobuf from 'pbf';\nimport GeoJSONFeature from '../util/vectortile_to_geojson';\nimport { arraysIntersect } from '../util/util';\nimport { OverscaledTileID } from '../source/tile_id';\nimport { register } from '../util/web_worker_transfer';\nimport EvaluationParameters from '../style/evaluation_parameters';\nimport SourceFeatureState from '../source/source_state';\nimport {polygonIntersectsBox} from '../util/intersection_tests';\n\nimport type StyleLayer from '../style/style_layer';\nimport type {FeatureFilter} from '../style-spec/feature_filter';\nimport type Transform from '../geo/transform';\nimport type {FilterSpecification} from '../style-spec/types';\n\nimport { FeatureIndexArray } from './array_types';\n\ntype QueryParameters = {\n    scale: number,\n    pixelPosMatrix: Float32Array,\n    transform: Transform,\n    tileSize: number,\n    queryGeometry: Array<Point>,\n    cameraQueryGeometry: Array<Point>,\n    queryPadding: number,\n    params: {\n        filter: FilterSpecification,\n        layers: Array<string>,\n    }\n}\n\nclass FeatureIndex {\n    tileID: OverscaledTileID;\n    x: number;\n    y: number;\n    z: number;\n    grid: Grid;\n    grid3D: Grid;\n    featureIndexArray: FeatureIndexArray;\n\n    rawTileData: ArrayBuffer;\n    bucketLayerIDs: Array<Array<string>>;\n\n    vtLayers: {[string]: VectorTileLayer};\n    sourceLayerCoder: DictionaryCoder;\n\n    constructor(tileID: OverscaledTileID,\n                grid?: Grid,\n                featureIndexArray?: FeatureIndexArray) {\n        this.tileID = tileID;\n        this.x = tileID.canonical.x;\n        this.y = tileID.canonical.y;\n        this.z = tileID.canonical.z;\n        this.grid = grid || new Grid(EXTENT, 16, 0);\n        this.grid3D = new Grid(EXTENT, 16, 0);\n        this.featureIndexArray = featureIndexArray || new FeatureIndexArray();\n    }\n\n    insert(feature: VectorTileFeature, geometry: Array<Array<Point>>, featureIndex: number, sourceLayerIndex: number, bucketIndex: number, is3D?: boolean) {\n        const key = this.featureIndexArray.length;\n        this.featureIndexArray.emplaceBack(featureIndex, sourceLayerIndex, bucketIndex);\n\n        const grid = is3D ? this.grid3D : this.grid;\n\n        for (let r = 0; r < geometry.length; r++) {\n            const ring = geometry[r];\n\n            const bbox = [Infinity, Infinity, -Infinity, -Infinity];\n            for (let i = 0; i < ring.length; i++) {\n                const p = ring[i];\n                bbox[0] = Math.min(bbox[0], p.x);\n                bbox[1] = Math.min(bbox[1], p.y);\n                bbox[2] = Math.max(bbox[2], p.x);\n                bbox[3] = Math.max(bbox[3], p.y);\n            }\n\n            if (bbox[0] < EXTENT &&\n                bbox[1] < EXTENT &&\n                bbox[2] >= 0 &&\n                bbox[3] >= 0) {\n                grid.insert(key, bbox[0], bbox[1], bbox[2], bbox[3]);\n            }\n        }\n    }\n\n    loadVTLayers(): {[string]: VectorTileLayer} {\n        if (!this.vtLayers) {\n            this.vtLayers = new vt.VectorTile(new Protobuf(this.rawTileData)).layers;\n            this.sourceLayerCoder = new DictionaryCoder(this.vtLayers ? Object.keys(this.vtLayers).sort() : ['_geojsonTileLayer']);\n        }\n        return this.vtLayers;\n    }\n\n    // Finds non-symbol features in this tile at a particular position.\n    query(args: QueryParameters, styleLayers: {[string]: StyleLayer}, sourceFeatureState: SourceFeatureState): {[string]: Array<{ featureIndex: number, feature: GeoJSONFeature }>} {\n        this.loadVTLayers();\n\n        const params = args.params || {},\n            pixelsToTileUnits = EXTENT / args.tileSize / args.scale,\n            filter = featureFilter(params.filter);\n\n        const queryGeometry = args.queryGeometry;\n        const queryPadding = args.queryPadding * pixelsToTileUnits;\n\n        const bounds = getBounds(queryGeometry);\n        const matching = this.grid.query(bounds.minX - queryPadding, bounds.minY - queryPadding, bounds.maxX + queryPadding, bounds.maxY + queryPadding);\n\n        const cameraBounds = getBounds(args.cameraQueryGeometry);\n        const matching3D = this.grid3D.query(\n                cameraBounds.minX - queryPadding, cameraBounds.minY - queryPadding, cameraBounds.maxX + queryPadding, cameraBounds.maxY + queryPadding,\n                (bx1, by1, bx2, by2) => {\n                    return polygonIntersectsBox(args.cameraQueryGeometry, bx1 - queryPadding, by1 - queryPadding, bx2 + queryPadding, by2 + queryPadding);\n                });\n\n        for (const key of matching3D) {\n            matching.push(key);\n        }\n\n        matching.sort(topDownFeatureComparator);\n\n        const result = {};\n        let previousIndex;\n        for (let k = 0; k < matching.length; k++) {\n            const index = matching[k];\n\n            // don't check the same feature more than once\n            if (index === previousIndex) continue;\n            previousIndex = index;\n\n            const match = this.featureIndexArray.get(index);\n            let featureGeometry = null;\n            this.loadMatchingFeature(\n                result,\n                match.bucketIndex,\n                match.sourceLayerIndex,\n                match.featureIndex,\n                filter,\n                params.layers,\n                styleLayers,\n                (feature: VectorTileFeature, styleLayer: StyleLayer) => {\n                    if (!featureGeometry) {\n                        featureGeometry = loadGeometry(feature);\n                    }\n                    let featureState = {};\n                    if (feature.id) {\n                        // `feature-state` expression evaluation requires feature state to be available\n                        featureState = sourceFeatureState.getState(styleLayer.sourceLayer || '_geojsonTileLayer', feature.id);\n                    }\n                    return styleLayer.queryIntersectsFeature(queryGeometry, feature, featureState, featureGeometry, this.z, args.transform, pixelsToTileUnits, args.pixelPosMatrix);\n                }\n            );\n        }\n\n        return result;\n    }\n\n    loadMatchingFeature(\n        result: {[string]: Array<{ featureIndex: number, feature: GeoJSONFeature }>},\n        bucketIndex: number,\n        sourceLayerIndex: number,\n        featureIndex: number,\n        filter: FeatureFilter,\n        filterLayerIDs: Array<string>,\n        styleLayers: {[string]: StyleLayer},\n        intersectionTest?: (feature: VectorTileFeature, styleLayer: StyleLayer) => boolean | number) {\n\n        const layerIDs = this.bucketLayerIDs[bucketIndex];\n        if (filterLayerIDs && !arraysIntersect(filterLayerIDs, layerIDs))\n            return;\n\n        const sourceLayerName = this.sourceLayerCoder.decode(sourceLayerIndex);\n        const sourceLayer = this.vtLayers[sourceLayerName];\n        const feature = sourceLayer.feature(featureIndex);\n\n        if (!filter(new EvaluationParameters(this.tileID.overscaledZ), feature))\n            return;\n\n        for (let l = 0; l < layerIDs.length; l++) {\n            const layerID = layerIDs[l];\n\n            if (filterLayerIDs && filterLayerIDs.indexOf(layerID) < 0) {\n                continue;\n            }\n\n            const styleLayer = styleLayers[layerID];\n            if (!styleLayer) continue;\n\n            const intersectionZ = !intersectionTest || intersectionTest(feature, styleLayer);\n            if (!intersectionZ) {\n                // Only applied for non-symbol features\n                continue;\n            }\n\n            const geojsonFeature = new GeoJSONFeature(feature, this.z, this.x, this.y);\n            (geojsonFeature: any).layer = styleLayer.serialize();\n            let layerResult = result[layerID];\n            if (layerResult === undefined) {\n                layerResult = result[layerID] = [];\n            }\n            layerResult.push({ featureIndex, feature: geojsonFeature, intersectionZ });\n        }\n    }\n\n    // Given a set of symbol indexes that have already been looked up,\n    // return a matching set of GeoJSONFeatures\n    lookupSymbolFeatures(symbolFeatureIndexes: Array<number>,\n                         bucketIndex: number,\n                         sourceLayerIndex: number,\n                         filterSpec: FilterSpecification,\n                         filterLayerIDs: Array<string>,\n                         styleLayers: {[string]: StyleLayer}) {\n        const result = {};\n        this.loadVTLayers();\n\n        const filter = featureFilter(filterSpec);\n\n        for (const symbolFeatureIndex of symbolFeatureIndexes) {\n            this.loadMatchingFeature(\n                result,\n                bucketIndex,\n                sourceLayerIndex,\n                symbolFeatureIndex,\n                filter,\n                filterLayerIDs,\n                styleLayers\n            );\n\n        }\n        return result;\n    }\n\n    hasLayer(id: string) {\n        for (const layerIDs of this.bucketLayerIDs) {\n            for (const layerID of layerIDs) {\n                if (id === layerID) return true;\n            }\n        }\n\n        return false;\n    }\n}\n\nregister(\n    'FeatureIndex',\n    FeatureIndex,\n    { omit: ['rawTileData', 'sourceLayerCoder'] }\n);\n\nexport default FeatureIndex;\n\nfunction getBounds(geometry: Array<Point>) {\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n    for (const p of geometry) {\n        minX = Math.min(minX, p.x);\n        minY = Math.min(minY, p.y);\n        maxX = Math.max(maxX, p.x);\n        maxY = Math.max(maxY, p.y);\n    }\n    return { minX, minY, maxX, maxY };\n}\n\nfunction topDownFeatureComparator(a, b) {\n    return b - a;\n}\n","// @flow\n\nimport UnitBezier from '@mapbox/unitbezier';\n\nimport Point from '@mapbox/point-geometry';\nimport window from './window';\n\nimport type {Callback} from '../types/callback';\n\n/**\n * @module util\n * @private\n */\n\n/**\n * Given a value `t` that varies between 0 and 1, return\n * an interpolation function that eases between 0 and 1 in a pleasing\n * cubic in-out fashion.\n *\n * @private\n */\nexport function easeCubicInOut(t: number): number {\n    if (t <= 0) return 0;\n    if (t >= 1) return 1;\n    const t2 = t * t,\n        t3 = t2 * t;\n    return 4 * (t < 0.5 ? t3 : 3 * (t - t2) + t3 - 0.75);\n}\n\n/**\n * Given given (x, y), (x1, y1) control points for a bezier curve,\n * return a function that interpolates along that curve.\n *\n * @param p1x control point 1 x coordinate\n * @param p1y control point 1 y coordinate\n * @param p2x control point 2 x coordinate\n * @param p2y control point 2 y coordinate\n * @private\n */\nexport function bezier(p1x: number, p1y: number, p2x: number, p2y: number): (t: number) => number {\n    const bezier = new UnitBezier(p1x, p1y, p2x, p2y);\n    return function(t: number) {\n        return bezier.solve(t);\n    };\n}\n\n/**\n * A default bezier-curve powered easing function with\n * control points (0.25, 0.1) and (0.25, 1)\n *\n * @private\n */\nexport const ease = bezier(0.25, 0.1, 0.25, 1);\n\n/**\n * constrain n to the given range via min + max\n *\n * @param n value\n * @param min the minimum value to be returned\n * @param max the maximum value to be returned\n * @returns the clamped value\n * @private\n */\nexport function clamp(n: number, min: number, max: number): number {\n    return Math.min(max, Math.max(min, n));\n}\n\n/**\n * constrain n to the given range, excluding the minimum, via modular arithmetic\n *\n * @param n value\n * @param min the minimum value to be returned, exclusive\n * @param max the maximum value to be returned, inclusive\n * @returns constrained number\n * @private\n */\nexport function wrap(n: number, min: number, max: number): number {\n    const d = max - min;\n    const w = ((n - min) % d + d) % d + min;\n    return (w === min) ? max : w;\n}\n\n/*\n * Call an asynchronous function on an array of arguments,\n * calling `callback` with the completed results of all calls.\n *\n * @param array input to each call of the async function.\n * @param fn an async function with signature (data, callback)\n * @param callback a callback run after all async work is done.\n * called with an array, containing the results of each async call.\n * @private\n */\nexport function asyncAll<Item, Result>(\n    array: Array<Item>,\n    fn: (item: Item, fnCallback: Callback<Result>) => void,\n    callback: Callback<Array<Result>>\n) {\n    if (!array.length) { return callback(null, []); }\n    let remaining = array.length;\n    const results = new Array(array.length);\n    let error = null;\n    array.forEach((item, i) => {\n        fn(item, (err, result) => {\n            if (err) error = err;\n            results[i] = ((result: any): Result); // https://github.com/facebook/flow/issues/2123\n            if (--remaining === 0) callback(error, results);\n        });\n    });\n}\n\n/*\n * Polyfill for Object.values. Not fully spec compliant, but we don't\n * need it to be.\n *\n * @private\n */\nexport function values<T>(obj: {[key: string]: T}): Array<T> {\n    const result = [];\n    for (const k in obj) {\n        result.push(obj[k]);\n    }\n    return result;\n}\n\n/*\n * Compute the difference between the keys in one object and the keys\n * in another object.\n *\n * @returns keys difference\n * @private\n */\nexport function keysDifference<S, T>(obj: {[key: string]: S}, other: {[key: string]: T}): Array<string> {\n    const difference = [];\n    for (const i in obj) {\n        if (!(i in other)) {\n            difference.push(i);\n        }\n    }\n    return difference;\n}\n\n/**\n * Given a destination object and optionally many source objects,\n * copy all properties from the source objects into the destination.\n * The last source object given overrides properties from previous\n * source objects.\n *\n * @param dest destination object\n * @param sources sources from which properties are pulled\n * @private\n */\nexport function extend(dest: Object, ...sources: Array<?Object>): Object {\n    for (const src of sources) {\n        for (const k in src) {\n            dest[k] = src[k];\n        }\n    }\n    return dest;\n}\n\n/**\n * Given an object and a number of properties as strings, return version\n * of that object with only those properties.\n *\n * @param src the object\n * @param properties an array of property names chosen\n * to appear on the resulting object.\n * @returns object with limited properties.\n * @example\n * var foo = { name: 'Charlie', age: 10 };\n * var justName = pick(foo, ['name']);\n * // justName = { name: 'Charlie' }\n * @private\n */\nexport function pick(src: Object, properties: Array<string>): Object {\n    const result = {};\n    for (let i = 0; i < properties.length; i++) {\n        const k = properties[i];\n        if (k in src) {\n            result[k] = src[k];\n        }\n    }\n    return result;\n}\n\nlet id = 1;\n\n/**\n * Return a unique numeric id, starting at 1 and incrementing with\n * each call.\n *\n * @returns unique numeric id.\n * @private\n */\nexport function uniqueId(): number {\n    return id++;\n}\n\n/**\n * Return a random UUID (v4). Taken from: https://gist.github.com/jed/982883\n * @private\n */\nexport function uuid(): string {\n    function b(a) {\n        return a ? (a ^ Math.random() * 16 >> a / 4).toString(16) :\n        //$FlowFixMe: Flow doesn't like the implied array literal conversion here\n            ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, b);\n    }\n    return b();\n}\n\n/**\n * Validate a string to match UUID(v4) of the\n * form: xxxxxxxx-xxxx-4xxx-[89ab]xxx-xxxxxxxxxxxx\n * @param str string to validate.\n * @private\n */\nexport function validateUuid(str: ?string): boolean {\n    return str ? /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(str) : false;\n}\n\n/**\n * Given an array of member function names as strings, replace all of them\n * with bound versions that will always refer to `context` as `this`. This\n * is useful for classes where otherwise event bindings would reassign\n * `this` to the evented object or some other value: this lets you ensure\n * the `this` value always.\n *\n * @param fns list of member function names\n * @param context the context value\n * @example\n * function MyClass() {\n *   bindAll(['ontimer'], this);\n *   this.name = 'Tom';\n * }\n * MyClass.prototype.ontimer = function() {\n *   alert(this.name);\n * };\n * var myClass = new MyClass();\n * setTimeout(myClass.ontimer, 100);\n * @private\n */\nexport function bindAll(fns: Array<string>, context: Object): void {\n    fns.forEach((fn) => {\n        if (!context[fn]) { return; }\n        context[fn] = context[fn].bind(context);\n    });\n}\n\n/**\n * Determine if a string ends with a particular substring\n *\n * @private\n */\nexport function endsWith(string: string, suffix: string): boolean {\n    return string.indexOf(suffix, string.length - suffix.length) !== -1;\n}\n\n/**\n * Create an object by mapping all the values of an existing object while\n * preserving their keys.\n *\n * @private\n */\nexport function mapObject(input: Object, iterator: Function, context?: Object): Object {\n    const output = {};\n    for (const key in input) {\n        output[key] = iterator.call(context || this, input[key], key, input);\n    }\n    return output;\n}\n\n/**\n * Create an object by filtering out values of an existing object.\n *\n * @private\n */\nexport function filterObject(input: Object, iterator: Function, context?: Object): Object {\n    const output = {};\n    for (const key in input) {\n        if (iterator.call(context || this, input[key], key, input)) {\n            output[key] = input[key];\n        }\n    }\n    return output;\n}\n\nimport deepEqual from '../style-spec/util/deep_equal';\nexport { deepEqual };\n\n/**\n * Deeply clones two objects.\n *\n * @private\n */\nexport function clone<T>(input: T): T {\n    if (Array.isArray(input)) {\n        return input.map(clone);\n    } else if (typeof input === 'object' && input) {\n        return ((mapObject(input, clone): any): T);\n    } else {\n        return input;\n    }\n}\n\n/**\n * Check if two arrays have at least one common element.\n *\n * @private\n */\nexport function arraysIntersect<T>(a: Array<T>, b: Array<T>): boolean {\n    for (let l = 0; l < a.length; l++) {\n        if (b.indexOf(a[l]) >= 0) return true;\n    }\n    return false;\n}\n\n/**\n * Print a warning message to the console and ensure duplicate warning messages\n * are not printed.\n *\n * @private\n */\nconst warnOnceHistory: {[key: string]: boolean} = {};\n\nexport function warnOnce(message: string): void {\n    if (!warnOnceHistory[message]) {\n        // console isn't defined in some WebWorkers, see #2558\n        if (typeof console !== \"undefined\") console.warn(message);\n        warnOnceHistory[message] = true;\n    }\n}\n\n/**\n * Indicates if the provided Points are in a counter clockwise (true) or clockwise (false) order\n *\n * @private\n * @returns true for a counter clockwise set of points\n */\n// http://bryceboe.com/2006/10/23/line-segment-intersection-algorithm/\nexport function isCounterClockwise(a: Point, b: Point, c: Point): boolean {\n    return (c.y - a.y) * (b.x - a.x) > (b.y - a.y) * (c.x - a.x);\n}\n\n/**\n * Returns the signed area for the polygon ring.  Postive areas are exterior rings and\n * have a clockwise winding.  Negative areas are interior rings and have a counter clockwise\n * ordering.\n *\n * @private\n * @param ring Exterior or interior ring\n */\nexport function calculateSignedArea(ring: Array<Point>): number {\n    let sum = 0;\n    for (let i = 0, len = ring.length, j = len - 1, p1, p2; i < len; j = i++) {\n        p1 = ring[i];\n        p2 = ring[j];\n        sum += (p2.x - p1.x) * (p1.y + p2.y);\n    }\n    return sum;\n}\n\n/**\n * Detects closed polygons, first + last point are equal\n *\n * @private\n * @param points array of points\n * @return true if the points are a closed polygon\n */\nexport function isClosedPolygon(points: Array<Point>): boolean {\n    // If it is 2 points that are the same then it is a point\n    // If it is 3 points with start and end the same then it is a line\n    if (points.length < 4)\n        return false;\n\n    const p1 = points[0];\n    const p2 = points[points.length - 1];\n\n    if (Math.abs(p1.x - p2.x) > 0 ||\n        Math.abs(p1.y - p2.y) > 0) {\n        return false;\n    }\n\n    // polygon simplification can produce polygons with zero area and more than 3 points\n    return Math.abs(calculateSignedArea(points)) > 0.01;\n}\n\n/**\n * Converts spherical coordinates to cartesian coordinates.\n *\n * @private\n * @param spherical Spherical coordinates, in [radial, azimuthal, polar]\n * @return cartesian coordinates in [x, y, z]\n */\n\nexport function sphericalToCartesian([r, azimuthal, polar]: [number, number, number]): {x: number, y: number, z: number} {\n    // We abstract \"north\"/\"up\" (compass-wise) to be 0 when really this is 90 (/2):\n    // correct for that here\n    azimuthal += 90;\n\n    // Convert azimuthal and polar angles to radians\n    azimuthal *= Math.PI / 180;\n    polar *= Math.PI / 180;\n\n    return {\n        x: r * Math.cos(azimuthal) * Math.sin(polar),\n        y: r * Math.sin(azimuthal) * Math.sin(polar),\n        z: r * Math.cos(polar)\n    };\n}\n\n/**\n * Parses data from 'Cache-Control' headers.\n *\n * @private\n * @param cacheControl Value of 'Cache-Control' header\n * @return object containing parsed header info.\n */\n\nexport function parseCacheControl(cacheControl: string): Object {\n    // Taken from [Wreck](https://github.com/hapijs/wreck)\n    const re = /(?:^|(?:\\s*\\,\\s*))([^\\x00-\\x20\\(\\)<>@\\,;\\:\\\\\"\\/\\[\\]\\?\\=\\{\\}\\x7F]+)(?:\\=(?:([^\\x00-\\x20\\(\\)<>@\\,;\\:\\\\\"\\/\\[\\]\\?\\=\\{\\}\\x7F]+)|(?:\\\"((?:[^\"\\\\]|\\\\.)*)\\\")))?/g;\n\n    const header = {};\n    cacheControl.replace(re, ($0, $1, $2, $3) => {\n        const value = $2 || $3;\n        header[$1] = value ? value.toLowerCase() : true;\n        return '';\n    });\n\n    if (header['max-age']) {\n        const maxAge = parseInt(header['max-age'], 10);\n        if (isNaN(maxAge)) delete header['max-age'];\n        else header['max-age'] = maxAge;\n    }\n\n    return header;\n}\n\nexport function storageAvailable(type: string): boolean {\n    try {\n        const storage = window[type];\n        storage.setItem('_mapbox_test_', 1);\n        storage.removeItem('_mapbox_test_');\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\n","// @flow\n\nimport { uniqueId, deepEqual, parseCacheControl } from '../util/util';\nimport { deserialize as deserializeBucket } from '../data/bucket';\nimport FeatureIndex from '../data/feature_index';\nimport GeoJSONFeature from '../util/vectortile_to_geojson';\nimport featureFilter from '../style-spec/feature_filter';\nimport SymbolBucket from '../data/bucket/symbol_bucket';\nimport { RasterBoundsArray, CollisionBoxArray } from '../data/array_types';\nimport rasterBoundsAttributes from '../data/raster_bounds_attributes';\nimport EXTENT from '../data/extent';\nimport Point from '@mapbox/point-geometry';\nimport Texture from '../render/texture';\nimport SegmentVector from '../data/segment';\nimport { TriangleIndexArray } from '../data/index_array_type';\nimport browser from '../util/browser';\nimport EvaluationParameters from '../style/evaluation_parameters';\nimport SourceFeatureState from '../source/source_state';\n\nconst CLOCK_SKEW_RETRY_TIMEOUT = 30000;\n\nimport type {Bucket} from '../data/bucket';\nimport type StyleLayer from '../style/style_layer';\nimport type {WorkerTileResult} from './worker_source';\nimport type DEMData from '../data/dem_data';\nimport type {AlphaImage} from '../util/image';\nimport type ImageAtlas from '../render/image_atlas';\nimport type Mask from '../render/tile_mask';\nimport type Context from '../gl/context';\nimport type IndexBuffer from '../gl/index_buffer';\nimport type VertexBuffer from '../gl/vertex_buffer';\nimport type {OverscaledTileID} from './tile_id';\nimport type Framebuffer from '../gl/framebuffer';\nimport type {PerformanceResourceTiming} from '../types/performance_resource_timing';\nimport type Transform from '../geo/transform';\nimport type {LayerFeatureStates} from './source_state';\nimport type {Cancelable} from '../types/cancelable';\nimport type {FilterSpecification} from '../style-spec/types';\n\nexport type TileState =\n    | 'loading'   // Tile data is in the process of loading.\n    | 'loaded'    // Tile data has been loaded. Tile can be rendered.\n    | 'reloading' // Tile data has been loaded and is being updated. Tile can be rendered.\n    | 'unloaded'  // Tile data has been deleted.\n    | 'errored'   // Tile data was not loaded because of an error.\n    | 'expired';  /* Tile data was previously loaded, but has expired per its\n                   * HTTP headers and is in the process of refreshing. */\n\n/**\n * A tile object is the combination of a Coordinate, which defines\n * its place, as well as a unique ID and data tracking for its content\n *\n * @private\n */\nclass Tile {\n    tileID: OverscaledTileID;\n    uid: number;\n    uses: number;\n    tileSize: number;\n    buckets: {[string]: Bucket};\n    latestFeatureIndex: ?FeatureIndex;\n    latestRawTileData: ?ArrayBuffer;\n    imageAtlas: ?ImageAtlas;\n    imageAtlasTexture: Texture;\n    glyphAtlasImage: ?AlphaImage;\n    glyphAtlasTexture: Texture;\n    expirationTime: any;\n    expiredRequestCount: number;\n    state: TileState;\n    timeAdded: any;\n    fadeEndTime: any;\n    collisionBoxArray: ?CollisionBoxArray;\n    redoWhenDone: boolean;\n    showCollisionBoxes: boolean;\n    placementSource: any;\n    workerID: number | void;\n    vtLayers: {[string]: VectorTileLayer};\n    mask: Mask;\n\n    neighboringTiles: ?Object;\n    dem: ?DEMData;\n    aborted: ?boolean;\n    maskedBoundsBuffer: ?VertexBuffer;\n    maskedIndexBuffer: ?IndexBuffer;\n    segments: ?SegmentVector;\n    needsHillshadePrepare: ?boolean;\n    request: ?Cancelable;\n    texture: any;\n    fbo: ?Framebuffer;\n    demTexture: ?Texture;\n    refreshedUponExpiration: boolean;\n    reloadCallback: any;\n    resourceTiming: ?Array<PerformanceResourceTiming>;\n    queryPadding: number;\n\n    symbolFadeHoldUntil: ?number;\n    hasSymbolBuckets: boolean;\n\n    /**\n     * @param {OverscaledTileID} tileID\n     * @param size\n     */\n    constructor(tileID: OverscaledTileID, size: number) {\n        this.tileID = tileID;\n        this.uid = uniqueId();\n        this.uses = 0;\n        this.tileSize = size;\n        this.buckets = {};\n        this.expirationTime = null;\n        this.queryPadding = 0;\n        this.hasSymbolBuckets = false;\n\n        // Counts the number of times a response was already expired when\n        // received. We're using this to add a delay when making a new request\n        // so we don't have to keep retrying immediately in case of a server\n        // serving expired tiles.\n        this.expiredRequestCount = 0;\n\n        this.state = 'loading';\n    }\n\n    registerFadeDuration(duration: number) {\n        const fadeEndTime = duration + this.timeAdded;\n        if (fadeEndTime < browser.now()) return;\n        if (this.fadeEndTime && fadeEndTime < this.fadeEndTime) return;\n\n        this.fadeEndTime = fadeEndTime;\n    }\n\n    wasRequested() {\n        return this.state === 'errored' || this.state === 'loaded' || this.state === 'reloading';\n    }\n\n    /**\n     * Given a data object with a 'buffers' property, load it into\n     * this tile's elementGroups and buffers properties and set loaded\n     * to true. If the data is null, like in the case of an empty\n     * GeoJSON tile, no-op but still set loaded to true.\n     * @param {Object} data\n     * @param painter\n     * @returns {undefined}\n     * @private\n     */\n    loadVectorData(data: WorkerTileResult, painter: any, justReloaded: ?boolean) {\n        if (this.hasData()) {\n            this.unloadVectorData();\n        }\n\n        this.state = 'loaded';\n\n        // empty GeoJSON tile\n        if (!data) {\n            this.collisionBoxArray = new CollisionBoxArray();\n            return;\n        }\n\n        if (data.featureIndex) {\n            this.latestFeatureIndex = data.featureIndex;\n            if (data.rawTileData) {\n                // Only vector tiles have rawTileData, and they won't update it for\n                // 'reloadTile'\n                this.latestRawTileData = data.rawTileData;\n                this.latestFeatureIndex.rawTileData = data.rawTileData;\n            } else if (this.latestRawTileData) {\n                // If rawTileData hasn't updated, hold onto a pointer to the last\n                // one we received\n                this.latestFeatureIndex.rawTileData = this.latestRawTileData;\n            }\n        }\n        this.collisionBoxArray = data.collisionBoxArray;\n        this.buckets = deserializeBucket(data.buckets, painter.style);\n\n        this.hasSymbolBuckets = false;\n        for (const id in this.buckets) {\n            const bucket = this.buckets[id];\n            if (bucket instanceof SymbolBucket) {\n                this.hasSymbolBuckets = true;\n                if (justReloaded) {\n                    bucket.justReloaded = true;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        this.queryPadding = 0;\n        for (const id in this.buckets) {\n            const bucket = this.buckets[id];\n            this.queryPadding = Math.max(this.queryPadding, painter.style.getLayer(id).queryRadius(bucket));\n        }\n\n        if (data.imageAtlas) {\n            this.imageAtlas = data.imageAtlas;\n        }\n        if (data.glyphAtlasImage) {\n            this.glyphAtlasImage = data.glyphAtlasImage;\n        }\n    }\n\n    /**\n     * Release any data or WebGL resources referenced by this tile.\n     * @returns {undefined}\n     * @private\n     */\n    unloadVectorData() {\n        for (const id in this.buckets) {\n            this.buckets[id].destroy();\n        }\n        this.buckets = {};\n\n        if (this.imageAtlasTexture) {\n            this.imageAtlasTexture.destroy();\n        }\n\n        if (this.imageAtlas) {\n            this.imageAtlas = null;\n        }\n\n        if (this.glyphAtlasTexture) {\n            this.glyphAtlasTexture.destroy();\n        }\n\n        this.latestFeatureIndex = null;\n        this.state = 'unloaded';\n    }\n\n    unloadDEMData() {\n        this.dem = null;\n        this.neighboringTiles = null;\n        this.state = 'unloaded';\n    }\n\n    getBucket(layer: StyleLayer) {\n        return this.buckets[layer.id];\n    }\n\n    upload(context: Context) {\n        for (const id in this.buckets) {\n            const bucket = this.buckets[id];\n            if (bucket.uploadPending()) {\n                bucket.upload(context);\n            }\n        }\n\n        const gl = context.gl;\n        if (this.imageAtlas && !this.imageAtlas.uploaded) {\n            this.imageAtlasTexture = new Texture(context, this.imageAtlas.image, gl.RGBA);\n            this.imageAtlas.uploaded = true;\n        }\n\n        if (this.glyphAtlasImage) {\n            this.glyphAtlasTexture = new Texture(context, this.glyphAtlasImage, gl.ALPHA);\n            this.glyphAtlasImage = null;\n        }\n    }\n\n    // Queries non-symbol features rendered for this tile.\n    // Symbol features are queried globally\n    queryRenderedFeatures(layers: {[string]: StyleLayer},\n                          sourceFeatureState: SourceFeatureState,\n                          queryGeometry: Array<Point>,\n                          cameraQueryGeometry: Array<Point>,\n                          scale: number,\n                          params: { filter: FilterSpecification, layers: Array<string> },\n                          transform: Transform,\n                          maxPitchScaleFactor: number,\n                          pixelPosMatrix: Float32Array): {[string]: Array<{ featureIndex: number, feature: GeoJSONFeature }>} {\n        if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData)\n            return {};\n\n        return this.latestFeatureIndex.query({\n            queryGeometry,\n            cameraQueryGeometry,\n            scale,\n            tileSize: this.tileSize,\n            pixelPosMatrix,\n            transform,\n            params,\n            queryPadding: this.queryPadding * maxPitchScaleFactor\n        }, layers, sourceFeatureState);\n    }\n\n    querySourceFeatures(result: Array<GeoJSONFeature>, params: any) {\n        if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData) return;\n\n        const vtLayers = this.latestFeatureIndex.loadVTLayers();\n\n        const sourceLayer = params ? params.sourceLayer : '';\n        const layer = vtLayers._geojsonTileLayer || vtLayers[sourceLayer];\n\n        if (!layer) return;\n\n        const filter = featureFilter(params && params.filter);\n        const {z, x, y} = this.tileID.canonical;\n        const coord = {z, x, y};\n\n        for (let i = 0; i < layer.length; i++) {\n            const feature = layer.feature(i);\n            if (filter(new EvaluationParameters(this.tileID.overscaledZ), feature)) {\n                const geojsonFeature = new GeoJSONFeature(feature, z, x, y);\n                (geojsonFeature: any).tile = coord;\n                result.push(geojsonFeature);\n            }\n        }\n    }\n\n    clearMask() {\n        if (this.segments) {\n            this.segments.destroy();\n            delete this.segments;\n        }\n        if (this.maskedBoundsBuffer) {\n            this.maskedBoundsBuffer.destroy();\n            delete this.maskedBoundsBuffer;\n        }\n        if (this.maskedIndexBuffer) {\n            this.maskedIndexBuffer.destroy();\n            delete this.maskedIndexBuffer;\n        }\n    }\n\n    setMask(mask: Mask, context: Context) {\n\n        // don't redo buffer work if the mask is the same;\n        if (deepEqual(this.mask, mask)) return;\n\n        this.mask = mask;\n        this.clearMask();\n\n        // We want to render the full tile, and keeping the segments/vertices/indices empty means\n        // using the global shared buffers for covering the entire tile.\n        if (deepEqual(mask, {'0': true})) return;\n\n        const maskedBoundsArray = new RasterBoundsArray();\n        const indexArray = new TriangleIndexArray();\n\n        this.segments = new SegmentVector();\n        // Create a new segment so that we will upload (empty) buffers even when there is nothing to\n        // draw for this tile.\n        this.segments.prepareSegment(0, maskedBoundsArray, indexArray);\n\n        const maskArray = Object.keys(mask);\n        for (let i = 0; i < maskArray.length; i++) {\n            const maskCoord = mask[maskArray[i]];\n            const vertexExtent = EXTENT >> maskCoord.z;\n            const tlVertex = new Point(maskCoord.x * vertexExtent, maskCoord.y * vertexExtent);\n            const brVertex = new Point(tlVertex.x + vertexExtent, tlVertex.y + vertexExtent);\n\n            // not sure why flow is complaining here because it doesn't complain at L401\n            const segment = (this.segments: any).prepareSegment(4, maskedBoundsArray, indexArray);\n\n            maskedBoundsArray.emplaceBack(tlVertex.x, tlVertex.y, tlVertex.x, tlVertex.y);\n            maskedBoundsArray.emplaceBack(brVertex.x, tlVertex.y, brVertex.x, tlVertex.y);\n            maskedBoundsArray.emplaceBack(tlVertex.x, brVertex.y, tlVertex.x, brVertex.y);\n            maskedBoundsArray.emplaceBack(brVertex.x, brVertex.y, brVertex.x, brVertex.y);\n\n            const offset = segment.vertexLength;\n            // 0, 1, 2\n            // 1, 2, 3\n            indexArray.emplaceBack(offset, offset + 1, offset + 2);\n            indexArray.emplaceBack(offset + 1, offset + 2, offset + 3);\n\n            segment.vertexLength += 4;\n            segment.primitiveLength += 2;\n        }\n\n        this.maskedBoundsBuffer = context.createVertexBuffer(maskedBoundsArray, rasterBoundsAttributes.members);\n        this.maskedIndexBuffer = context.createIndexBuffer(indexArray);\n    }\n\n    hasData() {\n        return this.state === 'loaded' || this.state === 'reloading' || this.state === 'expired';\n    }\n\n    patternsLoaded() {\n        return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;\n    }\n\n    setExpiryData(data: any) {\n        const prior = this.expirationTime;\n\n        if (data.cacheControl) {\n            const parsedCC = parseCacheControl(data.cacheControl);\n            if (parsedCC['max-age']) this.expirationTime = Date.now() + parsedCC['max-age'] * 1000;\n        } else if (data.expires) {\n            this.expirationTime = new Date(data.expires).getTime();\n        }\n\n        if (this.expirationTime) {\n            const now = Date.now();\n            let isExpired = false;\n\n            if (this.expirationTime > now) {\n                isExpired = false;\n            } else if (!prior) {\n                isExpired = true;\n            } else if (this.expirationTime < prior) {\n                // Expiring date is going backwards:\n                // fall back to exponential backoff\n                isExpired = true;\n\n            } else {\n                const delta = this.expirationTime - prior;\n\n                if (!delta) {\n                    // Server is serving the same expired resource over and over: fall\n                    // back to exponential backoff.\n                    isExpired = true;\n\n                } else {\n                    // Assume that either the client or the server clock is wrong and\n                    // try to interpolate a valid expiration date (from the client POV)\n                    // observing a minimum timeout.\n                    this.expirationTime = now + Math.max(delta, CLOCK_SKEW_RETRY_TIMEOUT);\n\n                }\n            }\n\n            if (isExpired) {\n                this.expiredRequestCount++;\n                this.state = 'expired';\n            } else {\n                this.expiredRequestCount = 0;\n            }\n        }\n    }\n\n    getExpiryTimeout() {\n        if (this.expirationTime) {\n            if (this.expiredRequestCount) {\n                return 1000 * (1 << Math.min(this.expiredRequestCount - 1, 31));\n            } else {\n                // Max value for `setTimeout` implementations is a 32 bit integer; cap this accordingly\n                return Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1);\n            }\n        }\n    }\n\n    setFeatureState(states: LayerFeatureStates, painter: any) {\n        if (!this.latestFeatureIndex ||\n            !this.latestFeatureIndex.rawTileData ||\n            Object.keys(states).length === 0) {\n            return;\n        }\n\n        const vtLayers = this.latestFeatureIndex.loadVTLayers();\n\n        for (const id in this.buckets) {\n            const bucket = this.buckets[id];\n            // Buckets are grouped by common source-layer\n            const sourceLayerId = bucket.layers[0]['sourceLayer'] || '_geojsonTileLayer';\n            const sourceLayer = vtLayers[sourceLayerId];\n            const sourceLayerStates = states[sourceLayerId];\n            if (!sourceLayer || !sourceLayerStates || Object.keys(sourceLayerStates).length === 0) continue;\n\n            bucket.update(sourceLayerStates, sourceLayer, this.imageAtlas && this.imageAtlas.patternPositions || {});\n            if (painter && painter.style) {\n                this.queryPadding = Math.max(this.queryPadding, painter.style.getLayer(id).queryRadius(bucket));\n            }\n        }\n    }\n\n    holdingForFade(): boolean {\n        return this.symbolFadeHoldUntil !== undefined;\n    }\n\n    symbolFadeFinished(): boolean {\n        return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < browser.now();\n    }\n\n    clearFadeHold() {\n        this.symbolFadeHoldUntil = undefined;\n    }\n\n    setHoldDuration(duration: number) {\n        this.symbolFadeHoldUntil = browser.now() + duration;\n    }\n}\n\nexport default Tile;\n","// @flow\n\nimport type {CollisionBoxArray} from './array_types';\nimport type Style from '../style/style';\nimport type {TypedStyleLayer} from '../style/style_layer/typed_style_layer';\nimport type FeatureIndex from './feature_index';\nimport type Context from '../gl/context';\nimport type {FeatureStates} from '../source/source_state';\nimport type {ImagePosition} from '../render/image_atlas';\n\nexport type BucketParameters<Layer: TypedStyleLayer> = {\n    index: number,\n    layers: Array<Layer>,\n    zoom: number,\n    pixelRatio: number,\n    overscaling: number,\n    collisionBoxArray: CollisionBoxArray,\n    sourceLayerIndex: number,\n    sourceID: string\n}\n\nexport type PopulateParameters = {\n    featureIndex: FeatureIndex,\n    iconDependencies: {},\n    patternDependencies: {},\n    glyphDependencies: {}\n}\n\nexport type IndexedFeature = {\n    feature: VectorTileFeature,\n    index: number,\n    sourceLayerIndex: number,\n}\n\nexport type BucketFeature = {|\n    index: number,\n    sourceLayerIndex: number,\n    geometry: Array<Array<Point>>,\n    properties: Object,\n    type: 1 | 2 | 3,\n    id?: any,\n    +patterns: {[string]: {\"min\": string, \"mid\": string, \"max\": string}}\n|};\n\n/**\n * The `Bucket` interface is the single point of knowledge about turning vector\n * tiles into WebGL buffers.\n *\n * `Bucket` is an abstract interface. An implementation exists for each style layer type.\n * Create a bucket via the `StyleLayer#createBucket` method.\n *\n * The concrete bucket types, using layout options from the style layer,\n * transform feature geometries into vertex and index data for use by the\n * vertex shader.  They also (via `ProgramConfiguration`) use feature\n * properties and the zoom level to populate the attributes needed for\n * data-driven styling.\n *\n * Buckets are designed to be built on a worker thread and then serialized and\n * transferred back to the main thread for rendering.  On the worker side, a\n * bucket's vertex, index, and attribute data is stored in `bucket.arrays:\n * ArrayGroup`.  When a bucket's data is serialized and sent back to the main\n * thread, is gets deserialized (using `new Bucket(serializedBucketData)`, with\n * the array data now stored in `bucket.buffers: BufferGroup`.  BufferGroups\n * hold the same data as ArrayGroups, but are tuned for consumption by WebGL.\n *\n * @private\n */\nexport interface Bucket {\n    layerIds: Array<string>;\n    hasPattern: boolean;\n    +layers: Array<any>;\n    +stateDependentLayers: Array<any>;\n\n    populate(features: Array<IndexedFeature>, options: PopulateParameters): void;\n    update(states: FeatureStates, vtLayer: VectorTileLayer, imagePositions: {[string]: ImagePosition}): void;\n    isEmpty(): boolean;\n\n    upload(context: Context): void;\n    uploadPending(): boolean;\n\n    /**\n     * Release the WebGL resources associated with the buffers. Note that because\n     * buckets are shared between layers having the same layout properties, they\n     * must be destroyed in groups (all buckets for a tile, or all symbol buckets).\n     *\n     * @private\n     */\n    destroy(): void;\n}\n\nexport function deserialize(input: Array<Bucket>, style: Style): {[string]: Bucket} {\n    const output = {};\n\n    // Guard against the case where the map's style has been set to null while\n    // this bucket has been parsing.\n    if (!style) return output;\n\n    for (const bucket of input) {\n        const layers = bucket.layerIds\n            .map((id) => style.getLayer(id))\n            .filter(Boolean);\n\n        if (layers.length === 0) {\n            continue;\n        }\n\n        // look up StyleLayer objects from layer ids (since we don't\n        // want to waste time serializing/copying them from the worker)\n        (bucket: any).layers = layers;\n        (bucket: any).stateDependentLayers = layers.filter((l) => l.isStateDependent());\n        for (const layer of layers) {\n            output[layer.id] = bucket;\n        }\n    }\n\n    return output;\n}\n","\nexport default ['type', 'source', 'source-layer', 'minzoom', 'maxzoom', 'filter', 'layout'];\n","// @flow\n\nimport {\n    charHasUprightVerticalOrientation,\n    charAllowsIdeographicBreaking\n} from '../util/script_detection';\nimport verticalizePunctuation from '../util/verticalize_punctuation';\nimport { plugin as rtlTextPlugin } from '../source/rtl_text_plugin';\n\nimport type {StyleGlyph} from '../style/style_glyph';\nimport type {ImagePosition} from '../render/image_atlas';\nimport Formatted from '../style-spec/expression/types/formatted';\n\nconst WritingMode = {\n    horizontal: 1,\n    vertical: 2,\n    horizontalOnly: 3\n};\n\nexport { shapeText, shapeIcon, WritingMode };\n\n// The position of a glyph relative to the text's anchor point.\nexport type PositionedGlyph = {\n    glyph: number,\n    x: number,\n    y: number,\n    vertical: boolean,\n    scale: number,\n    fontStack: string\n};\n\n// A collection of positioned glyphs and some metadata\nexport type Shaping = {\n    positionedGlyphs: Array<PositionedGlyph>,\n    top: number,\n    bottom: number,\n    left: number,\n    right: number,\n    writingMode: 1 | 2\n};\n\ntype SymbolAnchor = 'center' | 'left' | 'right' | 'top' | 'bottom' | 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';\ntype TextJustify = 'left' | 'center' | 'right';\n\nclass TaggedString {\n    text: string;\n    sectionIndex: Array<number> // maps each character in 'text' to its corresponding entry in 'sections'\n    sections: Array<{ scale: number, fontStack: string }>\n\n    constructor() {\n        this.text = \"\";\n        this.sectionIndex = [];\n        this.sections = [];\n    }\n\n    static fromFeature(text: Formatted, defaultFontStack: string) {\n        const result = new TaggedString();\n        for (let i = 0; i < text.sections.length; i++) {\n            const section = text.sections[i];\n            result.sections.push({\n                scale: section.scale || 1,\n                fontStack: section.fontStack || defaultFontStack\n            });\n            result.text += section.text;\n            for (let j = 0; j < section.text.length; j++) {\n                result.sectionIndex.push(i);\n            }\n        }\n        return result;\n    }\n\n    length(): number {\n        return this.text.length;\n    }\n\n    getSection(index: number): { scale: number, fontStack: string } {\n        return this.sections[this.sectionIndex[index]];\n    }\n\n    getCharCode(index: number): number {\n        return this.text.charCodeAt(index);\n    }\n\n    verticalizePunctuation() {\n        this.text = verticalizePunctuation(this.text);\n    }\n\n    trim() {\n        let beginningWhitespace = 0;\n        for (let i = 0;\n            i < this.text.length && whitespace[this.text.charCodeAt(i)];\n            i++) {\n            beginningWhitespace++;\n        }\n        let trailingWhitespace = this.text.length;\n        for (let i = this.text.length - 1;\n            i >= 0 && i >= beginningWhitespace && whitespace[this.text.charCodeAt(i)];\n            i--) {\n            trailingWhitespace--;\n        }\n        this.text = this.text.substring(beginningWhitespace, trailingWhitespace);\n        this.sectionIndex = this.sectionIndex.slice(beginningWhitespace, trailingWhitespace);\n    }\n\n    substring(start: number, end: number): TaggedString {\n        const substring = new TaggedString();\n        substring.text = this.text.substring(start, end);\n        substring.sectionIndex = this.sectionIndex.slice(start, end);\n        substring.sections = this.sections;\n        return substring;\n    }\n\n    toString(): string {\n        return this.text;\n    }\n\n    getMaxScale() {\n        return this.sectionIndex.reduce((max, index) => Math.max(max, this.sections[index].scale), 0);\n    }\n}\n\nfunction breakLines(input: TaggedString, lineBreakPoints: Array<number>): Array<TaggedString> {\n    const lines = [];\n    const text = input.text;\n    let start = 0;\n    for (const lineBreak of lineBreakPoints) {\n        lines.push(input.substring(start, lineBreak));\n        start = lineBreak;\n    }\n\n    if (start < text.length) {\n        lines.push(input.substring(start, text.length));\n    }\n    return lines;\n}\n\nfunction shapeText(text: Formatted,\n                   glyphs: {[string]: {[number]: ?StyleGlyph}},\n                   defaultFontStack: string,\n                   maxWidth: number,\n                   lineHeight: number,\n                   textAnchor: SymbolAnchor,\n                   textJustify: TextJustify,\n                   spacing: number,\n                   translate: [number, number],\n                   verticalHeight: number,\n                   writingMode: 1 | 2): Shaping | false {\n    const logicalInput = TaggedString.fromFeature(text, defaultFontStack);\n\n    if (writingMode === WritingMode.vertical) {\n        logicalInput.verticalizePunctuation();\n    }\n\n    const positionedGlyphs = [];\n    const shaping = {\n        positionedGlyphs,\n        text: logicalInput,\n        top: translate[1],\n        bottom: translate[1],\n        left: translate[0],\n        right: translate[0],\n        writingMode\n    };\n\n    let lines: Array<TaggedString>;\n\n    const {processBidirectionalText, processStyledBidirectionalText} = rtlTextPlugin;\n    if (processBidirectionalText && logicalInput.sections.length === 1) {\n        // Bidi doesn't have to be style-aware\n        lines = [];\n        const untaggedLines =\n            processBidirectionalText(logicalInput.toString(),\n                                     determineLineBreaks(logicalInput, spacing, maxWidth, glyphs));\n        for (const line of untaggedLines) {\n            const taggedLine = new TaggedString();\n            taggedLine.text = line;\n            taggedLine.sections = logicalInput.sections;\n            for (let i = 0; i < line.length; i++) {\n                taggedLine.sectionIndex.push(0);\n            }\n            lines.push(taggedLine);\n        }\n    } else if (processStyledBidirectionalText) {\n        // Need version of mapbox-gl-rtl-text with style support for combining RTL text\n        // with formatting\n        lines = [];\n        const processedLines =\n            processStyledBidirectionalText(logicalInput.text,\n                                           logicalInput.sectionIndex,\n                                           determineLineBreaks(logicalInput, spacing, maxWidth, glyphs));\n        for (const line of processedLines) {\n            const taggedLine = new TaggedString();\n            taggedLine.text = line[0];\n            taggedLine.sectionIndex = line[1];\n            taggedLine.sections = logicalInput.sections;\n            lines.push(taggedLine);\n        }\n    } else {\n        lines = breakLines(logicalInput, determineLineBreaks(logicalInput, spacing, maxWidth, glyphs));\n    }\n\n    shapeLines(shaping, glyphs, lines, lineHeight, textAnchor, textJustify, writingMode, spacing, verticalHeight);\n\n    if (!positionedGlyphs.length)\n        return false;\n\n    shaping.text = shaping.text.toString();\n    return shaping;\n}\n\n// using computed properties due to https://github.com/facebook/flow/issues/380\n/* eslint no-useless-computed-key: 0 */\n\nconst whitespace: {[number]: boolean} = {\n    [0x09]: true, // tab\n    [0x0a]: true, // newline\n    [0x0b]: true, // vertical tab\n    [0x0c]: true, // form feed\n    [0x0d]: true, // carriage return\n    [0x20]: true, // space\n};\n\nconst breakable: {[number]: boolean} = {\n    [0x0a]:   true, // newline\n    [0x20]:   true, // space\n    [0x26]:   true, // ampersand\n    [0x28]:   true, // left parenthesis\n    [0x29]:   true, // right parenthesis\n    [0x2b]:   true, // plus sign\n    [0x2d]:   true, // hyphen-minus\n    [0x2f]:   true, // solidus\n    [0xad]:   true, // soft hyphen\n    [0xb7]:   true, // middle dot\n    [0x200b]: true, // zero-width space\n    [0x2010]: true, // hyphen\n    [0x2013]: true, // en dash\n    [0x2027]: true  // interpunct\n    // Many other characters may be reasonable breakpoints\n    // Consider \"neutral orientation\" characters at scriptDetection.charHasNeutralVerticalOrientation\n    // See https://github.com/mapbox/mapbox-gl-js/issues/3658\n};\n\nfunction determineAverageLineWidth(logicalInput: TaggedString,\n                                   spacing: number,\n                                   maxWidth: number,\n                                   glyphMap: {[string]: {[number]: ?StyleGlyph}}) {\n    let totalWidth = 0;\n\n    for (let index = 0; index < logicalInput.length(); index++) {\n        const section = logicalInput.getSection(index);\n        const positions = glyphMap[section.fontStack];\n        const glyph = positions && positions[logicalInput.getCharCode(index)];\n        if (!glyph)\n            continue;\n        totalWidth += glyph.metrics.advance * section.scale + spacing;\n    }\n\n    const lineCount = Math.max(1, Math.ceil(totalWidth / maxWidth));\n    return totalWidth / lineCount;\n}\n\nfunction calculateBadness(lineWidth: number,\n                          targetWidth: number,\n                          penalty: number,\n                          isLastBreak: boolean) {\n    const raggedness = Math.pow(lineWidth - targetWidth, 2);\n    if (isLastBreak) {\n        // Favor finals lines shorter than average over longer than average\n        if (lineWidth < targetWidth) {\n            return raggedness / 2;\n        } else {\n            return raggedness * 2;\n        }\n    }\n\n    return raggedness + Math.abs(penalty) * penalty;\n}\n\nfunction calculatePenalty(codePoint: number, nextCodePoint: number) {\n    let penalty = 0;\n    // Force break on newline\n    if (codePoint === 0x0a) {\n        penalty -= 10000;\n    }\n    // Penalize open parenthesis at end of line\n    if (codePoint === 0x28 || codePoint === 0xff08) {\n        penalty += 50;\n    }\n\n    // Penalize close parenthesis at beginning of line\n    if (nextCodePoint === 0x29 || nextCodePoint === 0xff09) {\n        penalty += 50;\n    }\n    return penalty;\n}\n\ntype Break = {\n    index: number,\n    x: number,\n    priorBreak: ?Break,\n    badness: number\n};\n\nfunction evaluateBreak(breakIndex: number,\n                       breakX: number,\n                       targetWidth: number,\n                       potentialBreaks: Array<Break>,\n                       penalty: number,\n                       isLastBreak: boolean): Break {\n    // We could skip evaluating breaks where the line length (breakX - priorBreak.x) > maxWidth\n    //  ...but in fact we allow lines longer than maxWidth (if there's no break points)\n    //  ...and when targetWidth and maxWidth are close, strictly enforcing maxWidth can give\n    //     more lopsided results.\n\n    let bestPriorBreak: ?Break = null;\n    let bestBreakBadness = calculateBadness(breakX, targetWidth, penalty, isLastBreak);\n\n    for (const potentialBreak of potentialBreaks) {\n        const lineWidth = breakX - potentialBreak.x;\n        const breakBadness =\n            calculateBadness(lineWidth, targetWidth, penalty, isLastBreak) + potentialBreak.badness;\n        if (breakBadness <= bestBreakBadness) {\n            bestPriorBreak = potentialBreak;\n            bestBreakBadness = breakBadness;\n        }\n    }\n\n    return {\n        index: breakIndex,\n        x: breakX,\n        priorBreak: bestPriorBreak,\n        badness: bestBreakBadness\n    };\n}\n\nfunction leastBadBreaks(lastLineBreak: ?Break): Array<number> {\n    if (!lastLineBreak) {\n        return [];\n    }\n    return leastBadBreaks(lastLineBreak.priorBreak).concat(lastLineBreak.index);\n}\n\nfunction determineLineBreaks(logicalInput: TaggedString,\n                             spacing: number,\n                             maxWidth: number,\n                             glyphMap: {[string]: {[number]: ?StyleGlyph}}): Array<number> {\n    if (!maxWidth)\n        return [];\n\n    if (!logicalInput)\n        return [];\n\n    const potentialLineBreaks = [];\n    const targetWidth = determineAverageLineWidth(logicalInput, spacing, maxWidth, glyphMap);\n\n    let currentX = 0;\n\n    for (let i = 0; i < logicalInput.length(); i++) {\n        const section = logicalInput.getSection(i);\n        const codePoint = logicalInput.getCharCode(i);\n        const positions = glyphMap[section.fontStack];\n        const glyph = positions && positions[codePoint];\n\n        if (glyph && !whitespace[codePoint])\n            currentX += glyph.metrics.advance * section.scale + spacing;\n\n        // Ideographic characters, spaces, and word-breaking punctuation that often appear without\n        // surrounding spaces.\n        if ((i < logicalInput.length() - 1) &&\n            (breakable[codePoint] ||\n                charAllowsIdeographicBreaking(codePoint))) {\n\n            potentialLineBreaks.push(\n                evaluateBreak(\n                    i + 1,\n                    currentX,\n                    targetWidth,\n                    potentialLineBreaks,\n                    calculatePenalty(codePoint, logicalInput.getCharCode(i + 1)),\n                    false));\n        }\n    }\n\n    return leastBadBreaks(\n        evaluateBreak(\n            logicalInput.length(),\n            currentX,\n            targetWidth,\n            potentialLineBreaks,\n            0,\n            true));\n}\n\nfunction getAnchorAlignment(anchor: SymbolAnchor) {\n    let horizontalAlign = 0.5, verticalAlign = 0.5;\n\n    switch (anchor) {\n    case 'right':\n    case 'top-right':\n    case 'bottom-right':\n        horizontalAlign = 1;\n        break;\n    case 'left':\n    case 'top-left':\n    case 'bottom-left':\n        horizontalAlign = 0;\n        break;\n    }\n\n    switch (anchor) {\n    case 'bottom':\n    case 'bottom-right':\n    case 'bottom-left':\n        verticalAlign = 1;\n        break;\n    case 'top':\n    case 'top-right':\n    case 'top-left':\n        verticalAlign = 0;\n        break;\n    }\n\n    return { horizontalAlign, verticalAlign };\n}\n\nfunction shapeLines(shaping: Shaping,\n                    glyphMap: {[string]: {[number]: ?StyleGlyph}},\n                    lines: Array<TaggedString>,\n                    lineHeight: number,\n                    textAnchor: SymbolAnchor,\n                    textJustify: TextJustify,\n                    writingMode: 1 | 2,\n                    spacing: number,\n                    verticalHeight: number) {\n    // the y offset *should* be part of the font metadata\n    const yOffset = -17;\n\n    let x = 0;\n    let y = yOffset;\n\n    let maxLineLength = 0;\n    const positionedGlyphs = shaping.positionedGlyphs;\n\n    const justify =\n        textJustify === 'right' ? 1 :\n        textJustify === 'left' ? 0 : 0.5;\n\n    for (const line of lines) {\n        line.trim();\n\n        const lineMaxScale = line.getMaxScale();\n\n        if (!line.length()) {\n            y += lineHeight; // Still need a line feed after empty line\n            continue;\n        }\n\n        const lineStartIndex = positionedGlyphs.length;\n        for (let i = 0; i < line.length(); i++) {\n            const section = line.getSection(i);\n            const codePoint = line.getCharCode(i);\n            // We don't know the baseline, but since we're laying out\n            // at 24 points, we can calculate how much it will move when\n            // we scale up or down.\n            const baselineOffset = (lineMaxScale - section.scale) * 24;\n            const positions = glyphMap[section.fontStack];\n            const glyph = positions && positions[codePoint];\n\n            if (!glyph) continue;\n\n            if (!charHasUprightVerticalOrientation(codePoint) || writingMode === WritingMode.horizontal) {\n                positionedGlyphs.push({glyph: codePoint, x, y: y + baselineOffset, vertical: false, scale: section.scale, fontStack: section.fontStack});\n                x += glyph.metrics.advance * section.scale + spacing;\n            } else {\n                positionedGlyphs.push({glyph: codePoint, x, y: baselineOffset, vertical: true, scale: section.scale, fontStack: section.fontStack});\n                x += verticalHeight * section.scale + spacing;\n            }\n        }\n\n        // Only justify if we placed at least one glyph\n        if (positionedGlyphs.length !== lineStartIndex) {\n            const lineLength = x - spacing;\n            maxLineLength = Math.max(lineLength, maxLineLength);\n\n            justifyLine(positionedGlyphs, glyphMap, lineStartIndex, positionedGlyphs.length - 1, justify);\n        }\n\n        x = 0;\n        y += lineHeight * lineMaxScale;\n    }\n\n    const {horizontalAlign, verticalAlign} = getAnchorAlignment(textAnchor);\n    align(positionedGlyphs, justify, horizontalAlign, verticalAlign, maxLineLength, lineHeight, lines.length);\n\n    // Calculate the bounding box\n    const height = y - yOffset;\n\n    shaping.top += -verticalAlign * height;\n    shaping.bottom = shaping.top + height;\n    shaping.left += -horizontalAlign * maxLineLength;\n    shaping.right = shaping.left + maxLineLength;\n}\n\n// justify right = 1, left = 0, center = 0.5\nfunction justifyLine(positionedGlyphs: Array<PositionedGlyph>,\n                     glyphMap: {[string]: {[number]: ?StyleGlyph}},\n                     start: number,\n                     end: number,\n                     justify: 1 | 0 | 0.5) {\n    if (!justify)\n        return;\n\n    const lastPositionedGlyph = positionedGlyphs[end];\n    const positions = glyphMap[lastPositionedGlyph.fontStack];\n    const glyph = positions && positions[lastPositionedGlyph.glyph];\n    if (glyph) {\n        const lastAdvance = glyph.metrics.advance * lastPositionedGlyph.scale;\n        const lineIndent = (positionedGlyphs[end].x + lastAdvance) * justify;\n\n        for (let j = start; j <= end; j++) {\n            positionedGlyphs[j].x -= lineIndent;\n        }\n    }\n}\n\nfunction align(positionedGlyphs: Array<PositionedGlyph>,\n               justify: number,\n               horizontalAlign: number,\n               verticalAlign: number,\n               maxLineLength: number,\n               lineHeight: number,\n               lineCount: number) {\n    const shiftX = (justify - horizontalAlign) * maxLineLength;\n    const shiftY = (-verticalAlign * lineCount + 0.5) * lineHeight;\n\n    for (let j = 0; j < positionedGlyphs.length; j++) {\n        positionedGlyphs[j].x += shiftX;\n        positionedGlyphs[j].y += shiftY;\n    }\n}\n\nexport type PositionedIcon = {\n    image: ImagePosition,\n    top: number,\n    bottom: number,\n    left: number,\n    right: number\n};\n\nfunction shapeIcon(image: ImagePosition, iconOffset: [number, number], iconAnchor: SymbolAnchor): PositionedIcon {\n    const {horizontalAlign, verticalAlign} = getAnchorAlignment(iconAnchor);\n    const dx = iconOffset[0];\n    const dy = iconOffset[1];\n    const x1 = dx - image.displaySize[0] * horizontalAlign;\n    const x2 = x1 + image.displaySize[0];\n    const y1 = dy - image.displaySize[1] * verticalAlign;\n    const y2 = y1 + image.displaySize[1];\n    return {image, top: y1, bottom: y2, left: x1, right: x2};\n}\n","// @flow\n\nimport {\n    charHasRotatedVerticalOrientation,\n} from './script_detection';\n\nexport const verticalizedCharacterMap = {\n    '!': '',\n    '#': '',\n    '$': '',\n    '%': '',\n    '&': '',\n    '(': '',\n    ')': '',\n    '*': '',\n    '+': '',\n    ',': '',\n    '-': '',\n    '.': '',\n    '/': '',\n    ':': '',\n    ';': '',\n    '<': '',\n    '=': '',\n    '>': '',\n    '?': '',\n    '@': '',\n    '[': '',\n    '\\\\': '',\n    ']': '',\n    '^': '',\n    '_': '',\n    '`': '',\n    '{': '',\n    '|': '',\n    '}': '',\n    '~': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': ''\n};\n\nexport default function verticalizePunctuation(input: string) {\n    let output = '';\n\n    for (let i = 0; i < input.length; i++) {\n        const nextCharCode = input.charCodeAt(i + 1) || null;\n        const prevCharCode = input.charCodeAt(i - 1) || null;\n\n        const canReplacePunctuation = (\n            (!nextCharCode || !charHasRotatedVerticalOrientation(nextCharCode) || verticalizedCharacterMap[input[i + 1]]) &&\n            (!prevCharCode || !charHasRotatedVerticalOrientation(prevCharCode) || verticalizedCharacterMap[input[i - 1]])\n        );\n\n        if (canReplacePunctuation && verticalizedCharacterMap[input[i]]) {\n            output += verticalizedCharacterMap[input[i]];\n        } else {\n            output += input[i];\n        }\n    }\n\n    return output;\n}\n\n","// @flow\n\n/* eslint-disable new-cap */\n\nimport isChar from './is_char_in_unicode_block';\n\nexport function allowsIdeographicBreaking(chars: string) {\n    for (const char of chars) {\n        if (!charAllowsIdeographicBreaking(char.charCodeAt(0))) return false;\n    }\n    return true;\n}\n\nexport function allowsVerticalWritingMode(chars: string) {\n    for (const char of chars) {\n        if (charHasUprightVerticalOrientation(char.charCodeAt(0))) return true;\n    }\n    return false;\n}\n\nexport function allowsLetterSpacing(chars: string) {\n    for (const char of chars) {\n        if (!charAllowsLetterSpacing(char.charCodeAt(0))) return false;\n    }\n    return true;\n}\n\nexport function charAllowsLetterSpacing(char: number) {\n    if (isChar['Arabic'](char)) return false;\n    if (isChar['Arabic Supplement'](char)) return false;\n    if (isChar['Arabic Extended-A'](char)) return false;\n    if (isChar['Arabic Presentation Forms-A'](char)) return false;\n    if (isChar['Arabic Presentation Forms-B'](char)) return false;\n\n    return true;\n}\n\nexport function charAllowsIdeographicBreaking(char: number) {\n    // Return early for characters outside all ideographic ranges.\n    if (char < 0x2E80) return false;\n\n    if (isChar['Bopomofo Extended'](char)) return true;\n    if (isChar['Bopomofo'](char)) return true;\n    if (isChar['CJK Compatibility Forms'](char)) return true;\n    if (isChar['CJK Compatibility Ideographs'](char)) return true;\n    if (isChar['CJK Compatibility'](char)) return true;\n    if (isChar['CJK Radicals Supplement'](char)) return true;\n    if (isChar['CJK Strokes'](char)) return true;\n    if (isChar['CJK Symbols and Punctuation'](char)) return true;\n    if (isChar['CJK Unified Ideographs Extension A'](char)) return true;\n    if (isChar['CJK Unified Ideographs'](char)) return true;\n    if (isChar['Enclosed CJK Letters and Months'](char)) return true;\n    if (isChar['Halfwidth and Fullwidth Forms'](char)) return true;\n    if (isChar['Hiragana'](char)) return true;\n    if (isChar['Ideographic Description Characters'](char)) return true;\n    if (isChar['Kangxi Radicals'](char)) return true;\n    if (isChar['Katakana Phonetic Extensions'](char)) return true;\n    if (isChar['Katakana'](char)) return true;\n    if (isChar['Vertical Forms'](char)) return true;\n    if (isChar['Yi Radicals'](char)) return true;\n    if (isChar['Yi Syllables'](char)) return true;\n\n    return false;\n}\n\n// The following logic comes from\n// <http://www.unicode.org/Public/vertical/revision-17/VerticalOrientation-17.txt>.\n// The data file denotes with U or Tu any codepoint that may be drawn\n// upright in vertical text but does not distinguish between upright and\n// neutral characters.\n\n// Blocks in the Unicode supplementary planes are excluded from this module due\n// to <https://github.com/mapbox/mapbox-gl/issues/29>.\n\n/**\n * Returns true if the given Unicode codepoint identifies a character with\n * upright orientation.\n *\n * A character has upright orientation if it is drawn upright (unrotated)\n * whether the line is oriented horizontally or vertically, even if both\n * adjacent characters can be rotated. For example, a Chinese character is\n * always drawn upright. An uprightly oriented character causes an adjacent\n * neutral character to be drawn upright as well.\n * @private\n */\nexport function charHasUprightVerticalOrientation(char: number) {\n    if (char === 0x02EA /* modifier letter yin departing tone mark */ ||\n        char === 0x02EB /* modifier letter yang departing tone mark */) {\n        return true;\n    }\n\n    // Return early for characters outside all ranges whose characters remain\n    // upright in vertical writing mode.\n    if (char < 0x1100) return false;\n\n    if (isChar['Bopomofo Extended'](char)) return true;\n    if (isChar['Bopomofo'](char)) return true;\n    if (isChar['CJK Compatibility Forms'](char)) {\n        if (!((char >= 0xFE49 /* dashed overline */ && char <= 0xFE4F) /* wavy low line */)) {\n            return true;\n        }\n    }\n    if (isChar['CJK Compatibility Ideographs'](char)) return true;\n    if (isChar['CJK Compatibility'](char)) return true;\n    if (isChar['CJK Radicals Supplement'](char)) return true;\n    if (isChar['CJK Strokes'](char)) return true;\n    if (isChar['CJK Symbols and Punctuation'](char)) {\n        if (!((char >= 0x3008 /* left angle bracket */ && char <= 0x3011) /* right black lenticular bracket */) &&\n            !((char >= 0x3014 /* left tortoise shell bracket */ && char <= 0x301F) /* low double prime quotation mark */) &&\n            char !== 0x3030 /* wavy dash */) {\n            return true;\n        }\n    }\n    if (isChar['CJK Unified Ideographs Extension A'](char)) return true;\n    if (isChar['CJK Unified Ideographs'](char)) return true;\n    if (isChar['Enclosed CJK Letters and Months'](char)) return true;\n    if (isChar['Hangul Compatibility Jamo'](char)) return true;\n    if (isChar['Hangul Jamo Extended-A'](char)) return true;\n    if (isChar['Hangul Jamo Extended-B'](char)) return true;\n    if (isChar['Hangul Jamo'](char)) return true;\n    if (isChar['Hangul Syllables'](char)) return true;\n    if (isChar['Hiragana'](char)) return true;\n    if (isChar['Ideographic Description Characters'](char)) return true;\n    if (isChar['Kanbun'](char)) return true;\n    if (isChar['Kangxi Radicals'](char)) return true;\n    if (isChar['Katakana Phonetic Extensions'](char)) return true;\n    if (isChar['Katakana'](char)) {\n        if (char !== 0x30FC /* katakana-hiragana prolonged sound mark */) {\n            return true;\n        }\n    }\n    if (isChar['Halfwidth and Fullwidth Forms'](char)) {\n        if (char !== 0xFF08 /* fullwidth left parenthesis */ &&\n            char !== 0xFF09 /* fullwidth right parenthesis */ &&\n            char !== 0xFF0D /* fullwidth hyphen-minus */ &&\n            !((char >= 0xFF1A /* fullwidth colon */ && char <= 0xFF1E) /* fullwidth greater-than sign */) &&\n            char !== 0xFF3B /* fullwidth left square bracket */ &&\n            char !== 0xFF3D /* fullwidth right square bracket */ &&\n            char !== 0xFF3F /* fullwidth low line */ &&\n            !(char >= 0xFF5B /* fullwidth left curly bracket */ && char <= 0xFFDF) &&\n            char !== 0xFFE3 /* fullwidth macron */ &&\n            !(char >= 0xFFE8 /* halfwidth forms light vertical */ && char <= 0xFFEF)) {\n            return true;\n        }\n    }\n    if (isChar['Small Form Variants'](char)) {\n        if (!((char >= 0xFE58 /* small em dash */ && char <= 0xFE5E) /* small right tortoise shell bracket */) &&\n            !((char >= 0xFE63 /* small hyphen-minus */ && char <= 0xFE66) /* small equals sign */)) {\n            return true;\n        }\n    }\n    if (isChar['Unified Canadian Aboriginal Syllabics'](char)) return true;\n    if (isChar['Unified Canadian Aboriginal Syllabics Extended'](char)) return true;\n    if (isChar['Vertical Forms'](char)) return true;\n    if (isChar['Yijing Hexagram Symbols'](char)) return true;\n    if (isChar['Yi Syllables'](char)) return true;\n    if (isChar['Yi Radicals'](char)) return true;\n\n    return false;\n}\n\n/**\n * Returns true if the given Unicode codepoint identifies a character with\n * neutral orientation.\n *\n * A character has neutral orientation if it may be drawn rotated or unrotated\n * when the line is oriented vertically, depending on the orientation of the\n * adjacent characters. For example, along a verticlly oriented line, the vulgar\n * fraction  is drawn upright among Chinese characters but rotated among Latin\n * letters. A neutrally oriented character does not influence whether an\n * adjacent character is drawn upright or rotated.\n * @private\n */\nexport function charHasNeutralVerticalOrientation(char: number) {\n    if (isChar['Latin-1 Supplement'](char)) {\n        if (char === 0x00A7 /* section sign */ ||\n            char === 0x00A9 /* copyright sign */ ||\n            char === 0x00AE /* registered sign */ ||\n            char === 0x00B1 /* plus-minus sign */ ||\n            char === 0x00BC /* vulgar fraction one quarter */ ||\n            char === 0x00BD /* vulgar fraction one half */ ||\n            char === 0x00BE /* vulgar fraction three quarters */ ||\n            char === 0x00D7 /* multiplication sign */ ||\n            char === 0x00F7 /* division sign */) {\n            return true;\n        }\n    }\n    if (isChar['General Punctuation'](char)) {\n        if (char === 0x2016 /* double vertical line */ ||\n            char === 0x2020 /* dagger */ ||\n            char === 0x2021 /* double dagger */ ||\n            char === 0x2030 /* per mille sign */ ||\n            char === 0x2031 /* per ten thousand sign */ ||\n            char === 0x203B /* reference mark */ ||\n            char === 0x203C /* double exclamation mark */ ||\n            char === 0x2042 /* asterism */ ||\n            char === 0x2047 /* double question mark */ ||\n            char === 0x2048 /* question exclamation mark */ ||\n            char === 0x2049 /* exclamation question mark */ ||\n            char === 0x2051 /* two asterisks aligned vertically */) {\n            return true;\n        }\n    }\n    if (isChar['Letterlike Symbols'](char)) return true;\n    if (isChar['Number Forms'](char)) return true;\n    if (isChar['Miscellaneous Technical'](char)) {\n        if ((char >= 0x2300 /* diameter sign */ && char <= 0x2307 /* wavy line */) ||\n            (char >= 0x230C /* bottom right crop */ && char <= 0x231F /* bottom right corner */) ||\n            (char >= 0x2324 /* up arrowhead between two horizontal bars */ && char <= 0x2328 /* keyboard */) ||\n            char === 0x232B /* erase to the left */ ||\n            (char >= 0x237D /* shouldered open box */ && char <= 0x239A /* clear screen symbol */) ||\n            (char >= 0x23BE /* dentistry symbol light vertical and top right */ && char <= 0x23CD /* square foot */) ||\n            char === 0x23CF /* eject symbol */ ||\n            (char >= 0x23D1 /* metrical breve */ && char <= 0x23DB /* fuse */) ||\n            (char >= 0x23E2 /* white trapezium */ && char <= 0x23FF)) {\n            return true;\n        }\n    }\n    if (isChar['Control Pictures'](char) && char !== 0x2423 /* open box */) return true;\n    if (isChar['Optical Character Recognition'](char)) return true;\n    if (isChar['Enclosed Alphanumerics'](char)) return true;\n    if (isChar['Geometric Shapes'](char)) return true;\n    if (isChar['Miscellaneous Symbols'](char)) {\n        if (!((char >= 0x261A /* black left pointing index */ && char <= 0x261F) /* white down pointing index */)) {\n            return true;\n        }\n    }\n    if (isChar['Miscellaneous Symbols and Arrows'](char)) {\n        if ((char >= 0x2B12 /* square with top half black */ && char <= 0x2B2F /* white vertical ellipse */) ||\n            (char >= 0x2B50 /* white medium star */ && char <= 0x2B59 /* heavy circled saltire */) ||\n            (char >= 0x2BB8 /* upwards white arrow from bar with horizontal bar */ && char <= 0x2BEB)) {\n            return true;\n        }\n    }\n    if (isChar['CJK Symbols and Punctuation'](char)) return true;\n    if (isChar['Katakana'](char)) return true;\n    if (isChar['Private Use Area'](char)) return true;\n    if (isChar['CJK Compatibility Forms'](char)) return true;\n    if (isChar['Small Form Variants'](char)) return true;\n    if (isChar['Halfwidth and Fullwidth Forms'](char)) return true;\n\n    if (char === 0x221E /* infinity */ ||\n        char === 0x2234 /* therefore */ ||\n        char === 0x2235 /* because */ ||\n        (char >= 0x2700 /* black safety scissors */ && char <= 0x2767 /* rotated floral heart bullet */) ||\n        (char >= 0x2776 /* dingbat negative circled digit one */ && char <= 0x2793 /* dingbat negative circled sans-serif number ten */) ||\n        char === 0xFFFC /* object replacement character */ ||\n        char === 0xFFFD /* replacement character */) {\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Returns true if the given Unicode codepoint identifies a character with\n * rotated orientation.\n *\n * A character has rotated orientation if it is drawn rotated when the line is\n * oriented vertically, even if both adjacent characters are upright. For\n * example, a Latin letter is drawn rotated along a vertical line. A rotated\n * character causes an adjacent neutral character to be drawn rotated as well.\n * @private\n */\nexport function charHasRotatedVerticalOrientation(char: number) {\n    return !(charHasUprightVerticalOrientation(char) ||\n             charHasNeutralVerticalOrientation(char));\n}\n\nexport function charInSupportedScript(char: number, canRenderRTL: boolean) {\n    // This is a rough heuristic: whether we \"can render\" a script\n    // actually depends on the properties of the font being used\n    // and whether differences from the ideal rendering are considered\n    // semantically significant.\n\n    // Even in Latin script, we \"can't render\" combinations such as the fi\n    // ligature, but we don't consider that semantically significant.\n    if (!canRenderRTL &&\n        ((char >= 0x0590 && char <= 0x08FF) ||\n         isChar['Arabic Presentation Forms-A'](char) ||\n         isChar['Arabic Presentation Forms-B'](char))) {\n        // Main blocks for Hebrew, Arabic, Thaana and other RTL scripts\n        return false;\n    }\n    if ((char >= 0x0900 && char <= 0x0DFF) ||\n        // Main blocks for Indic scripts and Sinhala\n        (char >= 0x0F00 && char <= 0x109F) ||\n        // Main blocks for Tibetan and Myanmar\n        isChar['Khmer'](char)) {\n        // These blocks cover common scripts that require\n        // complex text shaping, based on unicode script metadata:\n        // http://www.unicode.org/repos/cldr/trunk/common/properties/scriptMetadata.txt\n        // where \"Web Rank <= 32\" \"Shaping Required = YES\"\n        return false;\n    }\n    return true;\n}\n\nexport function isStringInSupportedScript(chars: string, canRenderRTL: boolean) {\n    for (const char of chars) {\n        if (!charInSupportedScript(char.charCodeAt(0), canRenderRTL)) {\n            return false;\n        }\n    }\n    return true;\n}\n","// @flow\n\nimport window from './window';\nimport { extend } from './util';\nimport { isMapboxHTTPURL } from './mapbox';\nimport config from './config';\nimport assert from 'assert';\n\nimport type { Callback } from '../types/callback';\nimport type { Cancelable } from '../types/cancelable';\n\n/**\n * The type of a resource.\n * @private\n * @readonly\n * @enum {string}\n */\nconst ResourceType = {\n    Unknown: 'Unknown',\n    Style: 'Style',\n    Source: 'Source',\n    Tile: 'Tile',\n    Glyphs: 'Glyphs',\n    SpriteImage: 'SpriteImage',\n    SpriteJSON: 'SpriteJSON',\n    Image: 'Image'\n};\nexport { ResourceType };\n\nif (typeof Object.freeze == 'function') {\n    Object.freeze(ResourceType);\n}\n\n/**\n * A `RequestParameters` object to be returned from Map.options.transformRequest callbacks.\n * @typedef {Object} RequestParameters\n * @property {string} url The URL to be requested.\n * @property {Object} headers The headers to be sent with the request.\n * @property {string} credentials `'same-origin'|'include'` Use 'include' to send cookies with cross-origin requests.\n */\nexport type RequestParameters = {\n    url: string,\n    headers?: Object,\n    method?: 'GET' | 'POST' | 'PUT',\n    body?: string,\n    type?: 'string' | 'json' | 'arrayBuffer',\n    credentials?: 'same-origin' | 'include',\n    collectResourceTiming?: boolean\n};\n\nexport type ResponseCallback<T> = (error: ?Error, data: ?T, cacheControl: ?string, expires: ?string) => void;\n\nclass AJAXError extends Error {\n    status: number;\n    url: string;\n    constructor(message: string, status: number, url: string) {\n        if (status === 401 && isMapboxHTTPURL(url)) {\n            message += ': you may have provided an invalid Mapbox access token. See https://www.mapbox.com/api-documentation/#access-tokens';\n        }\n        super(message);\n        this.status = status;\n        this.url = url;\n\n        // work around for https://github.com/Rich-Harris/buble/issues/40\n        this.name = this.constructor.name;\n        this.message = message;\n    }\n\n    toString() {\n        return `${this.name}: ${this.message} (${this.status}): ${this.url}`;\n    }\n}\n\n// Ensure that we're sending the correct referrer from blob URL worker bundles.\n// For files loaded from the local file system, `location.origin` will be set\n// to the string(!) \"null\" (Firefox), or \"file://\" (Chrome, Safari, Edge, IE),\n// and we will set an empty referrer. Otherwise, we're using the document's URL.\n/* global self, WorkerGlobalScope */\nexport const getReferrer = typeof WorkerGlobalScope !== 'undefined' &&\n                           typeof self !== 'undefined' &&\n                           self instanceof WorkerGlobalScope ?\n    () => self.worker && self.worker.referrer :\n    () => {\n        const origin = window.location.origin;\n        if (origin && origin !== 'null' && origin !== 'file://') {\n            return origin + window.location.pathname;\n        }\n    };\n\nfunction makeFetchRequest(requestParameters: RequestParameters, callback: ResponseCallback<any>): Cancelable {\n    const controller = new window.AbortController();\n    const request = new window.Request(requestParameters.url, {\n        method: requestParameters.method || 'GET',\n        body: requestParameters.body,\n        credentials: requestParameters.credentials,\n        headers: requestParameters.headers,\n        referrer: getReferrer(),\n        signal: controller.signal\n    });\n\n    if (requestParameters.type === 'json') {\n        request.headers.set('Accept', 'application/json');\n    }\n\n    window.fetch(request).then(response => {\n        if (response.ok) {\n            response[requestParameters.type || 'text']().then(result => {\n                callback(null, result, response.headers.get('Cache-Control'), response.headers.get('Expires'));\n            }).catch(err => callback(new Error(err.message)));\n        } else {\n            callback(new AJAXError(response.statusText, response.status, requestParameters.url));\n        }\n    }).catch((error) => {\n        if (error.code === 20) {\n            // silence expected AbortError\n            return;\n        }\n        callback(new Error(error.message));\n    });\n\n    return { cancel: () => controller.abort() };\n}\n\nfunction makeXMLHttpRequest(requestParameters: RequestParameters, callback: ResponseCallback<any>): Cancelable {\n    const xhr: XMLHttpRequest = new window.XMLHttpRequest();\n\n    xhr.open(requestParameters.method || 'GET', requestParameters.url, true);\n    if (requestParameters.type === 'arrayBuffer') {\n        xhr.responseType = 'arraybuffer';\n    }\n    for (const k in requestParameters.headers) {\n        xhr.setRequestHeader(k, requestParameters.headers[k]);\n    }\n    if (requestParameters.type === 'json') {\n        xhr.setRequestHeader('Accept', 'application/json');\n    }\n    xhr.withCredentials = requestParameters.credentials === 'include';\n    xhr.onerror = () => {\n        callback(new Error(xhr.statusText));\n    };\n    xhr.onload = () => {\n        if (((xhr.status >= 200 && xhr.status < 300) || xhr.status === 0) && xhr.response !== null) {\n            let data: mixed = xhr.response;\n            if (requestParameters.type === 'json') {\n                // We're manually parsing JSON here to get better error messages.\n                try {\n                    data = JSON.parse(xhr.response);\n                } catch (err) {\n                    return callback(err);\n                }\n            }\n            callback(null, data, xhr.getResponseHeader('Cache-Control'), xhr.getResponseHeader('Expires'));\n        } else {\n            callback(new AJAXError(xhr.statusText, xhr.status, requestParameters.url));\n        }\n    };\n    xhr.send(requestParameters.body);\n    return { cancel: () => xhr.abort() };\n}\n\nconst makeRequest = window.fetch && window.Request && window.AbortController ? makeFetchRequest : makeXMLHttpRequest;\n\nexport const getJSON = function(requestParameters: RequestParameters, callback: ResponseCallback<Object>): Cancelable {\n    return makeRequest(extend(requestParameters, { type: 'json' }), callback);\n};\n\nexport const getArrayBuffer = function(requestParameters: RequestParameters, callback: ResponseCallback<ArrayBuffer>): Cancelable {\n    return makeRequest(extend(requestParameters, { type: 'arrayBuffer' }), callback);\n};\n\nexport const postData = function(requestParameters: RequestParameters, callback: ResponseCallback<string>): Cancelable {\n    return makeRequest(extend(requestParameters, { method: 'POST' }), callback);\n};\n\nfunction sameOrigin(url) {\n    const a: HTMLAnchorElement = window.document.createElement('a');\n    a.href = url;\n    return a.protocol === window.document.location.protocol && a.host === window.document.location.host;\n}\n\nconst transparentPngUrl = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=';\n\nlet imageQueue, numImageRequests;\nexport const resetImageRequestQueue = () => {\n    imageQueue = [];\n    numImageRequests = 0;\n};\nresetImageRequestQueue();\n\nexport const getImage = function(requestParameters: RequestParameters, callback: Callback<HTMLImageElement>): Cancelable {\n    // limit concurrent image loads to help with raster sources performance on big screens\n    if (numImageRequests >= config.MAX_PARALLEL_IMAGE_REQUESTS) {\n        const queued = {\n            requestParameters,\n            callback,\n            cancelled: false,\n            cancel() { this.cancelled = true; }\n        };\n        imageQueue.push(queued);\n        return queued;\n    }\n    numImageRequests++;\n\n    let advanced = false;\n    const advanceImageRequestQueue = () => {\n        if (advanced) return;\n        advanced = true;\n        numImageRequests--;\n        assert(numImageRequests >= 0);\n        while (imageQueue.length && numImageRequests < config.MAX_PARALLEL_IMAGE_REQUESTS) { // eslint-disable-line\n            const request = imageQueue.shift();\n            const {requestParameters, callback, cancelled} = request;\n            if (!cancelled) {\n                request.cancel = getImage(requestParameters, callback).cancel;\n            }\n        }\n    };\n\n    // request the image with XHR to work around caching issues\n    // see https://github.com/mapbox/mapbox-gl-js/issues/1470\n    const request = getArrayBuffer(requestParameters, (err: ?Error, data: ?ArrayBuffer, cacheControl: ?string, expires: ?string) => {\n\n        advanceImageRequestQueue();\n\n        if (err) {\n            callback(err);\n        } else if (data) {\n            const img: HTMLImageElement = new window.Image();\n            const URL = window.URL || window.webkitURL;\n            img.onload = () => {\n                callback(null, img);\n                URL.revokeObjectURL(img.src);\n            };\n            img.onerror = () => callback(new Error('Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.'));\n            const blob: Blob = new window.Blob([new Uint8Array(data)], { type: 'image/png' });\n            (img: any).cacheControl = cacheControl;\n            (img: any).expires = expires;\n            img.src = data.byteLength ? URL.createObjectURL(blob) : transparentPngUrl;\n        }\n    });\n\n    return {\n        cancel: () => {\n            request.cancel();\n            advanceImageRequestQueue();\n        }\n    };\n};\n\nexport const getVideo = function(urls: Array<string>, callback: Callback<HTMLVideoElement>): Cancelable {\n    const video: HTMLVideoElement = window.document.createElement('video');\n    video.muted = true;\n    video.onloadstart = function() {\n        callback(null, video);\n    };\n    for (let i = 0; i < urls.length; i++) {\n        const s: HTMLSourceElement = window.document.createElement('source');\n        if (!sameOrigin(urls[i])) {\n            video.crossOrigin = 'Anonymous';\n        }\n        s.src = urls[i];\n        video.appendChild(s);\n    }\n    return { cancel: () => {} };\n};\n","// @flow\n\nimport config from './config';\n\nimport browser from './browser';\nimport webpSupported from './webp_supported';\nimport window from './window';\nimport { version } from '../../package.json';\nimport { uuid, validateUuid, storageAvailable, warnOnce, extend } from './util';\nimport { postData } from './ajax';\n\nimport type { RequestParameters } from './ajax';\nimport type { Cancelable } from '../types/cancelable';\nimport type {TileJSON} from '../types/tilejson';\n\nconst help = 'See https://www.mapbox.com/api-documentation/#access-tokens';\nconst telemEventKey = 'mapbox.eventData';\n\ntype UrlObject = {|\n    protocol: string,\n    authority: string,\n    path: string,\n    params: Array<string>\n|};\n\nfunction makeAPIURL(urlObject: UrlObject, accessToken: string | null | void): string {\n    const apiUrlObject = parseUrl(config.API_URL);\n    urlObject.protocol = apiUrlObject.protocol;\n    urlObject.authority = apiUrlObject.authority;\n\n    if (apiUrlObject.path !== '/') {\n        urlObject.path = `${apiUrlObject.path}${urlObject.path}`;\n    }\n\n    if (!config.REQUIRE_ACCESS_TOKEN) return formatUrl(urlObject);\n\n    accessToken = accessToken || config.ACCESS_TOKEN;\n    if (!accessToken)\n        throw new Error(`An API access token is required to use Mapbox GL. ${help}`);\n    if (accessToken[0] === 's')\n        throw new Error(`Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ${help}`);\n\n    urlObject.params.push(`access_token=${accessToken}`);\n    return formatUrl(urlObject);\n}\n\nfunction isMapboxURL(url: string) {\n    return url.indexOf('mapbox:') === 0;\n}\n\nconst mapboxHTTPURLRe = /^((https?:)?\\/\\/)?([^\\/]+\\.)?mapbox\\.c(n|om)(\\/|\\?|$)/i;\nfunction isMapboxHTTPURL(url: string): boolean {\n    return mapboxHTTPURLRe.test(url);\n}\n\nexport { isMapboxURL, isMapboxHTTPURL };\n\nexport const normalizeStyleURL = function(url: string, accessToken?: string): string {\n    if (!isMapboxURL(url)) return url;\n    const urlObject = parseUrl(url);\n    urlObject.path = `/styles/v1${urlObject.path}`;\n    return makeAPIURL(urlObject, accessToken);\n};\n\nexport const normalizeGlyphsURL = function(url: string, accessToken?: string): string {\n    if (!isMapboxURL(url)) return url;\n    const urlObject = parseUrl(url);\n    urlObject.path = `/fonts/v1${urlObject.path}`;\n    return makeAPIURL(urlObject, accessToken);\n};\n\nexport const normalizeSourceURL = function(url: string, accessToken?: string): string {\n    if (!isMapboxURL(url)) return url;\n    const urlObject = parseUrl(url);\n    urlObject.path = `/v4/${urlObject.authority}.json`;\n    // TileJSON requests need a secure flag appended to their URLs so\n    // that the server knows to send SSL-ified resource references.\n    urlObject.params.push('secure');\n    return makeAPIURL(urlObject, accessToken);\n};\n\nexport const normalizeSpriteURL = function(url: string, format: string, extension: string, accessToken?: string): string {\n    const urlObject = parseUrl(url);\n    if (!isMapboxURL(url)) {\n        urlObject.path += `${format}${extension}`;\n        return formatUrl(urlObject);\n    }\n    urlObject.path = `/styles/v1${urlObject.path}/sprite${format}${extension}`;\n    return makeAPIURL(urlObject, accessToken);\n};\n\nconst imageExtensionRe = /(\\.(png|jpg)\\d*)(?=$)/;\n// matches any file extension specified by a dot and one or more alphanumeric characters\nconst extensionRe = /\\.[\\w]+$/;\n\nexport const normalizeTileURL = function(tileURL: string, sourceURL?: ?string, tileSize?: ?number): string {\n    if (!sourceURL || !isMapboxURL(sourceURL)) return tileURL;\n\n    const urlObject = parseUrl(tileURL);\n\n    // The v4 mapbox tile API supports 512x512 image tiles only when @2x\n    // is appended to the tile URL. If `tileSize: 512` is specified for\n    // a Mapbox raster source force the @2x suffix even if a non hidpi device.\n    const suffix = browser.devicePixelRatio >= 2 || tileSize === 512 ? '@2x' : '';\n    const extension = webpSupported.supported ? '.webp' : '$1';\n    urlObject.path = urlObject.path.replace(imageExtensionRe, `${suffix}${extension}`);\n    urlObject.path = `/v4${urlObject.path}`;\n\n    return makeAPIURL(urlObject);\n};\n\nexport const canonicalizeTileURL = function(url: string) {\n    const version = \"/v4/\";\n\n    const urlObject = parseUrl(url);\n    // Make sure that we are dealing with a valid Mapbox tile URL.\n    // Has to begin with /v4/, with a valid filename + extension\n    if (!urlObject.path.match(/(^\\/v4\\/)/) || !urlObject.path.match(extensionRe)) {\n        // Not a proper Mapbox tile URL.\n        return url;\n    }\n    // Reassemble the canonical URL from the parts we've parsed before.\n    let result = \"mapbox://tiles/\";\n    result +=  urlObject.path.replace(version, '');\n\n    // Append the query string, minus the access token parameter.\n    const params = urlObject.params.filter(p => !p.match(/^access_token=/));\n    if (params.length) result += `?${params.join('&')}`;\n    return result;\n};\n\nexport const canonicalizeTileset = function(tileJSON: TileJSON, sourceURL: string) {\n    if (!isMapboxURL(sourceURL)) return tileJSON.tiles || [];\n    const canonical = [];\n    for (const url of tileJSON.tiles) {\n        const canonicalUrl = canonicalizeTileURL(url);\n        canonical.push(canonicalUrl);\n    }\n    return canonical;\n};\n\nconst urlRe = /^(\\w+):\\/\\/([^/?]*)(\\/[^?]+)?\\??(.+)?/;\n\nfunction parseUrl(url: string): UrlObject {\n    const parts = url.match(urlRe);\n    if (!parts) {\n        throw new Error('Unable to parse URL object');\n    }\n    return {\n        protocol: parts[1],\n        authority: parts[2],\n        path: parts[3] || '/',\n        params: parts[4] ? parts[4].split('&') : []\n    };\n}\n\nfunction formatUrl(obj: UrlObject): string {\n    const params = obj.params.length ? `?${obj.params.join('&')}` : '';\n    return `${obj.protocol}://${obj.authority}${obj.path}${params}`;\n}\n\ntype TelemetryEventType = 'appUserTurnstile' | 'map.load';\n\nclass TelemetryEvent {\n    eventData: { lastSuccess: ?number, accessToken: ?string};\n    anonId: ?string;\n    queue: Array<any>;\n    type: TelemetryEventType;\n    pendingRequest: ?Cancelable;\n\n    constructor(type: TelemetryEventType) {\n        this.type = type;\n        this.anonId = null;\n        this.eventData = {lastSuccess: null, accessToken: config.ACCESS_TOKEN};\n        this.queue = [];\n        this.pendingRequest = null;\n    }\n\n    fetchEventData() {\n        const isLocalStorageAvailable = storageAvailable('localStorage');\n        const storageKey = `${telemEventKey}:${config.ACCESS_TOKEN || ''}`;\n        const uuidKey = `${telemEventKey}.uuid:${config.ACCESS_TOKEN || ''}`;\n\n        if (isLocalStorageAvailable) {\n            //Retrieve cached data\n            try {\n                const data = window.localStorage.getItem(storageKey);\n                if (data) {\n                    this.eventData = JSON.parse(data);\n                }\n\n                const uuid = window.localStorage.getItem(uuidKey);\n                if (uuid) this.anonId = uuid;\n            } catch (e) {\n                warnOnce('Unable to read from LocalStorage');\n            }\n        }\n    }\n\n    saveEventData() {\n        const isLocalStorageAvailable = storageAvailable('localStorage');\n        const storageKey = `${telemEventKey}:${config.ACCESS_TOKEN || ''}`;\n        const uuidKey = `${telemEventKey}.uuid:${config.ACCESS_TOKEN || ''}`;\n        if (isLocalStorageAvailable) {\n            try {\n                window.localStorage.setItem(uuidKey, this.anonId);\n                if (this.eventData.lastSuccess) {\n                    window.localStorage.setItem(storageKey, JSON.stringify(this.eventData));\n                }\n            } catch (e) {\n                warnOnce('Unable to write to LocalStorage');\n            }\n        }\n\n    }\n\n    processRequests() {}\n\n    /*\n    * If any event data should be persisted after the POST request, the callback should modify eventData`\n    * to the values that should be saved. For this reason, the callback should be invoked prior to the call\n    * to TelemetryEvent#saveData\n    */\n    postEvent(timestamp: number, additionalPayload: {[string]: any}, callback: (err: ?Error) => void) {\n        const eventsUrlObject: UrlObject = parseUrl(config.EVENTS_URL);\n        eventsUrlObject.params.push(`access_token=${config.ACCESS_TOKEN || ''}`);\n        const payload: Object = {\n            event: this.type,\n            created: new Date(timestamp).toISOString(),\n            sdkIdentifier: 'mapbox-gl-js',\n            sdkVersion: version,\n            userId: this.anonId\n        };\n\n        const finalPayload = additionalPayload ? extend(payload, additionalPayload) : payload;\n        const request: RequestParameters = {\n            url: formatUrl(eventsUrlObject),\n            headers: {\n                'Content-Type': 'text/plain' //Skip the pre-flight OPTIONS request\n            },\n            body: JSON.stringify([finalPayload])\n        };\n\n        this.pendingRequest = postData(request, (error) => {\n            this.pendingRequest = null;\n            callback(error);\n            this.saveEventData();\n            this.processRequests();\n        });\n    }\n\n    queueRequest(event: number | {id: number, timestamp: number}) {\n        this.queue.push(event);\n        this.processRequests();\n    }\n}\n\nexport class MapLoadEvent extends TelemetryEvent {\n    +success: {[number]: boolean};\n\n    constructor() {\n        super('map.load');\n        this.success = {};\n    }\n\n    postMapLoadEvent(tileUrls: Array<string>, mapId: number) {\n        //Enabled only when Mapbox Access Token is set and a source uses\n        // mapbox tiles.\n        if (config.ACCESS_TOKEN &&\n            Array.isArray(tileUrls) &&\n            tileUrls.some(url => isMapboxHTTPURL(url))) {\n            this.queueRequest({id: mapId, timestamp: Date.now()});\n        }\n    }\n\n    processRequests() {\n        if (this.pendingRequest || this.queue.length === 0) return;\n        const {id, timestamp} = this.queue.shift();\n\n        // Only one load event should fire per map\n        if (id && this.success[id]) return;\n\n        if (!this.anonId) {\n            this.fetchEventData();\n        }\n\n        if (!validateUuid(this.anonId)) {\n            this.anonId = uuid();\n        }\n\n        this.postEvent(timestamp, {}, (err) => {\n            if (!err) {\n                if (id) this.success[id] = true;\n            }\n        });\n    }\n}\n\n\nexport class TurnstileEvent extends TelemetryEvent {\n    constructor() {\n        super('appUserTurnstile');\n    }\n\n    postTurnstileEvent(tileUrls: Array<string>) {\n        //Enabled only when Mapbox Access Token is set and a source uses\n        // mapbox tiles.\n        if (config.ACCESS_TOKEN &&\n            Array.isArray(tileUrls) &&\n            tileUrls.some(url => isMapboxHTTPURL(url))) {\n            this.queueRequest(Date.now());\n        }\n    }\n\n\n    processRequests() {\n        if (this.pendingRequest || this.queue.length === 0) {\n            return;\n        }\n\n        let dueForEvent = this.eventData.accessToken ? (this.eventData.accessToken !== config.ACCESS_TOKEN) : false;\n        //Reset event data cache if the access token changed.\n        if (dueForEvent) {\n            this.anonId = this.eventData.lastSuccess = null;\n        }\n        if (!this.anonId || !this.eventData.lastSuccess) {\n            //Retrieve cached data\n            this.fetchEventData();\n        }\n\n        if (!validateUuid(this.anonId)) {\n            this.anonId = uuid();\n            dueForEvent = true;\n        }\n\n        const nextUpdate = this.queue.shift();\n        // Record turnstile event once per calendar day.\n        if (this.eventData.lastSuccess) {\n            const lastUpdate = new Date(this.eventData.lastSuccess);\n            const nextDate = new Date(nextUpdate);\n            const daysElapsed = (nextUpdate - this.eventData.lastSuccess) / (24 * 60 * 60 * 1000);\n            dueForEvent = dueForEvent || daysElapsed >= 1 || daysElapsed < -1 || lastUpdate.getDate() !== nextDate.getDate();\n        } else {\n            dueForEvent = true;\n        }\n\n        if (!dueForEvent) {\n            return this.processRequests();\n        }\n\n        this.postEvent(nextUpdate, {\"enabled.telemetry\": false}, (err) => {\n            if (!err) {\n                this.eventData.lastSuccess = nextUpdate;\n                this.eventData.accessToken = config.ACCESS_TOKEN;\n            }\n        });\n    }\n}\n\nconst turnstileEvent_ = new TurnstileEvent();\nexport const postTurnstileEvent = turnstileEvent_.postTurnstileEvent.bind(turnstileEvent_);\n\nconst mapLoadEvent_ = new MapLoadEvent();\nexport const postMapLoadEvent = mapLoadEvent_.postMapLoadEvent.bind(mapLoadEvent_);\n","import * as glMatrix from \"./common.js\";\r\n\r\n/**\r\n * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.\r\n * @module mat4\r\n */\r\n\r\n/**\r\n * Creates a new identity mat4\r\n *\r\n * @returns {mat4} a new 4x4 matrix\r\n */\r\nexport function create() {\r\n  var out = new glMatrix.ARRAY_TYPE(16);\r\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\r\n    out[1] = 0;\r\n    out[2] = 0;\r\n    out[3] = 0;\r\n    out[4] = 0;\r\n    out[6] = 0;\r\n    out[7] = 0;\r\n    out[8] = 0;\r\n    out[9] = 0;\r\n    out[11] = 0;\r\n    out[12] = 0;\r\n    out[13] = 0;\r\n    out[14] = 0;\r\n  }\r\n  out[0] = 1;\r\n  out[5] = 1;\r\n  out[10] = 1;\r\n  out[15] = 1;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a new mat4 initialized with values from an existing matrix\r\n *\r\n * @param {mat4} a matrix to clone\r\n * @returns {mat4} a new 4x4 matrix\r\n */\r\nexport function clone(a) {\r\n  var out = new glMatrix.ARRAY_TYPE(16);\r\n  out[0] = a[0];\r\n  out[1] = a[1];\r\n  out[2] = a[2];\r\n  out[3] = a[3];\r\n  out[4] = a[4];\r\n  out[5] = a[5];\r\n  out[6] = a[6];\r\n  out[7] = a[7];\r\n  out[8] = a[8];\r\n  out[9] = a[9];\r\n  out[10] = a[10];\r\n  out[11] = a[11];\r\n  out[12] = a[12];\r\n  out[13] = a[13];\r\n  out[14] = a[14];\r\n  out[15] = a[15];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Copy the values from one mat4 to another\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the source matrix\r\n * @returns {mat4} out\r\n */\r\nexport function copy(out, a) {\r\n  out[0] = a[0];\r\n  out[1] = a[1];\r\n  out[2] = a[2];\r\n  out[3] = a[3];\r\n  out[4] = a[4];\r\n  out[5] = a[5];\r\n  out[6] = a[6];\r\n  out[7] = a[7];\r\n  out[8] = a[8];\r\n  out[9] = a[9];\r\n  out[10] = a[10];\r\n  out[11] = a[11];\r\n  out[12] = a[12];\r\n  out[13] = a[13];\r\n  out[14] = a[14];\r\n  out[15] = a[15];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Create a new mat4 with the given values\r\n *\r\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\r\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\r\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\r\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\r\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\r\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\r\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\r\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\r\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\r\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\r\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\r\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\r\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\r\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\r\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\r\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\r\n * @returns {mat4} A new mat4\r\n */\r\nexport function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\r\n  var out = new glMatrix.ARRAY_TYPE(16);\r\n  out[0] = m00;\r\n  out[1] = m01;\r\n  out[2] = m02;\r\n  out[3] = m03;\r\n  out[4] = m10;\r\n  out[5] = m11;\r\n  out[6] = m12;\r\n  out[7] = m13;\r\n  out[8] = m20;\r\n  out[9] = m21;\r\n  out[10] = m22;\r\n  out[11] = m23;\r\n  out[12] = m30;\r\n  out[13] = m31;\r\n  out[14] = m32;\r\n  out[15] = m33;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Set the components of a mat4 to the given values\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\r\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\r\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\r\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\r\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\r\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\r\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\r\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\r\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\r\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\r\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\r\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\r\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\r\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\r\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\r\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\r\n * @returns {mat4} out\r\n */\r\nexport function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\r\n  out[0] = m00;\r\n  out[1] = m01;\r\n  out[2] = m02;\r\n  out[3] = m03;\r\n  out[4] = m10;\r\n  out[5] = m11;\r\n  out[6] = m12;\r\n  out[7] = m13;\r\n  out[8] = m20;\r\n  out[9] = m21;\r\n  out[10] = m22;\r\n  out[11] = m23;\r\n  out[12] = m30;\r\n  out[13] = m31;\r\n  out[14] = m32;\r\n  out[15] = m33;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Set a mat4 to the identity matrix\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @returns {mat4} out\r\n */\r\nexport function identity(out) {\r\n  out[0] = 1;\r\n  out[1] = 0;\r\n  out[2] = 0;\r\n  out[3] = 0;\r\n  out[4] = 0;\r\n  out[5] = 1;\r\n  out[6] = 0;\r\n  out[7] = 0;\r\n  out[8] = 0;\r\n  out[9] = 0;\r\n  out[10] = 1;\r\n  out[11] = 0;\r\n  out[12] = 0;\r\n  out[13] = 0;\r\n  out[14] = 0;\r\n  out[15] = 1;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Transpose the values of a mat4\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the source matrix\r\n * @returns {mat4} out\r\n */\r\nexport function transpose(out, a) {\r\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\r\n  if (out === a) {\r\n    var a01 = a[1],\r\n        a02 = a[2],\r\n        a03 = a[3];\r\n    var a12 = a[6],\r\n        a13 = a[7];\r\n    var a23 = a[11];\r\n\r\n    out[1] = a[4];\r\n    out[2] = a[8];\r\n    out[3] = a[12];\r\n    out[4] = a01;\r\n    out[6] = a[9];\r\n    out[7] = a[13];\r\n    out[8] = a02;\r\n    out[9] = a12;\r\n    out[11] = a[14];\r\n    out[12] = a03;\r\n    out[13] = a13;\r\n    out[14] = a23;\r\n  } else {\r\n    out[0] = a[0];\r\n    out[1] = a[4];\r\n    out[2] = a[8];\r\n    out[3] = a[12];\r\n    out[4] = a[1];\r\n    out[5] = a[5];\r\n    out[6] = a[9];\r\n    out[7] = a[13];\r\n    out[8] = a[2];\r\n    out[9] = a[6];\r\n    out[10] = a[10];\r\n    out[11] = a[14];\r\n    out[12] = a[3];\r\n    out[13] = a[7];\r\n    out[14] = a[11];\r\n    out[15] = a[15];\r\n  }\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Inverts a mat4\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the source matrix\r\n * @returns {mat4} out\r\n */\r\nexport function invert(out, a) {\r\n  var a00 = a[0],\r\n      a01 = a[1],\r\n      a02 = a[2],\r\n      a03 = a[3];\r\n  var a10 = a[4],\r\n      a11 = a[5],\r\n      a12 = a[6],\r\n      a13 = a[7];\r\n  var a20 = a[8],\r\n      a21 = a[9],\r\n      a22 = a[10],\r\n      a23 = a[11];\r\n  var a30 = a[12],\r\n      a31 = a[13],\r\n      a32 = a[14],\r\n      a33 = a[15];\r\n\r\n  var b00 = a00 * a11 - a01 * a10;\r\n  var b01 = a00 * a12 - a02 * a10;\r\n  var b02 = a00 * a13 - a03 * a10;\r\n  var b03 = a01 * a12 - a02 * a11;\r\n  var b04 = a01 * a13 - a03 * a11;\r\n  var b05 = a02 * a13 - a03 * a12;\r\n  var b06 = a20 * a31 - a21 * a30;\r\n  var b07 = a20 * a32 - a22 * a30;\r\n  var b08 = a20 * a33 - a23 * a30;\r\n  var b09 = a21 * a32 - a22 * a31;\r\n  var b10 = a21 * a33 - a23 * a31;\r\n  var b11 = a22 * a33 - a23 * a32;\r\n\r\n  // Calculate the determinant\r\n  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\r\n\r\n  if (!det) {\r\n    return null;\r\n  }\r\n  det = 1.0 / det;\r\n\r\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\r\n  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\r\n  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\r\n  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\r\n  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\r\n  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\r\n  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\r\n  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\r\n  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\r\n  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\r\n  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\r\n  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\r\n  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\r\n  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\r\n  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\r\n  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Calculates the adjugate of a mat4\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the source matrix\r\n * @returns {mat4} out\r\n */\r\nexport function adjoint(out, a) {\r\n  var a00 = a[0],\r\n      a01 = a[1],\r\n      a02 = a[2],\r\n      a03 = a[3];\r\n  var a10 = a[4],\r\n      a11 = a[5],\r\n      a12 = a[6],\r\n      a13 = a[7];\r\n  var a20 = a[8],\r\n      a21 = a[9],\r\n      a22 = a[10],\r\n      a23 = a[11];\r\n  var a30 = a[12],\r\n      a31 = a[13],\r\n      a32 = a[14],\r\n      a33 = a[15];\r\n\r\n  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);\r\n  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));\r\n  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);\r\n  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));\r\n  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));\r\n  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);\r\n  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));\r\n  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);\r\n  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);\r\n  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));\r\n  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);\r\n  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));\r\n  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));\r\n  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);\r\n  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));\r\n  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);\r\n  return out;\r\n}\r\n\r\n/**\r\n * Calculates the determinant of a mat4\r\n *\r\n * @param {mat4} a the source matrix\r\n * @returns {Number} determinant of a\r\n */\r\nexport function determinant(a) {\r\n  var a00 = a[0],\r\n      a01 = a[1],\r\n      a02 = a[2],\r\n      a03 = a[3];\r\n  var a10 = a[4],\r\n      a11 = a[5],\r\n      a12 = a[6],\r\n      a13 = a[7];\r\n  var a20 = a[8],\r\n      a21 = a[9],\r\n      a22 = a[10],\r\n      a23 = a[11];\r\n  var a30 = a[12],\r\n      a31 = a[13],\r\n      a32 = a[14],\r\n      a33 = a[15];\r\n\r\n  var b00 = a00 * a11 - a01 * a10;\r\n  var b01 = a00 * a12 - a02 * a10;\r\n  var b02 = a00 * a13 - a03 * a10;\r\n  var b03 = a01 * a12 - a02 * a11;\r\n  var b04 = a01 * a13 - a03 * a11;\r\n  var b05 = a02 * a13 - a03 * a12;\r\n  var b06 = a20 * a31 - a21 * a30;\r\n  var b07 = a20 * a32 - a22 * a30;\r\n  var b08 = a20 * a33 - a23 * a30;\r\n  var b09 = a21 * a32 - a22 * a31;\r\n  var b10 = a21 * a33 - a23 * a31;\r\n  var b11 = a22 * a33 - a23 * a32;\r\n\r\n  // Calculate the determinant\r\n  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\r\n}\r\n\r\n/**\r\n * Multiplies two mat4s\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the first operand\r\n * @param {mat4} b the second operand\r\n * @returns {mat4} out\r\n */\r\nexport function multiply(out, a, b) {\r\n  var a00 = a[0],\r\n      a01 = a[1],\r\n      a02 = a[2],\r\n      a03 = a[3];\r\n  var a10 = a[4],\r\n      a11 = a[5],\r\n      a12 = a[6],\r\n      a13 = a[7];\r\n  var a20 = a[8],\r\n      a21 = a[9],\r\n      a22 = a[10],\r\n      a23 = a[11];\r\n  var a30 = a[12],\r\n      a31 = a[13],\r\n      a32 = a[14],\r\n      a33 = a[15];\r\n\r\n  // Cache only the current line of the second matrix\r\n  var b0 = b[0],\r\n      b1 = b[1],\r\n      b2 = b[2],\r\n      b3 = b[3];\r\n  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\r\n  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\r\n  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\r\n  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\r\n\r\n  b0 = b[4];b1 = b[5];b2 = b[6];b3 = b[7];\r\n  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\r\n  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\r\n  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\r\n  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\r\n\r\n  b0 = b[8];b1 = b[9];b2 = b[10];b3 = b[11];\r\n  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\r\n  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\r\n  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\r\n  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\r\n\r\n  b0 = b[12];b1 = b[13];b2 = b[14];b3 = b[15];\r\n  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\r\n  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\r\n  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\r\n  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Translate a mat4 by the given vector\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the matrix to translate\r\n * @param {vec3} v vector to translate by\r\n * @returns {mat4} out\r\n */\r\nexport function translate(out, a, v) {\r\n  var x = v[0],\r\n      y = v[1],\r\n      z = v[2];\r\n  var a00 = void 0,\r\n      a01 = void 0,\r\n      a02 = void 0,\r\n      a03 = void 0;\r\n  var a10 = void 0,\r\n      a11 = void 0,\r\n      a12 = void 0,\r\n      a13 = void 0;\r\n  var a20 = void 0,\r\n      a21 = void 0,\r\n      a22 = void 0,\r\n      a23 = void 0;\r\n\r\n  if (a === out) {\r\n    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\r\n    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\r\n    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\r\n    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\r\n  } else {\r\n    a00 = a[0];a01 = a[1];a02 = a[2];a03 = a[3];\r\n    a10 = a[4];a11 = a[5];a12 = a[6];a13 = a[7];\r\n    a20 = a[8];a21 = a[9];a22 = a[10];a23 = a[11];\r\n\r\n    out[0] = a00;out[1] = a01;out[2] = a02;out[3] = a03;\r\n    out[4] = a10;out[5] = a11;out[6] = a12;out[7] = a13;\r\n    out[8] = a20;out[9] = a21;out[10] = a22;out[11] = a23;\r\n\r\n    out[12] = a00 * x + a10 * y + a20 * z + a[12];\r\n    out[13] = a01 * x + a11 * y + a21 * z + a[13];\r\n    out[14] = a02 * x + a12 * y + a22 * z + a[14];\r\n    out[15] = a03 * x + a13 * y + a23 * z + a[15];\r\n  }\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Scales the mat4 by the dimensions in the given vec3 not using vectorization\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the matrix to scale\r\n * @param {vec3} v the vec3 to scale the matrix by\r\n * @returns {mat4} out\r\n **/\r\nexport function scale(out, a, v) {\r\n  var x = v[0],\r\n      y = v[1],\r\n      z = v[2];\r\n\r\n  out[0] = a[0] * x;\r\n  out[1] = a[1] * x;\r\n  out[2] = a[2] * x;\r\n  out[3] = a[3] * x;\r\n  out[4] = a[4] * y;\r\n  out[5] = a[5] * y;\r\n  out[6] = a[6] * y;\r\n  out[7] = a[7] * y;\r\n  out[8] = a[8] * z;\r\n  out[9] = a[9] * z;\r\n  out[10] = a[10] * z;\r\n  out[11] = a[11] * z;\r\n  out[12] = a[12];\r\n  out[13] = a[13];\r\n  out[14] = a[14];\r\n  out[15] = a[15];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Rotates a mat4 by the given angle around the given axis\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @param {vec3} axis the axis to rotate around\r\n * @returns {mat4} out\r\n */\r\nexport function rotate(out, a, rad, axis) {\r\n  var x = axis[0],\r\n      y = axis[1],\r\n      z = axis[2];\r\n  var len = Math.sqrt(x * x + y * y + z * z);\r\n  var s = void 0,\r\n      c = void 0,\r\n      t = void 0;\r\n  var a00 = void 0,\r\n      a01 = void 0,\r\n      a02 = void 0,\r\n      a03 = void 0;\r\n  var a10 = void 0,\r\n      a11 = void 0,\r\n      a12 = void 0,\r\n      a13 = void 0;\r\n  var a20 = void 0,\r\n      a21 = void 0,\r\n      a22 = void 0,\r\n      a23 = void 0;\r\n  var b00 = void 0,\r\n      b01 = void 0,\r\n      b02 = void 0;\r\n  var b10 = void 0,\r\n      b11 = void 0,\r\n      b12 = void 0;\r\n  var b20 = void 0,\r\n      b21 = void 0,\r\n      b22 = void 0;\r\n\r\n  if (len < glMatrix.EPSILON) {\r\n    return null;\r\n  }\r\n\r\n  len = 1 / len;\r\n  x *= len;\r\n  y *= len;\r\n  z *= len;\r\n\r\n  s = Math.sin(rad);\r\n  c = Math.cos(rad);\r\n  t = 1 - c;\r\n\r\n  a00 = a[0];a01 = a[1];a02 = a[2];a03 = a[3];\r\n  a10 = a[4];a11 = a[5];a12 = a[6];a13 = a[7];\r\n  a20 = a[8];a21 = a[9];a22 = a[10];a23 = a[11];\r\n\r\n  // Construct the elements of the rotation matrix\r\n  b00 = x * x * t + c;b01 = y * x * t + z * s;b02 = z * x * t - y * s;\r\n  b10 = x * y * t - z * s;b11 = y * y * t + c;b12 = z * y * t + x * s;\r\n  b20 = x * z * t + y * s;b21 = y * z * t - x * s;b22 = z * z * t + c;\r\n\r\n  // Perform rotation-specific matrix multiplication\r\n  out[0] = a00 * b00 + a10 * b01 + a20 * b02;\r\n  out[1] = a01 * b00 + a11 * b01 + a21 * b02;\r\n  out[2] = a02 * b00 + a12 * b01 + a22 * b02;\r\n  out[3] = a03 * b00 + a13 * b01 + a23 * b02;\r\n  out[4] = a00 * b10 + a10 * b11 + a20 * b12;\r\n  out[5] = a01 * b10 + a11 * b11 + a21 * b12;\r\n  out[6] = a02 * b10 + a12 * b11 + a22 * b12;\r\n  out[7] = a03 * b10 + a13 * b11 + a23 * b12;\r\n  out[8] = a00 * b20 + a10 * b21 + a20 * b22;\r\n  out[9] = a01 * b20 + a11 * b21 + a21 * b22;\r\n  out[10] = a02 * b20 + a12 * b21 + a22 * b22;\r\n  out[11] = a03 * b20 + a13 * b21 + a23 * b22;\r\n\r\n  if (a !== out) {\r\n    // If the source and destination differ, copy the unchanged last row\r\n    out[12] = a[12];\r\n    out[13] = a[13];\r\n    out[14] = a[14];\r\n    out[15] = a[15];\r\n  }\r\n  return out;\r\n}\r\n\r\n/**\r\n * Rotates a matrix by the given angle around the X axis\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\r\nexport function rotateX(out, a, rad) {\r\n  var s = Math.sin(rad);\r\n  var c = Math.cos(rad);\r\n  var a10 = a[4];\r\n  var a11 = a[5];\r\n  var a12 = a[6];\r\n  var a13 = a[7];\r\n  var a20 = a[8];\r\n  var a21 = a[9];\r\n  var a22 = a[10];\r\n  var a23 = a[11];\r\n\r\n  if (a !== out) {\r\n    // If the source and destination differ, copy the unchanged rows\r\n    out[0] = a[0];\r\n    out[1] = a[1];\r\n    out[2] = a[2];\r\n    out[3] = a[3];\r\n    out[12] = a[12];\r\n    out[13] = a[13];\r\n    out[14] = a[14];\r\n    out[15] = a[15];\r\n  }\r\n\r\n  // Perform axis-specific matrix multiplication\r\n  out[4] = a10 * c + a20 * s;\r\n  out[5] = a11 * c + a21 * s;\r\n  out[6] = a12 * c + a22 * s;\r\n  out[7] = a13 * c + a23 * s;\r\n  out[8] = a20 * c - a10 * s;\r\n  out[9] = a21 * c - a11 * s;\r\n  out[10] = a22 * c - a12 * s;\r\n  out[11] = a23 * c - a13 * s;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Rotates a matrix by the given angle around the Y axis\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\r\nexport function rotateY(out, a, rad) {\r\n  var s = Math.sin(rad);\r\n  var c = Math.cos(rad);\r\n  var a00 = a[0];\r\n  var a01 = a[1];\r\n  var a02 = a[2];\r\n  var a03 = a[3];\r\n  var a20 = a[8];\r\n  var a21 = a[9];\r\n  var a22 = a[10];\r\n  var a23 = a[11];\r\n\r\n  if (a !== out) {\r\n    // If the source and destination differ, copy the unchanged rows\r\n    out[4] = a[4];\r\n    out[5] = a[5];\r\n    out[6] = a[6];\r\n    out[7] = a[7];\r\n    out[12] = a[12];\r\n    out[13] = a[13];\r\n    out[14] = a[14];\r\n    out[15] = a[15];\r\n  }\r\n\r\n  // Perform axis-specific matrix multiplication\r\n  out[0] = a00 * c - a20 * s;\r\n  out[1] = a01 * c - a21 * s;\r\n  out[2] = a02 * c - a22 * s;\r\n  out[3] = a03 * c - a23 * s;\r\n  out[8] = a00 * s + a20 * c;\r\n  out[9] = a01 * s + a21 * c;\r\n  out[10] = a02 * s + a22 * c;\r\n  out[11] = a03 * s + a23 * c;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Rotates a matrix by the given angle around the Z axis\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\r\nexport function rotateZ(out, a, rad) {\r\n  var s = Math.sin(rad);\r\n  var c = Math.cos(rad);\r\n  var a00 = a[0];\r\n  var a01 = a[1];\r\n  var a02 = a[2];\r\n  var a03 = a[3];\r\n  var a10 = a[4];\r\n  var a11 = a[5];\r\n  var a12 = a[6];\r\n  var a13 = a[7];\r\n\r\n  if (a !== out) {\r\n    // If the source and destination differ, copy the unchanged last row\r\n    out[8] = a[8];\r\n    out[9] = a[9];\r\n    out[10] = a[10];\r\n    out[11] = a[11];\r\n    out[12] = a[12];\r\n    out[13] = a[13];\r\n    out[14] = a[14];\r\n    out[15] = a[15];\r\n  }\r\n\r\n  // Perform axis-specific matrix multiplication\r\n  out[0] = a00 * c + a10 * s;\r\n  out[1] = a01 * c + a11 * s;\r\n  out[2] = a02 * c + a12 * s;\r\n  out[3] = a03 * c + a13 * s;\r\n  out[4] = a10 * c - a00 * s;\r\n  out[5] = a11 * c - a01 * s;\r\n  out[6] = a12 * c - a02 * s;\r\n  out[7] = a13 * c - a03 * s;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a matrix from a vector translation\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.translate(dest, dest, vec);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {vec3} v Translation vector\r\n * @returns {mat4} out\r\n */\r\nexport function fromTranslation(out, v) {\r\n  out[0] = 1;\r\n  out[1] = 0;\r\n  out[2] = 0;\r\n  out[3] = 0;\r\n  out[4] = 0;\r\n  out[5] = 1;\r\n  out[6] = 0;\r\n  out[7] = 0;\r\n  out[8] = 0;\r\n  out[9] = 0;\r\n  out[10] = 1;\r\n  out[11] = 0;\r\n  out[12] = v[0];\r\n  out[13] = v[1];\r\n  out[14] = v[2];\r\n  out[15] = 1;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a matrix from a vector scaling\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.scale(dest, dest, vec);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {vec3} v Scaling vector\r\n * @returns {mat4} out\r\n */\r\nexport function fromScaling(out, v) {\r\n  out[0] = v[0];\r\n  out[1] = 0;\r\n  out[2] = 0;\r\n  out[3] = 0;\r\n  out[4] = 0;\r\n  out[5] = v[1];\r\n  out[6] = 0;\r\n  out[7] = 0;\r\n  out[8] = 0;\r\n  out[9] = 0;\r\n  out[10] = v[2];\r\n  out[11] = 0;\r\n  out[12] = 0;\r\n  out[13] = 0;\r\n  out[14] = 0;\r\n  out[15] = 1;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a matrix from a given angle around a given axis\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.rotate(dest, dest, rad, axis);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @param {vec3} axis the axis to rotate around\r\n * @returns {mat4} out\r\n */\r\nexport function fromRotation(out, rad, axis) {\r\n  var x = axis[0],\r\n      y = axis[1],\r\n      z = axis[2];\r\n  var len = Math.sqrt(x * x + y * y + z * z);\r\n  var s = void 0,\r\n      c = void 0,\r\n      t = void 0;\r\n\r\n  if (len < glMatrix.EPSILON) {\r\n    return null;\r\n  }\r\n\r\n  len = 1 / len;\r\n  x *= len;\r\n  y *= len;\r\n  z *= len;\r\n\r\n  s = Math.sin(rad);\r\n  c = Math.cos(rad);\r\n  t = 1 - c;\r\n\r\n  // Perform rotation-specific matrix multiplication\r\n  out[0] = x * x * t + c;\r\n  out[1] = y * x * t + z * s;\r\n  out[2] = z * x * t - y * s;\r\n  out[3] = 0;\r\n  out[4] = x * y * t - z * s;\r\n  out[5] = y * y * t + c;\r\n  out[6] = z * y * t + x * s;\r\n  out[7] = 0;\r\n  out[8] = x * z * t + y * s;\r\n  out[9] = y * z * t - x * s;\r\n  out[10] = z * z * t + c;\r\n  out[11] = 0;\r\n  out[12] = 0;\r\n  out[13] = 0;\r\n  out[14] = 0;\r\n  out[15] = 1;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a matrix from the given angle around the X axis\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.rotateX(dest, dest, rad);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\r\nexport function fromXRotation(out, rad) {\r\n  var s = Math.sin(rad);\r\n  var c = Math.cos(rad);\r\n\r\n  // Perform axis-specific matrix multiplication\r\n  out[0] = 1;\r\n  out[1] = 0;\r\n  out[2] = 0;\r\n  out[3] = 0;\r\n  out[4] = 0;\r\n  out[5] = c;\r\n  out[6] = s;\r\n  out[7] = 0;\r\n  out[8] = 0;\r\n  out[9] = -s;\r\n  out[10] = c;\r\n  out[11] = 0;\r\n  out[12] = 0;\r\n  out[13] = 0;\r\n  out[14] = 0;\r\n  out[15] = 1;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a matrix from the given angle around the Y axis\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.rotateY(dest, dest, rad);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\r\nexport function fromYRotation(out, rad) {\r\n  var s = Math.sin(rad);\r\n  var c = Math.cos(rad);\r\n\r\n  // Perform axis-specific matrix multiplication\r\n  out[0] = c;\r\n  out[1] = 0;\r\n  out[2] = -s;\r\n  out[3] = 0;\r\n  out[4] = 0;\r\n  out[5] = 1;\r\n  out[6] = 0;\r\n  out[7] = 0;\r\n  out[8] = s;\r\n  out[9] = 0;\r\n  out[10] = c;\r\n  out[11] = 0;\r\n  out[12] = 0;\r\n  out[13] = 0;\r\n  out[14] = 0;\r\n  out[15] = 1;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a matrix from the given angle around the Z axis\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.rotateZ(dest, dest, rad);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\r\nexport function fromZRotation(out, rad) {\r\n  var s = Math.sin(rad);\r\n  var c = Math.cos(rad);\r\n\r\n  // Perform axis-specific matrix multiplication\r\n  out[0] = c;\r\n  out[1] = s;\r\n  out[2] = 0;\r\n  out[3] = 0;\r\n  out[4] = -s;\r\n  out[5] = c;\r\n  out[6] = 0;\r\n  out[7] = 0;\r\n  out[8] = 0;\r\n  out[9] = 0;\r\n  out[10] = 1;\r\n  out[11] = 0;\r\n  out[12] = 0;\r\n  out[13] = 0;\r\n  out[14] = 0;\r\n  out[15] = 1;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a matrix from a quaternion rotation and vector translation\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.translate(dest, vec);\r\n *     let quatMat = mat4.create();\r\n *     quat4.toMat4(quat, quatMat);\r\n *     mat4.multiply(dest, quatMat);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {quat4} q Rotation quaternion\r\n * @param {vec3} v Translation vector\r\n * @returns {mat4} out\r\n */\r\nexport function fromRotationTranslation(out, q, v) {\r\n  // Quaternion math\r\n  var x = q[0],\r\n      y = q[1],\r\n      z = q[2],\r\n      w = q[3];\r\n  var x2 = x + x;\r\n  var y2 = y + y;\r\n  var z2 = z + z;\r\n\r\n  var xx = x * x2;\r\n  var xy = x * y2;\r\n  var xz = x * z2;\r\n  var yy = y * y2;\r\n  var yz = y * z2;\r\n  var zz = z * z2;\r\n  var wx = w * x2;\r\n  var wy = w * y2;\r\n  var wz = w * z2;\r\n\r\n  out[0] = 1 - (yy + zz);\r\n  out[1] = xy + wz;\r\n  out[2] = xz - wy;\r\n  out[3] = 0;\r\n  out[4] = xy - wz;\r\n  out[5] = 1 - (xx + zz);\r\n  out[6] = yz + wx;\r\n  out[7] = 0;\r\n  out[8] = xz + wy;\r\n  out[9] = yz - wx;\r\n  out[10] = 1 - (xx + yy);\r\n  out[11] = 0;\r\n  out[12] = v[0];\r\n  out[13] = v[1];\r\n  out[14] = v[2];\r\n  out[15] = 1;\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a new mat4 from a dual quat.\r\n *\r\n * @param {mat4} out Matrix\r\n * @param {quat2} a Dual Quaternion\r\n * @returns {mat4} mat4 receiving operation result\r\n */\r\nexport function fromQuat2(out, a) {\r\n  var translation = new glMatrix.ARRAY_TYPE(3);\r\n  var bx = -a[0],\r\n      by = -a[1],\r\n      bz = -a[2],\r\n      bw = a[3],\r\n      ax = a[4],\r\n      ay = a[5],\r\n      az = a[6],\r\n      aw = a[7];\r\n\r\n  var magnitude = bx * bx + by * by + bz * bz + bw * bw;\r\n  //Only scale if it makes sense\r\n  if (magnitude > 0) {\r\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;\r\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;\r\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;\r\n  } else {\r\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;\r\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;\r\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;\r\n  }\r\n  fromRotationTranslation(out, a, translation);\r\n  return out;\r\n}\r\n\r\n/**\r\n * Returns the translation vector component of a transformation\r\n *  matrix. If a matrix is built with fromRotationTranslation,\r\n *  the returned vector will be the same as the translation vector\r\n *  originally supplied.\r\n * @param  {vec3} out Vector to receive translation component\r\n * @param  {mat4} mat Matrix to be decomposed (input)\r\n * @return {vec3} out\r\n */\r\nexport function getTranslation(out, mat) {\r\n  out[0] = mat[12];\r\n  out[1] = mat[13];\r\n  out[2] = mat[14];\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Returns the scaling factor component of a transformation\r\n *  matrix. If a matrix is built with fromRotationTranslationScale\r\n *  with a normalized Quaternion paramter, the returned vector will be\r\n *  the same as the scaling vector\r\n *  originally supplied.\r\n * @param  {vec3} out Vector to receive scaling factor component\r\n * @param  {mat4} mat Matrix to be decomposed (input)\r\n * @return {vec3} out\r\n */\r\nexport function getScaling(out, mat) {\r\n  var m11 = mat[0];\r\n  var m12 = mat[1];\r\n  var m13 = mat[2];\r\n  var m21 = mat[4];\r\n  var m22 = mat[5];\r\n  var m23 = mat[6];\r\n  var m31 = mat[8];\r\n  var m32 = mat[9];\r\n  var m33 = mat[10];\r\n\r\n  out[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);\r\n  out[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);\r\n  out[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Returns a quaternion representing the rotational component\r\n *  of a transformation matrix. If a matrix is built with\r\n *  fromRotationTranslation, the returned quaternion will be the\r\n *  same as the quaternion originally supplied.\r\n * @param {quat} out Quaternion to receive the rotation component\r\n * @param {mat4} mat Matrix to be decomposed (input)\r\n * @return {quat} out\r\n */\r\nexport function getRotation(out, mat) {\r\n  // Algorithm taken from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\r\n  var trace = mat[0] + mat[5] + mat[10];\r\n  var S = 0;\r\n\r\n  if (trace > 0) {\r\n    S = Math.sqrt(trace + 1.0) * 2;\r\n    out[3] = 0.25 * S;\r\n    out[0] = (mat[6] - mat[9]) / S;\r\n    out[1] = (mat[8] - mat[2]) / S;\r\n    out[2] = (mat[1] - mat[4]) / S;\r\n  } else if (mat[0] > mat[5] && mat[0] > mat[10]) {\r\n    S = Math.sqrt(1.0 + mat[0] - mat[5] - mat[10]) * 2;\r\n    out[3] = (mat[6] - mat[9]) / S;\r\n    out[0] = 0.25 * S;\r\n    out[1] = (mat[1] + mat[4]) / S;\r\n    out[2] = (mat[8] + mat[2]) / S;\r\n  } else if (mat[5] > mat[10]) {\r\n    S = Math.sqrt(1.0 + mat[5] - mat[0] - mat[10]) * 2;\r\n    out[3] = (mat[8] - mat[2]) / S;\r\n    out[0] = (mat[1] + mat[4]) / S;\r\n    out[1] = 0.25 * S;\r\n    out[2] = (mat[6] + mat[9]) / S;\r\n  } else {\r\n    S = Math.sqrt(1.0 + mat[10] - mat[0] - mat[5]) * 2;\r\n    out[3] = (mat[1] - mat[4]) / S;\r\n    out[0] = (mat[8] + mat[2]) / S;\r\n    out[1] = (mat[6] + mat[9]) / S;\r\n    out[2] = 0.25 * S;\r\n  }\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a matrix from a quaternion rotation, vector translation and vector scale\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.translate(dest, vec);\r\n *     let quatMat = mat4.create();\r\n *     quat4.toMat4(quat, quatMat);\r\n *     mat4.multiply(dest, quatMat);\r\n *     mat4.scale(dest, scale)\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {quat4} q Rotation quaternion\r\n * @param {vec3} v Translation vector\r\n * @param {vec3} s Scaling vector\r\n * @returns {mat4} out\r\n */\r\nexport function fromRotationTranslationScale(out, q, v, s) {\r\n  // Quaternion math\r\n  var x = q[0],\r\n      y = q[1],\r\n      z = q[2],\r\n      w = q[3];\r\n  var x2 = x + x;\r\n  var y2 = y + y;\r\n  var z2 = z + z;\r\n\r\n  var xx = x * x2;\r\n  var xy = x * y2;\r\n  var xz = x * z2;\r\n  var yy = y * y2;\r\n  var yz = y * z2;\r\n  var zz = z * z2;\r\n  var wx = w * x2;\r\n  var wy = w * y2;\r\n  var wz = w * z2;\r\n  var sx = s[0];\r\n  var sy = s[1];\r\n  var sz = s[2];\r\n\r\n  out[0] = (1 - (yy + zz)) * sx;\r\n  out[1] = (xy + wz) * sx;\r\n  out[2] = (xz - wy) * sx;\r\n  out[3] = 0;\r\n  out[4] = (xy - wz) * sy;\r\n  out[5] = (1 - (xx + zz)) * sy;\r\n  out[6] = (yz + wx) * sy;\r\n  out[7] = 0;\r\n  out[8] = (xz + wy) * sz;\r\n  out[9] = (yz - wx) * sz;\r\n  out[10] = (1 - (xx + yy)) * sz;\r\n  out[11] = 0;\r\n  out[12] = v[0];\r\n  out[13] = v[1];\r\n  out[14] = v[2];\r\n  out[15] = 1;\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.translate(dest, vec);\r\n *     mat4.translate(dest, origin);\r\n *     let quatMat = mat4.create();\r\n *     quat4.toMat4(quat, quatMat);\r\n *     mat4.multiply(dest, quatMat);\r\n *     mat4.scale(dest, scale)\r\n *     mat4.translate(dest, negativeOrigin);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {quat4} q Rotation quaternion\r\n * @param {vec3} v Translation vector\r\n * @param {vec3} s Scaling vector\r\n * @param {vec3} o The origin vector around which to scale and rotate\r\n * @returns {mat4} out\r\n */\r\nexport function fromRotationTranslationScaleOrigin(out, q, v, s, o) {\r\n  // Quaternion math\r\n  var x = q[0],\r\n      y = q[1],\r\n      z = q[2],\r\n      w = q[3];\r\n  var x2 = x + x;\r\n  var y2 = y + y;\r\n  var z2 = z + z;\r\n\r\n  var xx = x * x2;\r\n  var xy = x * y2;\r\n  var xz = x * z2;\r\n  var yy = y * y2;\r\n  var yz = y * z2;\r\n  var zz = z * z2;\r\n  var wx = w * x2;\r\n  var wy = w * y2;\r\n  var wz = w * z2;\r\n\r\n  var sx = s[0];\r\n  var sy = s[1];\r\n  var sz = s[2];\r\n\r\n  var ox = o[0];\r\n  var oy = o[1];\r\n  var oz = o[2];\r\n\r\n  var out0 = (1 - (yy + zz)) * sx;\r\n  var out1 = (xy + wz) * sx;\r\n  var out2 = (xz - wy) * sx;\r\n  var out4 = (xy - wz) * sy;\r\n  var out5 = (1 - (xx + zz)) * sy;\r\n  var out6 = (yz + wx) * sy;\r\n  var out8 = (xz + wy) * sz;\r\n  var out9 = (yz - wx) * sz;\r\n  var out10 = (1 - (xx + yy)) * sz;\r\n\r\n  out[0] = out0;\r\n  out[1] = out1;\r\n  out[2] = out2;\r\n  out[3] = 0;\r\n  out[4] = out4;\r\n  out[5] = out5;\r\n  out[6] = out6;\r\n  out[7] = 0;\r\n  out[8] = out8;\r\n  out[9] = out9;\r\n  out[10] = out10;\r\n  out[11] = 0;\r\n  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);\r\n  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);\r\n  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);\r\n  out[15] = 1;\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Calculates a 4x4 matrix from the given quaternion\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {quat} q Quaternion to create matrix from\r\n *\r\n * @returns {mat4} out\r\n */\r\nexport function fromQuat(out, q) {\r\n  var x = q[0],\r\n      y = q[1],\r\n      z = q[2],\r\n      w = q[3];\r\n  var x2 = x + x;\r\n  var y2 = y + y;\r\n  var z2 = z + z;\r\n\r\n  var xx = x * x2;\r\n  var yx = y * x2;\r\n  var yy = y * y2;\r\n  var zx = z * x2;\r\n  var zy = z * y2;\r\n  var zz = z * z2;\r\n  var wx = w * x2;\r\n  var wy = w * y2;\r\n  var wz = w * z2;\r\n\r\n  out[0] = 1 - yy - zz;\r\n  out[1] = yx + wz;\r\n  out[2] = zx - wy;\r\n  out[3] = 0;\r\n\r\n  out[4] = yx - wz;\r\n  out[5] = 1 - xx - zz;\r\n  out[6] = zy + wx;\r\n  out[7] = 0;\r\n\r\n  out[8] = zx + wy;\r\n  out[9] = zy - wx;\r\n  out[10] = 1 - xx - yy;\r\n  out[11] = 0;\r\n\r\n  out[12] = 0;\r\n  out[13] = 0;\r\n  out[14] = 0;\r\n  out[15] = 1;\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Generates a frustum matrix with the given bounds\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {Number} left Left bound of the frustum\r\n * @param {Number} right Right bound of the frustum\r\n * @param {Number} bottom Bottom bound of the frustum\r\n * @param {Number} top Top bound of the frustum\r\n * @param {Number} near Near bound of the frustum\r\n * @param {Number} far Far bound of the frustum\r\n * @returns {mat4} out\r\n */\r\nexport function frustum(out, left, right, bottom, top, near, far) {\r\n  var rl = 1 / (right - left);\r\n  var tb = 1 / (top - bottom);\r\n  var nf = 1 / (near - far);\r\n  out[0] = near * 2 * rl;\r\n  out[1] = 0;\r\n  out[2] = 0;\r\n  out[3] = 0;\r\n  out[4] = 0;\r\n  out[5] = near * 2 * tb;\r\n  out[6] = 0;\r\n  out[7] = 0;\r\n  out[8] = (right + left) * rl;\r\n  out[9] = (top + bottom) * tb;\r\n  out[10] = (far + near) * nf;\r\n  out[11] = -1;\r\n  out[12] = 0;\r\n  out[13] = 0;\r\n  out[14] = far * near * 2 * nf;\r\n  out[15] = 0;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Generates a perspective projection matrix with the given bounds.\r\n * Passing null/undefined/no value for far will generate infinite projection matrix.\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {number} fovy Vertical field of view in radians\r\n * @param {number} aspect Aspect ratio. typically viewport width/height\r\n * @param {number} near Near bound of the frustum\r\n * @param {number} far Far bound of the frustum, can be null or Infinity\r\n * @returns {mat4} out\r\n */\r\nexport function perspective(out, fovy, aspect, near, far) {\r\n  var f = 1.0 / Math.tan(fovy / 2),\r\n      nf = void 0;\r\n  out[0] = f / aspect;\r\n  out[1] = 0;\r\n  out[2] = 0;\r\n  out[3] = 0;\r\n  out[4] = 0;\r\n  out[5] = f;\r\n  out[6] = 0;\r\n  out[7] = 0;\r\n  out[8] = 0;\r\n  out[9] = 0;\r\n  out[11] = -1;\r\n  out[12] = 0;\r\n  out[13] = 0;\r\n  out[15] = 0;\r\n  if (far != null && far !== Infinity) {\r\n    nf = 1 / (near - far);\r\n    out[10] = (far + near) * nf;\r\n    out[14] = 2 * far * near * nf;\r\n  } else {\r\n    out[10] = -1;\r\n    out[14] = -2 * near;\r\n  }\r\n  return out;\r\n}\r\n\r\n/**\r\n * Generates a perspective projection matrix with the given field of view.\r\n * This is primarily useful for generating projection matrices to be used\r\n * with the still experiemental WebVR API.\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees\r\n * @param {number} near Near bound of the frustum\r\n * @param {number} far Far bound of the frustum\r\n * @returns {mat4} out\r\n */\r\nexport function perspectiveFromFieldOfView(out, fov, near, far) {\r\n  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);\r\n  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);\r\n  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);\r\n  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);\r\n  var xScale = 2.0 / (leftTan + rightTan);\r\n  var yScale = 2.0 / (upTan + downTan);\r\n\r\n  out[0] = xScale;\r\n  out[1] = 0.0;\r\n  out[2] = 0.0;\r\n  out[3] = 0.0;\r\n  out[4] = 0.0;\r\n  out[5] = yScale;\r\n  out[6] = 0.0;\r\n  out[7] = 0.0;\r\n  out[8] = -((leftTan - rightTan) * xScale * 0.5);\r\n  out[9] = (upTan - downTan) * yScale * 0.5;\r\n  out[10] = far / (near - far);\r\n  out[11] = -1.0;\r\n  out[12] = 0.0;\r\n  out[13] = 0.0;\r\n  out[14] = far * near / (near - far);\r\n  out[15] = 0.0;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Generates a orthogonal projection matrix with the given bounds\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {number} left Left bound of the frustum\r\n * @param {number} right Right bound of the frustum\r\n * @param {number} bottom Bottom bound of the frustum\r\n * @param {number} top Top bound of the frustum\r\n * @param {number} near Near bound of the frustum\r\n * @param {number} far Far bound of the frustum\r\n * @returns {mat4} out\r\n */\r\nexport function ortho(out, left, right, bottom, top, near, far) {\r\n  var lr = 1 / (left - right);\r\n  var bt = 1 / (bottom - top);\r\n  var nf = 1 / (near - far);\r\n  out[0] = -2 * lr;\r\n  out[1] = 0;\r\n  out[2] = 0;\r\n  out[3] = 0;\r\n  out[4] = 0;\r\n  out[5] = -2 * bt;\r\n  out[6] = 0;\r\n  out[7] = 0;\r\n  out[8] = 0;\r\n  out[9] = 0;\r\n  out[10] = 2 * nf;\r\n  out[11] = 0;\r\n  out[12] = (left + right) * lr;\r\n  out[13] = (top + bottom) * bt;\r\n  out[14] = (far + near) * nf;\r\n  out[15] = 1;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Generates a look-at matrix with the given eye position, focal point, and up axis.\r\n * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {vec3} eye Position of the viewer\r\n * @param {vec3} center Point the viewer is looking at\r\n * @param {vec3} up vec3 pointing up\r\n * @returns {mat4} out\r\n */\r\nexport function lookAt(out, eye, center, up) {\r\n  var x0 = void 0,\r\n      x1 = void 0,\r\n      x2 = void 0,\r\n      y0 = void 0,\r\n      y1 = void 0,\r\n      y2 = void 0,\r\n      z0 = void 0,\r\n      z1 = void 0,\r\n      z2 = void 0,\r\n      len = void 0;\r\n  var eyex = eye[0];\r\n  var eyey = eye[1];\r\n  var eyez = eye[2];\r\n  var upx = up[0];\r\n  var upy = up[1];\r\n  var upz = up[2];\r\n  var centerx = center[0];\r\n  var centery = center[1];\r\n  var centerz = center[2];\r\n\r\n  if (Math.abs(eyex - centerx) < glMatrix.EPSILON && Math.abs(eyey - centery) < glMatrix.EPSILON && Math.abs(eyez - centerz) < glMatrix.EPSILON) {\r\n    return identity(out);\r\n  }\r\n\r\n  z0 = eyex - centerx;\r\n  z1 = eyey - centery;\r\n  z2 = eyez - centerz;\r\n\r\n  len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);\r\n  z0 *= len;\r\n  z1 *= len;\r\n  z2 *= len;\r\n\r\n  x0 = upy * z2 - upz * z1;\r\n  x1 = upz * z0 - upx * z2;\r\n  x2 = upx * z1 - upy * z0;\r\n  len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);\r\n  if (!len) {\r\n    x0 = 0;\r\n    x1 = 0;\r\n    x2 = 0;\r\n  } else {\r\n    len = 1 / len;\r\n    x0 *= len;\r\n    x1 *= len;\r\n    x2 *= len;\r\n  }\r\n\r\n  y0 = z1 * x2 - z2 * x1;\r\n  y1 = z2 * x0 - z0 * x2;\r\n  y2 = z0 * x1 - z1 * x0;\r\n\r\n  len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);\r\n  if (!len) {\r\n    y0 = 0;\r\n    y1 = 0;\r\n    y2 = 0;\r\n  } else {\r\n    len = 1 / len;\r\n    y0 *= len;\r\n    y1 *= len;\r\n    y2 *= len;\r\n  }\r\n\r\n  out[0] = x0;\r\n  out[1] = y0;\r\n  out[2] = z0;\r\n  out[3] = 0;\r\n  out[4] = x1;\r\n  out[5] = y1;\r\n  out[6] = z1;\r\n  out[7] = 0;\r\n  out[8] = x2;\r\n  out[9] = y2;\r\n  out[10] = z2;\r\n  out[11] = 0;\r\n  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);\r\n  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);\r\n  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);\r\n  out[15] = 1;\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Generates a matrix that makes something look at something else.\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {vec3} eye Position of the viewer\r\n * @param {vec3} center Point the viewer is looking at\r\n * @param {vec3} up vec3 pointing up\r\n * @returns {mat4} out\r\n */\r\nexport function targetTo(out, eye, target, up) {\r\n  var eyex = eye[0],\r\n      eyey = eye[1],\r\n      eyez = eye[2],\r\n      upx = up[0],\r\n      upy = up[1],\r\n      upz = up[2];\r\n\r\n  var z0 = eyex - target[0],\r\n      z1 = eyey - target[1],\r\n      z2 = eyez - target[2];\r\n\r\n  var len = z0 * z0 + z1 * z1 + z2 * z2;\r\n  if (len > 0) {\r\n    len = 1 / Math.sqrt(len);\r\n    z0 *= len;\r\n    z1 *= len;\r\n    z2 *= len;\r\n  }\r\n\r\n  var x0 = upy * z2 - upz * z1,\r\n      x1 = upz * z0 - upx * z2,\r\n      x2 = upx * z1 - upy * z0;\r\n\r\n  len = x0 * x0 + x1 * x1 + x2 * x2;\r\n  if (len > 0) {\r\n    len = 1 / Math.sqrt(len);\r\n    x0 *= len;\r\n    x1 *= len;\r\n    x2 *= len;\r\n  }\r\n\r\n  out[0] = x0;\r\n  out[1] = x1;\r\n  out[2] = x2;\r\n  out[3] = 0;\r\n  out[4] = z1 * x2 - z2 * x1;\r\n  out[5] = z2 * x0 - z0 * x2;\r\n  out[6] = z0 * x1 - z1 * x0;\r\n  out[7] = 0;\r\n  out[8] = z0;\r\n  out[9] = z1;\r\n  out[10] = z2;\r\n  out[11] = 0;\r\n  out[12] = eyex;\r\n  out[13] = eyey;\r\n  out[14] = eyez;\r\n  out[15] = 1;\r\n  return out;\r\n};\r\n\r\n/**\r\n * Returns a string representation of a mat4\r\n *\r\n * @param {mat4} a matrix to represent as a string\r\n * @returns {String} string representation of the matrix\r\n */\r\nexport function str(a) {\r\n  return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';\r\n}\r\n\r\n/**\r\n * Returns Frobenius norm of a mat4\r\n *\r\n * @param {mat4} a the matrix to calculate Frobenius norm of\r\n * @returns {Number} Frobenius norm\r\n */\r\nexport function frob(a) {\r\n  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2));\r\n}\r\n\r\n/**\r\n * Adds two mat4's\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the first operand\r\n * @param {mat4} b the second operand\r\n * @returns {mat4} out\r\n */\r\nexport function add(out, a, b) {\r\n  out[0] = a[0] + b[0];\r\n  out[1] = a[1] + b[1];\r\n  out[2] = a[2] + b[2];\r\n  out[3] = a[3] + b[3];\r\n  out[4] = a[4] + b[4];\r\n  out[5] = a[5] + b[5];\r\n  out[6] = a[6] + b[6];\r\n  out[7] = a[7] + b[7];\r\n  out[8] = a[8] + b[8];\r\n  out[9] = a[9] + b[9];\r\n  out[10] = a[10] + b[10];\r\n  out[11] = a[11] + b[11];\r\n  out[12] = a[12] + b[12];\r\n  out[13] = a[13] + b[13];\r\n  out[14] = a[14] + b[14];\r\n  out[15] = a[15] + b[15];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Subtracts matrix b from matrix a\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the first operand\r\n * @param {mat4} b the second operand\r\n * @returns {mat4} out\r\n */\r\nexport function subtract(out, a, b) {\r\n  out[0] = a[0] - b[0];\r\n  out[1] = a[1] - b[1];\r\n  out[2] = a[2] - b[2];\r\n  out[3] = a[3] - b[3];\r\n  out[4] = a[4] - b[4];\r\n  out[5] = a[5] - b[5];\r\n  out[6] = a[6] - b[6];\r\n  out[7] = a[7] - b[7];\r\n  out[8] = a[8] - b[8];\r\n  out[9] = a[9] - b[9];\r\n  out[10] = a[10] - b[10];\r\n  out[11] = a[11] - b[11];\r\n  out[12] = a[12] - b[12];\r\n  out[13] = a[13] - b[13];\r\n  out[14] = a[14] - b[14];\r\n  out[15] = a[15] - b[15];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Multiply each element of the matrix by a scalar.\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the matrix to scale\r\n * @param {Number} b amount to scale the matrix's elements by\r\n * @returns {mat4} out\r\n */\r\nexport function multiplyScalar(out, a, b) {\r\n  out[0] = a[0] * b;\r\n  out[1] = a[1] * b;\r\n  out[2] = a[2] * b;\r\n  out[3] = a[3] * b;\r\n  out[4] = a[4] * b;\r\n  out[5] = a[5] * b;\r\n  out[6] = a[6] * b;\r\n  out[7] = a[7] * b;\r\n  out[8] = a[8] * b;\r\n  out[9] = a[9] * b;\r\n  out[10] = a[10] * b;\r\n  out[11] = a[11] * b;\r\n  out[12] = a[12] * b;\r\n  out[13] = a[13] * b;\r\n  out[14] = a[14] * b;\r\n  out[15] = a[15] * b;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Adds two mat4's after multiplying each element of the second operand by a scalar value.\r\n *\r\n * @param {mat4} out the receiving vector\r\n * @param {mat4} a the first operand\r\n * @param {mat4} b the second operand\r\n * @param {Number} scale the amount to scale b's elements by before adding\r\n * @returns {mat4} out\r\n */\r\nexport function multiplyScalarAndAdd(out, a, b, scale) {\r\n  out[0] = a[0] + b[0] * scale;\r\n  out[1] = a[1] + b[1] * scale;\r\n  out[2] = a[2] + b[2] * scale;\r\n  out[3] = a[3] + b[3] * scale;\r\n  out[4] = a[4] + b[4] * scale;\r\n  out[5] = a[5] + b[5] * scale;\r\n  out[6] = a[6] + b[6] * scale;\r\n  out[7] = a[7] + b[7] * scale;\r\n  out[8] = a[8] + b[8] * scale;\r\n  out[9] = a[9] + b[9] * scale;\r\n  out[10] = a[10] + b[10] * scale;\r\n  out[11] = a[11] + b[11] * scale;\r\n  out[12] = a[12] + b[12] * scale;\r\n  out[13] = a[13] + b[13] * scale;\r\n  out[14] = a[14] + b[14] * scale;\r\n  out[15] = a[15] + b[15] * scale;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {mat4} a The first matrix.\r\n * @param {mat4} b The second matrix.\r\n * @returns {Boolean} True if the matrices are equal, false otherwise.\r\n */\r\nexport function exactEquals(a, b) {\r\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];\r\n}\r\n\r\n/**\r\n * Returns whether or not the matrices have approximately the same elements in the same position.\r\n *\r\n * @param {mat4} a The first matrix.\r\n * @param {mat4} b The second matrix.\r\n * @returns {Boolean} True if the matrices are equal, false otherwise.\r\n */\r\nexport function equals(a, b) {\r\n  var a0 = a[0],\r\n      a1 = a[1],\r\n      a2 = a[2],\r\n      a3 = a[3];\r\n  var a4 = a[4],\r\n      a5 = a[5],\r\n      a6 = a[6],\r\n      a7 = a[7];\r\n  var a8 = a[8],\r\n      a9 = a[9],\r\n      a10 = a[10],\r\n      a11 = a[11];\r\n  var a12 = a[12],\r\n      a13 = a[13],\r\n      a14 = a[14],\r\n      a15 = a[15];\r\n\r\n  var b0 = b[0],\r\n      b1 = b[1],\r\n      b2 = b[2],\r\n      b3 = b[3];\r\n  var b4 = b[4],\r\n      b5 = b[5],\r\n      b6 = b[6],\r\n      b7 = b[7];\r\n  var b8 = b[8],\r\n      b9 = b[9],\r\n      b10 = b[10],\r\n      b11 = b[11];\r\n  var b12 = b[12],\r\n      b13 = b[13],\r\n      b14 = b[14],\r\n      b15 = b[15];\r\n\r\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));\r\n}\r\n\r\n/**\r\n * Alias for {@link mat4.multiply}\r\n * @function\r\n */\r\nexport var mul = multiply;\r\n\r\n/**\r\n * Alias for {@link mat4.subtract}\r\n * @function\r\n */\r\nexport var sub = subtract;","\nimport refProperties from './util/ref_properties';\n\nfunction stringify(obj) {\n    const type = typeof obj;\n    if (type === 'number' || type === 'boolean' || type === 'string' || obj === undefined || obj === null)\n        return JSON.stringify(obj);\n\n    if (Array.isArray(obj)) {\n        let str = '[';\n        for (const val of obj) {\n            str += `${stringify(val)},`;\n        }\n        return `${str}]`;\n    }\n\n    const keys = Object.keys(obj).sort();\n\n    let str = '{';\n    for (let i = 0; i < keys.length; i++) {\n        str += `${JSON.stringify(keys[i])}:${stringify(obj[keys[i]])},`;\n    }\n    return `${str}}`;\n}\n\nfunction getKey(layer) {\n    let key = '';\n    for (const k of refProperties) {\n        key += `/${stringify(layer[k])}`;\n    }\n    return key;\n}\n\nexport default groupByLayout;\n\n/**\n * Given an array of layers, return an array of arrays of layers where all\n * layers in each group have identical layout-affecting properties. These\n * are the properties that were formerly used by explicit `ref` mechanism\n * for layers: 'type', 'source', 'source-layer', 'minzoom', 'maxzoom',\n * 'filter', and 'layout'.\n *\n * The input is not modified. The output layers are references to the\n * input layers.\n *\n * @private\n * @param {Array<Layer>} layers\n * @returns {Array<Array<Layer>>}\n */\nfunction groupByLayout(layers) {\n    const groups = {};\n\n    for (let i = 0; i < layers.length; i++) {\n        const k = getKey(layers[i]);\n        let group = groups[k];\n        if (!group) {\n            group = groups[k] = [];\n        }\n        group.push(layers[i]);\n    }\n\n    const result = [];\n\n    for (const k in groups) {\n        result.push(groups[k]);\n    }\n\n    return result;\n}\n","// @flow\n\nimport StyleLayer from './style_layer';\nimport createStyleLayer from './create_style_layer';\n\nimport { values } from '../util/util';\nimport featureFilter from '../style-spec/feature_filter';\nimport groupByLayout from '../style-spec/group_by_layout';\n\nimport type {TypedStyleLayer} from './style_layer/typed_style_layer';\nimport type {LayerSpecification} from '../style-spec/types';\n\nexport type LayerConfigs = { [string]: LayerSpecification };\nexport type Family<Layer: TypedStyleLayer> = Array<Layer>;\n\nclass StyleLayerIndex {\n    familiesBySource: { [source: string]: { [sourceLayer: string]: Array<Family<*>> } };\n\n    _layerConfigs: LayerConfigs;\n    _layers: { [string]: StyleLayer };\n\n    constructor(layerConfigs: ?Array<LayerSpecification>) {\n        if (layerConfigs) {\n            this.replace(layerConfigs);\n        }\n    }\n\n    replace(layerConfigs: Array<LayerSpecification>) {\n        this._layerConfigs = {};\n        this._layers = {};\n        this.update(layerConfigs, []);\n    }\n\n    update(layerConfigs: Array<LayerSpecification>, removedIds: Array<string>) {\n        for (const layerConfig of layerConfigs) {\n            this._layerConfigs[layerConfig.id] = layerConfig;\n\n            const layer = this._layers[layerConfig.id] = createStyleLayer(layerConfig);\n            layer._featureFilter = featureFilter(layer.filter);\n        }\n        for (const id of removedIds) {\n            delete this._layerConfigs[id];\n            delete this._layers[id];\n        }\n\n        this.familiesBySource = {};\n\n        const groups = groupByLayout(values(this._layerConfigs));\n\n        for (const layerConfigs of groups) {\n            const layers = layerConfigs.map((layerConfig) => this._layers[layerConfig.id]);\n\n            const layer = layers[0];\n            if (layer.visibility === 'none') {\n                continue;\n            }\n\n            const sourceId = layer.source || '';\n            let sourceGroup = this.familiesBySource[sourceId];\n            if (!sourceGroup) {\n                sourceGroup = this.familiesBySource[sourceId] = {};\n            }\n\n            const sourceLayerId = layer.sourceLayer || '_geojsonTileLayer';\n            let sourceLayerFamilies = sourceGroup[sourceLayerId];\n            if (!sourceLayerFamilies) {\n                sourceLayerFamilies = sourceGroup[sourceLayerId] = [];\n            }\n\n            sourceLayerFamilies.push(layers);\n        }\n    }\n}\n\nexport default StyleLayerIndex;\n","// @flow\n\nexport default checkMaxAngle;\n\nimport type Point from '@mapbox/point-geometry';\nimport type Anchor from './anchor';\n\n/**\n * Labels placed around really sharp angles aren't readable. Check if any\n * part of the potential label has a combined angle that is too big.\n *\n * @param line\n * @param anchor The point on the line around which the label is anchored.\n * @param labelLength The length of the label in geometry units.\n * @param windowSize The check fails if the combined angles within a part of the line that is `windowSize` long is too big.\n * @param maxAngle The maximum combined angle that any window along the label is allowed to have.\n *\n * @returns {boolean} whether the label should be placed\n * @private\n */\nfunction checkMaxAngle(line: Array<Point>, anchor: Anchor, labelLength: number, windowSize: number, maxAngle: number) {\n\n    // horizontal labels always pass\n    if (anchor.segment === undefined) return true;\n\n    let p = anchor;\n    let index = anchor.segment + 1;\n    let anchorDistance = 0;\n\n    // move backwards along the line to the first segment the label appears on\n    while (anchorDistance > -labelLength / 2) {\n        index--;\n\n        // there isn't enough room for the label after the beginning of the line\n        if (index < 0) return false;\n\n        anchorDistance -= line[index].dist(p);\n        p = line[index];\n    }\n\n    anchorDistance += line[index].dist(line[index + 1]);\n    index++;\n\n    // store recent corners and their total angle difference\n    const recentCorners = [];\n    let recentAngleDelta = 0;\n\n    // move forwards by the length of the label and check angles along the way\n    while (anchorDistance < labelLength / 2) {\n        const prev = line[index - 1];\n        const current = line[index];\n        const next = line[index + 1];\n\n        // there isn't enough room for the label before the end of the line\n        if (!next) return false;\n\n        let angleDelta = prev.angleTo(current) - current.angleTo(next);\n        // restrict angle to -pi..pi range\n        angleDelta = Math.abs(((angleDelta + 3 * Math.PI) % (Math.PI * 2)) - Math.PI);\n\n        recentCorners.push({\n            distance: anchorDistance,\n            angleDelta\n        });\n        recentAngleDelta += angleDelta;\n\n        // remove corners that are far enough away from the list of recent anchors\n        while (anchorDistance - recentCorners[0].distance > windowSize) {\n            recentAngleDelta -= recentCorners.shift().angleDelta;\n        }\n\n        // the sum of angles within the window area exceeds the maximum allowed value. check fails.\n        if (recentAngleDelta > maxAngle) return false;\n\n        index++;\n        anchorDistance += current.dist(next);\n    }\n\n    // no part of the line had an angle greater than the maximum allowed. check passes.\n    return true;\n}\n","// @flow\n\nimport { number as interpolate } from '../style-spec/util/interpolate';\n\nimport Anchor from '../symbol/anchor';\nimport checkMaxAngle from './check_max_angle';\n\nimport type Point from '@mapbox/point-geometry';\nimport type {Shaping, PositionedIcon} from './shaping';\n\nexport { getAnchors, getCenterAnchor };\n\nfunction getLineLength(line: Array<Point>): number {\n    let lineLength = 0;\n    for (let k = 0; k < line.length - 1; k++) {\n        lineLength += line[k].dist(line[k + 1]);\n    }\n    return lineLength;\n}\n\nfunction getAngleWindowSize(shapedText: ?Shaping,\n                            glyphSize: number,\n                            boxScale: number): number {\n    return shapedText ?\n        3 / 5 * glyphSize * boxScale :\n        0;\n}\n\nfunction getShapedLabelLength(shapedText: ?Shaping, shapedIcon: ?PositionedIcon): number {\n    return Math.max(\n        shapedText ? shapedText.right - shapedText.left : 0,\n        shapedIcon ? shapedIcon.right - shapedIcon.left : 0);\n}\n\nfunction getCenterAnchor(line: Array<Point>,\n                         maxAngle: number,\n                         shapedText: ?Shaping,\n                         shapedIcon: ?PositionedIcon,\n                         glyphSize: number,\n                         boxScale: number) {\n    const angleWindowSize = getAngleWindowSize(shapedText, glyphSize, boxScale);\n    const labelLength = getShapedLabelLength(shapedText, shapedIcon) * boxScale;\n\n    let prevDistance = 0;\n    const centerDistance = getLineLength(line) / 2;\n\n    for (let i = 0; i < line.length - 1; i++) {\n\n        const a = line[i],\n            b = line[i + 1];\n\n        const segmentDistance = a.dist(b);\n\n        if (prevDistance + segmentDistance > centerDistance) {\n            // The center is on this segment\n            const t = (centerDistance - prevDistance) / segmentDistance,\n                x = interpolate(a.x, b.x, t),\n                y = interpolate(a.y, b.y, t);\n\n            const anchor = new Anchor(x, y, b.angleTo(a), i);\n            anchor._round();\n            if (!angleWindowSize || checkMaxAngle(line, anchor, labelLength, angleWindowSize, maxAngle)) {\n                return anchor;\n            } else {\n                return;\n            }\n        }\n\n        prevDistance += segmentDistance;\n    }\n}\n\nfunction getAnchors(line: Array<Point>,\n                    spacing: number,\n                    maxAngle: number,\n                    shapedText: ?Shaping,\n                    shapedIcon: ?PositionedIcon,\n                    glyphSize: number,\n                    boxScale: number,\n                    overscaling: number,\n                    tileExtent: number) {\n\n    // Resample a line to get anchor points for labels and check that each\n    // potential label passes text-max-angle check and has enough froom to fit\n    // on the line.\n\n    const angleWindowSize = getAngleWindowSize(shapedText, glyphSize, boxScale);\n    const shapedLabelLength = getShapedLabelLength(shapedText, shapedIcon);\n    const labelLength = shapedLabelLength * boxScale;\n\n    // Is the line continued from outside the tile boundary?\n    const isLineContinued = line[0].x === 0 || line[0].x === tileExtent || line[0].y === 0 || line[0].y === tileExtent;\n\n    // Is the label long, relative to the spacing?\n    // If so, adjust the spacing so there is always a minimum space of `spacing / 4` between label edges.\n    if (spacing - labelLength < spacing / 4) {\n        spacing = labelLength + spacing / 4;\n    }\n\n    // Offset the first anchor by:\n    // Either half the label length plus a fixed extra offset if the line is not continued\n    // Or half the spacing if the line is continued.\n\n    // For non-continued lines, add a bit of fixed extra offset to avoid collisions at T intersections.\n    const fixedExtraOffset = glyphSize * 2;\n\n    const offset = !isLineContinued ?\n        ((shapedLabelLength / 2 + fixedExtraOffset) * boxScale * overscaling) % spacing :\n        (spacing / 2 * overscaling) % spacing;\n\n    return resample(line, offset, spacing, angleWindowSize, maxAngle, labelLength, isLineContinued, false, tileExtent);\n}\n\n\nfunction resample(line, offset, spacing, angleWindowSize, maxAngle, labelLength, isLineContinued, placeAtMiddle, tileExtent) {\n\n    const halfLabelLength = labelLength / 2;\n    const lineLength = getLineLength(line);\n\n    let distance = 0,\n        markedDistance = offset - spacing;\n\n    let anchors = [];\n\n    for (let i = 0; i < line.length - 1; i++) {\n\n        const a = line[i],\n            b = line[i + 1];\n\n        const segmentDist = a.dist(b),\n            angle = b.angleTo(a);\n\n        while (markedDistance + spacing < distance + segmentDist) {\n            markedDistance += spacing;\n\n            const t = (markedDistance - distance) / segmentDist,\n                x = interpolate(a.x, b.x, t),\n                y = interpolate(a.y, b.y, t);\n\n            // Check that the point is within the tile boundaries and that\n            // the label would fit before the beginning and end of the line\n            // if placed at this point.\n            if (x >= 0 && x < tileExtent && y >= 0 && y < tileExtent &&\n                    markedDistance - halfLabelLength >= 0 &&\n                    markedDistance + halfLabelLength <= lineLength) {\n                const anchor = new Anchor(x, y, angle, i);\n                anchor._round();\n\n                if (!angleWindowSize || checkMaxAngle(line, anchor, labelLength, angleWindowSize, maxAngle)) {\n                    anchors.push(anchor);\n                }\n            }\n        }\n\n        distance += segmentDist;\n    }\n\n    if (!placeAtMiddle && !anchors.length && !isLineContinued) {\n        // The first attempt at finding anchors at which labels can be placed failed.\n        // Try again, but this time just try placing one anchor at the middle of the line.\n        // This has the most effect for short lines in overscaled tiles, since the\n        // initial offset used in overscaled tiles is calculated to align labels with positions in\n        // parent tiles instead of placing the label as close to the beginning as possible.\n        anchors = resample(line, distance / 2, spacing, angleWindowSize, maxAngle, labelLength, isLineContinued, true, tileExtent);\n    }\n\n    return anchors;\n}\n","// @flow\n\nimport type {CollisionBoxArray} from '../data/array_types';\nimport Point from '@mapbox/point-geometry';\nimport type Anchor from './anchor';\n\n/**\n * A CollisionFeature represents the area of the tile covered by a single label.\n * It is used with CollisionIndex to check if the label overlaps with any\n * previous labels. A CollisionFeature is mostly just a set of CollisionBox\n * objects.\n *\n * @private\n */\nclass CollisionFeature {\n    boxStartIndex: number;\n    boxEndIndex: number;\n\n    /**\n     * Create a CollisionFeature, adding its collision box data to the given collisionBoxArray in the process.\n     *\n     * @param line The geometry the label is placed on.\n     * @param anchor The point along the line around which the label is anchored.\n     * @param shaped The text or icon shaping results.\n     * @param boxScale A magic number used to convert from glyph metrics units to geometry units.\n     * @param padding The amount of padding to add around the label edges.\n     * @param alignLine Whether the label is aligned with the line or the viewport.\n     */\n    constructor(collisionBoxArray: CollisionBoxArray,\n                line: Array<Point>,\n                anchor: Anchor,\n                featureIndex: number,\n                sourceLayerIndex: number,\n                bucketIndex: number,\n                shaped: Object,\n                boxScale: number,\n                padding: number,\n                alignLine: boolean,\n                overscaling: number,\n                rotate: number) {\n        let y1 = shaped.top * boxScale - padding;\n        let y2 = shaped.bottom * boxScale + padding;\n        let x1 = shaped.left * boxScale - padding;\n        let x2 = shaped.right * boxScale + padding;\n\n        this.boxStartIndex = collisionBoxArray.length;\n\n        if (alignLine) {\n\n            let height = y2 - y1;\n            const length = x2 - x1;\n\n            if (height > 0) {\n                // set minimum box height to avoid very many small labels\n                height = Math.max(10 * boxScale, height);\n\n                this._addLineCollisionCircles(collisionBoxArray, line, anchor, (anchor.segment: any), length, height, featureIndex, sourceLayerIndex, bucketIndex, overscaling);\n            }\n\n        } else {\n            if (rotate) {\n                // Account for *-rotate in point collision boxes\n                // See https://github.com/mapbox/mapbox-gl-js/issues/6075\n                // Doesn't account for icon-text-fit\n\n                const tl = new Point(x1, y1);\n                const tr = new Point(x2, y1);\n                const bl = new Point(x1, y2);\n                const br = new Point(x2, y2);\n\n                const rotateRadians = rotate * Math.PI / 180;\n\n                tl._rotate(rotateRadians);\n                tr._rotate(rotateRadians);\n                bl._rotate(rotateRadians);\n                br._rotate(rotateRadians);\n\n                // Collision features require an \"on-axis\" geometry,\n                // so take the envelope of the rotated geometry\n                // (may be quite large for wide labels rotated 45 degrees)\n                x1 = Math.min(tl.x, tr.x, bl.x, br.x);\n                x2 = Math.max(tl.x, tr.x, bl.x, br.x);\n                y1 = Math.min(tl.y, tr.y, bl.y, br.y);\n                y2 = Math.max(tl.y, tr.y, bl.y, br.y);\n            }\n            collisionBoxArray.emplaceBack(anchor.x, anchor.y, x1, y1, x2, y2, featureIndex, sourceLayerIndex, bucketIndex,\n                0, 0);\n        }\n\n        this.boxEndIndex = collisionBoxArray.length;\n    }\n\n    /**\n     * Create a set of CollisionBox objects for a line.\n     *\n     * @param labelLength The length of the label in geometry units.\n     * @param anchor The point along the line around which the label is anchored.\n     * @param boxSize The size of the collision boxes that will be created.\n     * @private\n     */\n    _addLineCollisionCircles(collisionBoxArray: CollisionBoxArray,\n                           line: Array<Point>,\n                           anchor: Anchor,\n                           segment: number,\n                           labelLength: number,\n                           boxSize: number,\n                           featureIndex: number,\n                           sourceLayerIndex: number,\n                           bucketIndex: number,\n                           overscaling: number) {\n        const step = boxSize / 2;\n        const nBoxes = Math.floor(labelLength / step) || 1;\n        // We calculate line collision circles out to 300% of what would normally be our\n        // max size, to allow collision detection to work on labels that expand as\n        // they move into the distance\n        // Vertically oriented labels in the distant field can extend past this padding\n        // This is a noticeable problem in overscaled tiles where the pitch 0-based\n        // symbol spacing will put labels very close together in a pitched map.\n        // To reduce the cost of adding extra collision circles, we slowly increase\n        // them for overscaled tiles.\n        const overscalingPaddingFactor = 1 + .4 * Math.log(overscaling) / Math.LN2;\n        const nPitchPaddingBoxes = Math.floor(nBoxes * overscalingPaddingFactor / 2);\n\n        // offset the center of the first box by half a box so that the edge of the\n        // box is at the edge of the label.\n        const firstBoxOffset = -boxSize / 2;\n\n        let p = anchor;\n        let index = segment + 1;\n        let anchorDistance = firstBoxOffset;\n        const labelStartDistance = -labelLength / 2;\n        const paddingStartDistance = labelStartDistance - labelLength / 4;\n        // move backwards along the line to the first segment the label appears on\n        do {\n            index--;\n\n            if (index < 0) {\n                if (anchorDistance > labelStartDistance) {\n                    // there isn't enough room for the label after the beginning of the line\n                    // checkMaxAngle should have already caught this\n                    return;\n                } else {\n                    // The line doesn't extend far enough back for all of our padding,\n                    // but we got far enough to show the label under most conditions.\n                    index = 0;\n                    break;\n                }\n            } else {\n                anchorDistance -= line[index].dist(p);\n                p = line[index];\n            }\n        } while (anchorDistance > paddingStartDistance);\n\n        let segmentLength = line[index].dist(line[index + 1]);\n\n        for (let i = -nPitchPaddingBoxes; i < nBoxes + nPitchPaddingBoxes; i++) {\n\n            // the distance the box will be from the anchor\n            const boxOffset = i * step;\n            let boxDistanceToAnchor = labelStartDistance + boxOffset;\n\n            // make the distance between pitch padding boxes bigger\n            if (boxOffset < 0) boxDistanceToAnchor += boxOffset;\n            if (boxOffset > labelLength) boxDistanceToAnchor += boxOffset - labelLength;\n\n            if (boxDistanceToAnchor < anchorDistance) {\n                // The line doesn't extend far enough back for this box, skip it\n                // (This could allow for line collisions on distant tiles)\n                continue;\n            }\n\n            // the box is not on the current segment. Move to the next segment.\n            while (anchorDistance + segmentLength < boxDistanceToAnchor) {\n                anchorDistance += segmentLength;\n                index++;\n\n                // There isn't enough room before the end of the line.\n                if (index + 1 >= line.length) {\n                    return;\n                }\n\n                segmentLength = line[index].dist(line[index + 1]);\n            }\n\n            // the distance the box will be from the beginning of the segment\n            const segmentBoxDistance = boxDistanceToAnchor - anchorDistance;\n\n            const p0 = line[index];\n            const p1 = line[index + 1];\n            const boxAnchorPoint = p1.sub(p0)._unit()._mult(segmentBoxDistance)._add(p0)._round();\n\n            // If the box is within boxSize of the anchor, force the box to be used\n            // (so even 0-width labels use at least one box)\n            // Otherwise, the .8 multiplication gives us a little bit of conservative\n            // padding in choosing which boxes to use (see CollisionIndex#placedCollisionCircles)\n            const paddedAnchorDistance = Math.abs(boxDistanceToAnchor - firstBoxOffset) < step ?\n                0 :\n                (boxDistanceToAnchor - firstBoxOffset) * 0.8;\n\n            collisionBoxArray.emplaceBack(boxAnchorPoint.x, boxAnchorPoint.y,\n                -boxSize / 2, -boxSize / 2, boxSize / 2, boxSize / 2,\n                featureIndex, sourceLayerIndex, bucketIndex,\n                boxSize / 2, paddedAnchorDistance);\n        }\n    }\n}\n\nexport default CollisionFeature;\n","'use strict';\n\nmodule.exports = TinyQueue;\nmodule.exports.default = TinyQueue;\n\nfunction TinyQueue(data, compare) {\n    if (!(this instanceof TinyQueue)) return new TinyQueue(data, compare);\n\n    this.data = data || [];\n    this.length = this.data.length;\n    this.compare = compare || defaultCompare;\n\n    if (this.length > 0) {\n        for (var i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);\n    }\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\nTinyQueue.prototype = {\n\n    push: function (item) {\n        this.data.push(item);\n        this.length++;\n        this._up(this.length - 1);\n    },\n\n    pop: function () {\n        if (this.length === 0) return undefined;\n\n        var top = this.data[0];\n        this.length--;\n\n        if (this.length > 0) {\n            this.data[0] = this.data[this.length];\n            this._down(0);\n        }\n        this.data.pop();\n\n        return top;\n    },\n\n    peek: function () {\n        return this.data[0];\n    },\n\n    _up: function (pos) {\n        var data = this.data;\n        var compare = this.compare;\n        var item = data[pos];\n\n        while (pos > 0) {\n            var parent = (pos - 1) >> 1;\n            var current = data[parent];\n            if (compare(item, current) >= 0) break;\n            data[pos] = current;\n            pos = parent;\n        }\n\n        data[pos] = item;\n    },\n\n    _down: function (pos) {\n        var data = this.data;\n        var compare = this.compare;\n        var halfLength = this.length >> 1;\n        var item = data[pos];\n\n        while (pos < halfLength) {\n            var left = (pos << 1) + 1;\n            var right = left + 1;\n            var best = data[left];\n\n            if (right < this.length && compare(data[right], best) < 0) {\n                left = right;\n                best = data[right];\n            }\n            if (compare(best, item) >= 0) break;\n\n            data[pos] = best;\n            pos = left;\n        }\n\n        data[pos] = item;\n    }\n};\n","// @flow\n\nimport Queue from 'tinyqueue';\n\nimport Point from '@mapbox/point-geometry';\nimport { distToSegmentSquared } from './intersection_tests';\n\n/**\n * Finds an approximation of a polygon's Pole Of Inaccessibiliy https://en.wikipedia.org/wiki/Pole_of_inaccessibility\n * This is a copy of http://github.com/mapbox/polylabel adapted to use Points\n *\n * @param polygonRings first item in array is the outer ring followed optionally by the list of holes, should be an element of the result of util/classify_rings\n * @param precision Specified in input coordinate units. If 0 returns after first run, if > 0 repeatedly narrows the search space until the radius of the area searched for the best pole is less than precision\n * @param debug Print some statistics to the console during execution\n * @returns Pole of Inaccessibiliy.\n * @private\n */\nexport default function (polygonRings: Array<Array<Point>>, precision?: number = 1, debug?: boolean = false): Point {\n    // find the bounding box of the outer ring\n    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;\n    const outerRing = polygonRings[0];\n    for (let i = 0; i < outerRing.length; i++) {\n        const p = outerRing[i];\n        if (!i || p.x < minX) minX = p.x;\n        if (!i || p.y < minY) minY = p.y;\n        if (!i || p.x > maxX) maxX = p.x;\n        if (!i || p.y > maxY) maxY = p.y;\n    }\n\n    const width = maxX - minX;\n    const height = maxY - minY;\n    const cellSize = Math.min(width, height);\n    let h = cellSize / 2;\n\n    // a priority queue of cells in order of their \"potential\" (max distance to polygon)\n    const cellQueue = new Queue(null, compareMax);\n\n    if (cellSize === 0) return new Point(minX, minY);\n\n    // cover polygon with initial cells\n    for (let x = minX; x < maxX; x += cellSize) {\n        for (let y = minY; y < maxY; y += cellSize) {\n            cellQueue.push(new Cell(x + h, y + h, h, polygonRings));\n        }\n    }\n\n    // take centroid as the first best guess\n    let bestCell = getCentroidCell(polygonRings);\n    let numProbes = cellQueue.length;\n\n    while (cellQueue.length) {\n        // pick the most promising cell from the queue\n        const cell = cellQueue.pop();\n\n        // update the best cell if we found a better one\n        if (cell.d > bestCell.d || !bestCell.d) {\n            bestCell = cell;\n            if (debug) console.log('found best %d after %d probes', Math.round(1e4 * cell.d) / 1e4, numProbes);\n        }\n\n        // do not drill down further if there's no chance of a better solution\n        if (cell.max - bestCell.d <= precision) continue;\n\n        // split the cell into four cells\n        h = cell.h / 2;\n        cellQueue.push(new Cell(cell.p.x - h, cell.p.y - h, h, polygonRings));\n        cellQueue.push(new Cell(cell.p.x + h, cell.p.y - h, h, polygonRings));\n        cellQueue.push(new Cell(cell.p.x - h, cell.p.y + h, h, polygonRings));\n        cellQueue.push(new Cell(cell.p.x + h, cell.p.y + h, h, polygonRings));\n        numProbes += 4;\n    }\n\n    if (debug) {\n        console.log(`num probes: ${numProbes}`);\n        console.log(`best distance: ${bestCell.d}`);\n    }\n\n    return bestCell.p;\n}\n\nfunction compareMax(a, b) {\n    return b.max - a.max;\n}\n\nfunction Cell(x, y, h, polygon) {\n    this.p = new Point(x, y);\n    this.h = h; // half the cell size\n    this.d = pointToPolygonDist(this.p, polygon); // distance from cell center to polygon\n    this.max = this.d + this.h * Math.SQRT2; // max distance to polygon within a cell\n}\n\n// signed distance from point to polygon outline (negative if point is outside)\nfunction pointToPolygonDist(p, polygon) {\n    let inside = false;\n    let minDistSq = Infinity;\n\n    for (let k = 0; k < polygon.length; k++) {\n        const ring = polygon[k];\n\n        for (let i = 0, len = ring.length, j = len - 1; i < len; j = i++) {\n            const a = ring[i];\n            const b = ring[j];\n\n            if ((a.y > p.y !== b.y > p.y) &&\n                (p.x < (b.x - a.x) * (p.y - a.y) / (b.y - a.y) + a.x)) inside = !inside;\n\n            minDistSq = Math.min(minDistSq, distToSegmentSquared(p, a, b));\n        }\n    }\n\n    return (inside ? 1 : -1) * Math.sqrt(minDistSq);\n}\n\n// get polygon centroid\nfunction getCentroidCell(polygon) {\n    let area = 0;\n    let x = 0;\n    let y = 0;\n    const points = polygon[0];\n    for (let i = 0, len = points.length, j = len - 1; i < len; j = i++) {\n        const a = points[i];\n        const b = points[j];\n        const f = a.x * b.y - b.x * a.y;\n        x += (a.x + b.x) * f;\n        y += (a.y + b.y) * f;\n        area += f * 3;\n    }\n    return new Cell(x / area, y / area, 0, polygon);\n}\n","/**\n * JS Implementation of MurmurHash3 (r136) (as of May 20, 2011)\n * \n * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\n * @see http://github.com/garycourt/murmurhash-js\n * @author <a href=\"mailto:aappleby@gmail.com\">Austin Appleby</a>\n * @see http://sites.google.com/site/murmurhash/\n * \n * @param {string} key ASCII only\n * @param {number} seed Positive integer only\n * @return {number} 32-bit positive integer hash \n */\n\nfunction murmurhash3_32_gc(key, seed) {\n\tvar remainder, bytes, h1, h1b, c1, c1b, c2, c2b, k1, i;\n\t\n\tremainder = key.length & 3; // key.length % 4\n\tbytes = key.length - remainder;\n\th1 = seed;\n\tc1 = 0xcc9e2d51;\n\tc2 = 0x1b873593;\n\ti = 0;\n\t\n\twhile (i < bytes) {\n\t  \tk1 = \n\t  \t  ((key.charCodeAt(i) & 0xff)) |\n\t  \t  ((key.charCodeAt(++i) & 0xff) << 8) |\n\t  \t  ((key.charCodeAt(++i) & 0xff) << 16) |\n\t  \t  ((key.charCodeAt(++i) & 0xff) << 24);\n\t\t++i;\n\t\t\n\t\tk1 = ((((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16))) & 0xffffffff;\n\t\tk1 = (k1 << 15) | (k1 >>> 17);\n\t\tk1 = ((((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16))) & 0xffffffff;\n\n\t\th1 ^= k1;\n        h1 = (h1 << 13) | (h1 >>> 19);\n\t\th1b = ((((h1 & 0xffff) * 5) + ((((h1 >>> 16) * 5) & 0xffff) << 16))) & 0xffffffff;\n\t\th1 = (((h1b & 0xffff) + 0x6b64) + ((((h1b >>> 16) + 0xe654) & 0xffff) << 16));\n\t}\n\t\n\tk1 = 0;\n\t\n\tswitch (remainder) {\n\t\tcase 3: k1 ^= (key.charCodeAt(i + 2) & 0xff) << 16;\n\t\tcase 2: k1 ^= (key.charCodeAt(i + 1) & 0xff) << 8;\n\t\tcase 1: k1 ^= (key.charCodeAt(i) & 0xff);\n\t\t\n\t\tk1 = (((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16)) & 0xffffffff;\n\t\tk1 = (k1 << 15) | (k1 >>> 17);\n\t\tk1 = (((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16)) & 0xffffffff;\n\t\th1 ^= k1;\n\t}\n\t\n\th1 ^= key.length;\n\n\th1 ^= h1 >>> 16;\n\th1 = (((h1 & 0xffff) * 0x85ebca6b) + ((((h1 >>> 16) * 0x85ebca6b) & 0xffff) << 16)) & 0xffffffff;\n\th1 ^= h1 >>> 13;\n\th1 = ((((h1 & 0xffff) * 0xc2b2ae35) + ((((h1 >>> 16) * 0xc2b2ae35) & 0xffff) << 16))) & 0xffffffff;\n\th1 ^= h1 >>> 16;\n\n\treturn h1 >>> 0;\n}\n\nif(typeof module !== \"undefined\") {\n  module.exports = murmurhash3_32_gc\n}","/**\n * JS Implementation of MurmurHash2\n * \n * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\n * @see http://github.com/garycourt/murmurhash-js\n * @author <a href=\"mailto:aappleby@gmail.com\">Austin Appleby</a>\n * @see http://sites.google.com/site/murmurhash/\n * \n * @param {string} str ASCII only\n * @param {number} seed Positive integer only\n * @return {number} 32-bit positive integer hash\n */\n\nfunction murmurhash2_32_gc(str, seed) {\n  var\n    l = str.length,\n    h = seed ^ l,\n    i = 0,\n    k;\n  \n  while (l >= 4) {\n  \tk = \n  \t  ((str.charCodeAt(i) & 0xff)) |\n  \t  ((str.charCodeAt(++i) & 0xff) << 8) |\n  \t  ((str.charCodeAt(++i) & 0xff) << 16) |\n  \t  ((str.charCodeAt(++i) & 0xff) << 24);\n    \n    k = (((k & 0xffff) * 0x5bd1e995) + ((((k >>> 16) * 0x5bd1e995) & 0xffff) << 16));\n    k ^= k >>> 24;\n    k = (((k & 0xffff) * 0x5bd1e995) + ((((k >>> 16) * 0x5bd1e995) & 0xffff) << 16));\n\n\th = (((h & 0xffff) * 0x5bd1e995) + ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16)) ^ k;\n\n    l -= 4;\n    ++i;\n  }\n  \n  switch (l) {\n  case 3: h ^= (str.charCodeAt(i + 2) & 0xff) << 16;\n  case 2: h ^= (str.charCodeAt(i + 1) & 0xff) << 8;\n  case 1: h ^= (str.charCodeAt(i) & 0xff);\n          h = (((h & 0xffff) * 0x5bd1e995) + ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16));\n  }\n\n  h ^= h >>> 13;\n  h = (((h & 0xffff) * 0x5bd1e995) + ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16));\n  h ^= h >>> 15;\n\n  return h >>> 0;\n}\n\nif(typeof module !== undefined) {\n  module.exports = murmurhash2_32_gc\n}\n","var murmur3 = require(\"./murmurhash3_gc.js\")\nvar murmur2 = require(\"./murmurhash2_gc.js\")\n\nmodule.exports = murmur3\nmodule.exports.murmur3 = murmur3\nmodule.exports.murmur2 = murmur2\n","// @flow\n\nimport Anchor from './anchor';\n\nimport { getAnchors, getCenterAnchor } from './get_anchors';\nimport clipLine from './clip_line';\nimport { shapeText, shapeIcon, WritingMode } from './shaping';\nimport { getGlyphQuads, getIconQuads } from './quads';\nimport CollisionFeature from './collision_feature';\nimport { warnOnce } from '../util/util';\nimport {\n    allowsVerticalWritingMode,\n    allowsLetterSpacing\n} from '../util/script_detection';\nimport findPoleOfInaccessibility from '../util/find_pole_of_inaccessibility';\nimport classifyRings from '../util/classify_rings';\nimport EXTENT from '../data/extent';\nimport SymbolBucket from '../data/bucket/symbol_bucket';\nimport EvaluationParameters from '../style/evaluation_parameters';\nimport {SIZE_PACK_FACTOR} from './symbol_size';\n\nimport type {Shaping, PositionedIcon} from './shaping';\nimport type {CollisionBoxArray} from '../data/array_types';\nimport type {SymbolFeature} from '../data/bucket/symbol_bucket';\nimport type {StyleImage} from '../style/style_image';\nimport type {StyleGlyph} from '../style/style_glyph';\nimport type SymbolStyleLayer from '../style/style_layer/symbol_style_layer';\nimport type {ImagePosition} from '../render/image_atlas';\nimport type {GlyphPosition} from '../render/glyph_atlas';\nimport type {PossiblyEvaluatedPropertyValue} from '../style/properties';\n\nimport Point from '@mapbox/point-geometry';\nimport murmur3 from 'murmurhash-js';\n\n// The symbol layout process needs `text-size` evaluated at up to five different zoom levels, and\n// `icon-size` at up to three:\n//\n//   1. `text-size` at the zoom level of the bucket. Used to calculate a per-feature size for source `text-size`\n//       expressions, and to calculate the box dimensions for icon-text-fit.\n//   2. `icon-size` at the zoom level of the bucket. Used to calculate a per-feature size for source `icon-size`\n//       expressions.\n//   3. `text-size` and `icon-size` at the zoom level of the bucket, plus one. Used to calculate collision boxes.\n//   4. `text-size` at zoom level 18. Used for something line-symbol-placement-related.\n//   5.  For composite `*-size` expressions: two zoom levels of curve stops that \"cover\" the zoom level of the\n//       bucket. These go into a vertex buffer and are used by the shader to interpolate the size at render time.\n//\n// (1) and (2) are stored in `bucket.layers[0].layout`. The remainder are below.\n//\ntype Sizes = {\n    layoutTextSize: PossiblyEvaluatedPropertyValue<number>, // (3)\n    layoutIconSize: PossiblyEvaluatedPropertyValue<number>, // (3)\n    textMaxSize: PossiblyEvaluatedPropertyValue<number>,    // (4)\n    compositeTextSizes: [PossiblyEvaluatedPropertyValue<number>, PossiblyEvaluatedPropertyValue<number>], // (5)\n    compositeIconSizes: [PossiblyEvaluatedPropertyValue<number>, PossiblyEvaluatedPropertyValue<number>], // (5)\n};\n\nexport function performSymbolLayout(bucket: SymbolBucket,\n                             glyphMap: {[string]: {[number]: ?StyleGlyph}},\n                             glyphPositions: {[string]: {[number]: GlyphPosition}},\n                             imageMap: {[string]: StyleImage},\n                             imagePositions: {[string]: ImagePosition},\n                             showCollisionBoxes: boolean) {\n    bucket.createArrays();\n\n    const tileSize = 512 * bucket.overscaling;\n    bucket.tilePixelRatio = EXTENT / tileSize;\n    bucket.compareText = {};\n    bucket.iconsNeedLinear = false;\n\n    const layout = bucket.layers[0].layout;\n    const unevaluatedLayoutValues = bucket.layers[0]._unevaluatedLayout._values;\n\n    const sizes = {};\n\n    if (bucket.textSizeData.functionType === 'composite') {\n        const {min, max} = bucket.textSizeData.zoomRange;\n        sizes.compositeTextSizes = [\n            unevaluatedLayoutValues['text-size'].possiblyEvaluate(new EvaluationParameters(min)),\n            unevaluatedLayoutValues['text-size'].possiblyEvaluate(new EvaluationParameters(max))\n        ];\n    }\n\n    if (bucket.iconSizeData.functionType === 'composite') {\n        const {min, max} = bucket.iconSizeData.zoomRange;\n        sizes.compositeIconSizes = [\n            unevaluatedLayoutValues['icon-size'].possiblyEvaluate(new EvaluationParameters(min)),\n            unevaluatedLayoutValues['icon-size'].possiblyEvaluate(new EvaluationParameters(max))\n        ];\n    }\n\n    sizes.layoutTextSize = unevaluatedLayoutValues['text-size'].possiblyEvaluate(new EvaluationParameters(bucket.zoom + 1));\n    sizes.layoutIconSize = unevaluatedLayoutValues['icon-size'].possiblyEvaluate(new EvaluationParameters(bucket.zoom + 1));\n    sizes.textMaxSize = unevaluatedLayoutValues['text-size'].possiblyEvaluate(new EvaluationParameters(18));\n\n    const oneEm = 24;\n    const lineHeight = layout.get('text-line-height') * oneEm;\n    const textAlongLine = layout.get('text-rotation-alignment') === 'map' && layout.get('symbol-placement') !== 'point';\n    const keepUpright = layout.get('text-keep-upright');\n\n\n    for (const feature of bucket.features) {\n        const fontstack = layout.get('text-font').evaluate(feature, {}).join(',');\n        const glyphPositionMap = glyphPositions;\n\n        const shapedTextOrientations = {};\n        const text = feature.text;\n        if (text) {\n            const unformattedText = text.toString();\n            const textOffset: [number, number] = (layout.get('text-offset').evaluate(feature, {}).map((t) => t * oneEm): any);\n            const spacing = layout.get('text-letter-spacing').evaluate(feature, {}) * oneEm;\n            const spacingIfAllowed = allowsLetterSpacing(unformattedText) ? spacing : 0;\n            const textAnchor = layout.get('text-anchor').evaluate(feature, {});\n            const textJustify = layout.get('text-justify').evaluate(feature, {});\n            const maxWidth = layout.get('symbol-placement') === 'point' ?\n                layout.get('text-max-width').evaluate(feature, {}) * oneEm :\n                0;\n\n            shapedTextOrientations.horizontal = shapeText(text, glyphMap, fontstack, maxWidth, lineHeight, textAnchor, textJustify, spacingIfAllowed, textOffset, oneEm, WritingMode.horizontal);\n            if (allowsVerticalWritingMode(unformattedText) && textAlongLine && keepUpright) {\n                shapedTextOrientations.vertical = shapeText(text, glyphMap, fontstack, maxWidth, lineHeight, textAnchor, textJustify, spacingIfAllowed, textOffset, oneEm, WritingMode.vertical);\n            }\n        }\n\n        let shapedIcon;\n        if (feature.icon) {\n            const image = imageMap[feature.icon];\n            if (image) {\n                shapedIcon = shapeIcon(\n                    imagePositions[feature.icon],\n                    layout.get('icon-offset').evaluate(feature, {}),\n                    layout.get('icon-anchor').evaluate(feature, {}));\n                if (bucket.sdfIcons === undefined) {\n                    bucket.sdfIcons = image.sdf;\n                } else if (bucket.sdfIcons !== image.sdf) {\n                    warnOnce('Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer');\n                }\n                if (image.pixelRatio !== bucket.pixelRatio) {\n                    bucket.iconsNeedLinear = true;\n                } else if (layout.get('icon-rotate').constantOr(1) !== 0) {\n                    bucket.iconsNeedLinear = true;\n                }\n            }\n        }\n\n        if (shapedTextOrientations.horizontal || shapedIcon) {\n            addFeature(bucket, feature, shapedTextOrientations, shapedIcon, glyphPositionMap, sizes);\n        }\n    }\n\n    if (showCollisionBoxes) {\n        bucket.generateCollisionDebugBuffers();\n    }\n}\n\n\n/**\n * Given a feature and its shaped text and icon data, add a 'symbol\n * instance' for each _possible_ placement of the symbol feature.\n * (At render timePlaceSymbols#place() selects which of these instances to\n * show or hide based on collisions with symbols in other layers.)\n * @private\n */\nfunction addFeature(bucket: SymbolBucket,\n                    feature: SymbolFeature,\n                    shapedTextOrientations: any,\n                    shapedIcon: PositionedIcon | void,\n                    glyphPositionMap: {[string]: {[number]: GlyphPosition}},\n                    sizes: Sizes) {\n    const layoutTextSize = sizes.layoutTextSize.evaluate(feature, {});\n    const layoutIconSize = sizes.layoutIconSize.evaluate(feature, {});\n\n    // To reduce the number of labels that jump around when zooming we need\n    // to use a text-size value that is the same for all zoom levels.\n    // bucket calculates text-size at a high zoom level so that all tiles can\n    // use the same value when calculating anchor positions.\n    let textMaxSize = sizes.textMaxSize.evaluate(feature, {});\n    if (textMaxSize === undefined) {\n        textMaxSize = layoutTextSize;\n    }\n\n    const layout = bucket.layers[0].layout;\n    const textOffset = layout.get('text-offset').evaluate(feature, {});\n    const iconOffset = layout.get('icon-offset').evaluate(feature, {});\n\n    const glyphSize = 24,\n        fontScale = layoutTextSize / glyphSize,\n        textBoxScale = bucket.tilePixelRatio * fontScale,\n        textMaxBoxScale = bucket.tilePixelRatio * textMaxSize / glyphSize,\n        iconBoxScale = bucket.tilePixelRatio * layoutIconSize,\n        symbolMinDistance = bucket.tilePixelRatio * layout.get('symbol-spacing'),\n        textPadding = layout.get('text-padding') * bucket.tilePixelRatio,\n        iconPadding = layout.get('icon-padding') * bucket.tilePixelRatio,\n        textMaxAngle = layout.get('text-max-angle') / 180 * Math.PI,\n        textAlongLine = layout.get('text-rotation-alignment') === 'map' && layout.get('symbol-placement') !== 'point',\n        iconAlongLine = layout.get('icon-rotation-alignment') === 'map' && layout.get('symbol-placement') !== 'point',\n        symbolPlacement = layout.get('symbol-placement'),\n        textRepeatDistance = symbolMinDistance / 2;\n\n    const addSymbolAtAnchor = (line, anchor) => {\n        if (anchor.x < 0 || anchor.x >= EXTENT || anchor.y < 0 || anchor.y >= EXTENT) {\n            // Symbol layers are drawn across tile boundaries, We filter out symbols\n            // outside our tile boundaries (which may be included in vector tile buffers)\n            // to prevent double-drawing symbols.\n            return;\n        }\n\n        addSymbol(bucket, anchor, line, shapedTextOrientations, shapedIcon, bucket.layers[0],\n            bucket.collisionBoxArray, feature.index, feature.sourceLayerIndex, bucket.index,\n            textBoxScale, textPadding, textAlongLine, textOffset,\n            iconBoxScale, iconPadding, iconAlongLine, iconOffset,\n            feature, glyphPositionMap, sizes);\n    };\n\n    if (symbolPlacement === 'line') {\n        for (const line of clipLine(feature.geometry, 0, 0, EXTENT, EXTENT)) {\n            const anchors = getAnchors(\n                line,\n                symbolMinDistance,\n                textMaxAngle,\n                shapedTextOrientations.vertical || shapedTextOrientations.horizontal,\n                shapedIcon,\n                glyphSize,\n                textMaxBoxScale,\n                bucket.overscaling,\n                EXTENT\n            );\n            for (const anchor of anchors) {\n                const shapedText = shapedTextOrientations.horizontal;\n                if (!shapedText || !anchorIsTooClose(bucket, shapedText.text, textRepeatDistance, anchor)) {\n                    addSymbolAtAnchor(line, anchor);\n                }\n            }\n        }\n    } else if (symbolPlacement === 'line-center') {\n        // No clipping, multiple lines per feature are allowed\n        // \"lines\" with only one point are ignored as in clipLines\n        for (const line of feature.geometry) {\n            if (line.length > 1) {\n                const anchor = getCenterAnchor(\n                    line,\n                    textMaxAngle,\n                    shapedTextOrientations.vertical || shapedTextOrientations.horizontal,\n                    shapedIcon,\n                    glyphSize,\n                    textMaxBoxScale);\n                if (anchor) {\n                    addSymbolAtAnchor(line, anchor);\n                }\n            }\n        }\n    } else if (feature.type === 'Polygon') {\n        for (const polygon of classifyRings(feature.geometry, 0)) {\n            // 16 here represents 2 pixels\n            const poi = findPoleOfInaccessibility(polygon, 16);\n            addSymbolAtAnchor(polygon[0], new Anchor(poi.x, poi.y, 0));\n        }\n    } else if (feature.type === 'LineString') {\n        // https://github.com/mapbox/mapbox-gl-js/issues/3808\n        for (const line of feature.geometry) {\n            addSymbolAtAnchor(line, new Anchor(line[0].x, line[0].y, 0));\n        }\n    } else if (feature.type === 'Point') {\n        for (const points of feature.geometry) {\n            for (const point of points) {\n                addSymbolAtAnchor([point], new Anchor(point.x, point.y, 0));\n            }\n        }\n    }\n}\n\nconst MAX_PACKED_SIZE = 65535;\n\nfunction addTextVertices(bucket: SymbolBucket,\n                         anchor: Point,\n                         shapedText: Shaping,\n                         layer: SymbolStyleLayer,\n                         textAlongLine: boolean,\n                         feature: SymbolFeature,\n                         textOffset: [number, number],\n                         lineArray: {lineStartIndex: number, lineLength: number},\n                         writingMode: number,\n                         placedTextSymbolIndices: Array<number>,\n                         glyphPositionMap: {[string]: {[number]: GlyphPosition}},\n                         sizes: Sizes) {\n    const glyphQuads = getGlyphQuads(anchor, shapedText,\n                            layer, textAlongLine, feature, glyphPositionMap);\n\n    const sizeData = bucket.textSizeData;\n    let textSizeData = null;\n\n    if (sizeData.functionType === 'source') {\n        textSizeData = [\n            SIZE_PACK_FACTOR * layer.layout.get('text-size').evaluate(feature, {})\n        ];\n        if (textSizeData[0] > MAX_PACKED_SIZE) {\n            warnOnce(`${bucket.layerIds[0]}: Value for \"text-size\" is >= 256. Reduce your \"text-size\".`);\n        }\n    } else if (sizeData.functionType === 'composite') {\n        textSizeData = [\n            SIZE_PACK_FACTOR * sizes.compositeTextSizes[0].evaluate(feature, {}),\n            SIZE_PACK_FACTOR * sizes.compositeTextSizes[1].evaluate(feature, {})\n        ];\n        if (textSizeData[0] > MAX_PACKED_SIZE || textSizeData[1] > MAX_PACKED_SIZE) {\n            warnOnce(`${bucket.layerIds[0]}: Value for \"text-size\" is >= 256. Reduce your \"text-size\".`);\n        }\n    }\n\n    bucket.addSymbols(\n        bucket.text,\n        glyphQuads,\n        textSizeData,\n        textOffset,\n        textAlongLine,\n        feature,\n        writingMode,\n        anchor,\n        lineArray.lineStartIndex,\n        lineArray.lineLength);\n\n    // The placedSymbolArray is used at render time in drawTileSymbols\n    // These indices allow access to the array at collision detection time\n    placedTextSymbolIndices.push(bucket.text.placedSymbolArray.length - 1);\n\n    return glyphQuads.length * 4;\n}\n\n\n/**\n * Add a single label & icon placement.\n *\n * @private\n */\nfunction addSymbol(bucket: SymbolBucket,\n                   anchor: Anchor,\n                   line: Array<Point>,\n                   shapedTextOrientations: any,\n                   shapedIcon: PositionedIcon | void,\n                   layer: SymbolStyleLayer,\n                   collisionBoxArray: CollisionBoxArray,\n                   featureIndex: number,\n                   sourceLayerIndex: number,\n                   bucketIndex: number,\n                   textBoxScale: number,\n                   textPadding: number,\n                   textAlongLine: boolean,\n                   textOffset: [number, number],\n                   iconBoxScale: number,\n                   iconPadding: number,\n                   iconAlongLine: boolean,\n                   iconOffset: [number, number],\n                   feature: SymbolFeature,\n                   glyphPositionMap: {[string]: {[number]: GlyphPosition}},\n                   sizes: Sizes) {\n    const lineArray = bucket.addToLineVertexArray(anchor, line);\n\n    let textCollisionFeature, iconCollisionFeature;\n\n    let numIconVertices = 0;\n    let numGlyphVertices = 0;\n    let numVerticalGlyphVertices = 0;\n    const key = murmur3(shapedTextOrientations.horizontal ? shapedTextOrientations.horizontal.text : '');\n    const placedTextSymbolIndices = [];\n    if (shapedTextOrientations.horizontal) {\n        // As a collision approximation, we can use either the vertical or the horizontal version of the feature\n        // We're counting on the two versions having similar dimensions\n        const textRotate = layer.layout.get('text-rotate').evaluate(feature, {});\n        textCollisionFeature = new CollisionFeature(collisionBoxArray, line, anchor, featureIndex, sourceLayerIndex, bucketIndex, shapedTextOrientations.horizontal, textBoxScale, textPadding, textAlongLine, bucket.overscaling, textRotate);\n        numGlyphVertices += addTextVertices(bucket, anchor, shapedTextOrientations.horizontal, layer, textAlongLine, feature, textOffset, lineArray, shapedTextOrientations.vertical ? WritingMode.horizontal : WritingMode.horizontalOnly, placedTextSymbolIndices, glyphPositionMap, sizes);\n\n        if (shapedTextOrientations.vertical) {\n            numVerticalGlyphVertices += addTextVertices(bucket, anchor, shapedTextOrientations.vertical, layer, textAlongLine, feature, textOffset, lineArray, WritingMode.vertical, placedTextSymbolIndices, glyphPositionMap, sizes);\n        }\n    }\n\n    const textBoxStartIndex = textCollisionFeature ? textCollisionFeature.boxStartIndex : bucket.collisionBoxArray.length;\n    const textBoxEndIndex = textCollisionFeature ? textCollisionFeature.boxEndIndex : bucket.collisionBoxArray.length;\n\n    if (shapedIcon) {\n        const iconQuads = getIconQuads(anchor, shapedIcon, layer,\n                            iconAlongLine, shapedTextOrientations.horizontal,\n                            feature);\n        const iconRotate = layer.layout.get('icon-rotate').evaluate(feature, {});\n        iconCollisionFeature = new CollisionFeature(collisionBoxArray, line, anchor, featureIndex, sourceLayerIndex, bucketIndex, shapedIcon, iconBoxScale, iconPadding, /*align boxes to line*/false, bucket.overscaling, iconRotate);\n\n        numIconVertices = iconQuads.length * 4;\n\n        const sizeData = bucket.iconSizeData;\n        let iconSizeData = null;\n\n        if (sizeData.functionType === 'source') {\n            iconSizeData = [\n                SIZE_PACK_FACTOR * layer.layout.get('icon-size').evaluate(feature, {})\n            ];\n            if (iconSizeData[0] > MAX_PACKED_SIZE) {\n                warnOnce(`${bucket.layerIds[0]}: Value for \"icon-size\" is >= 256. Reduce your \"icon-size\".`);\n            }\n        } else if (sizeData.functionType === 'composite') {\n            iconSizeData = [\n                SIZE_PACK_FACTOR * sizes.compositeIconSizes[0].evaluate(feature, {}),\n                SIZE_PACK_FACTOR * sizes.compositeIconSizes[1].evaluate(feature, {})\n            ];\n            if (iconSizeData[0] > MAX_PACKED_SIZE || iconSizeData[1] > MAX_PACKED_SIZE) {\n                warnOnce(`${bucket.layerIds[0]}: Value for \"icon-size\" is >= 256. Reduce your \"icon-size\".`);\n            }\n        }\n\n        bucket.addSymbols(\n            bucket.icon,\n            iconQuads,\n            iconSizeData,\n            iconOffset,\n            iconAlongLine,\n            feature,\n            false,\n            anchor,\n            lineArray.lineStartIndex,\n            lineArray.lineLength);\n    }\n\n    const iconBoxStartIndex = iconCollisionFeature ? iconCollisionFeature.boxStartIndex : bucket.collisionBoxArray.length;\n    const iconBoxEndIndex = iconCollisionFeature ? iconCollisionFeature.boxEndIndex : bucket.collisionBoxArray.length;\n\n    if (bucket.glyphOffsetArray.length >= SymbolBucket.MAX_GLYPHS) warnOnce(\n        \"Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907\"\n    );\n\n    bucket.symbolInstances.emplaceBack(\n        anchor.x,\n        anchor.y,\n        placedTextSymbolIndices.length > 0 ? placedTextSymbolIndices[0] : -1,\n        placedTextSymbolIndices.length > 1 ? placedTextSymbolIndices[1] : -1,\n        key,\n        textBoxStartIndex,\n        textBoxEndIndex,\n        iconBoxStartIndex,\n        iconBoxEndIndex,\n        featureIndex,\n        numGlyphVertices,\n        numVerticalGlyphVertices,\n        numIconVertices,\n        0);\n}\n\nfunction anchorIsTooClose(bucket: any, text: string, repeatDistance: number, anchor: Point) {\n    const compareText = bucket.compareText;\n    if (!(text in compareText)) {\n        compareText[text] = [];\n    } else {\n        const otherAnchors = compareText[text];\n        for (let k = otherAnchors.length - 1; k >= 0; k--) {\n            if (anchor.dist(otherAnchors[k]) < repeatDistance) {\n                // If it's within repeatDistance of one anchor, stop looking\n                return true;\n            }\n        }\n    }\n    // If anchor is not within repeatDistance of any other anchor, add to array\n    compareText[text].push(anchor);\n    return false;\n}\n","// @flow\n\nimport Point from '@mapbox/point-geometry';\n\nimport { GLYPH_PBF_BORDER } from '../style/parse_glyph_pbf';\n\nimport type Anchor from './anchor';\nimport type {PositionedIcon, Shaping} from './shaping';\nimport type SymbolStyleLayer from '../style/style_layer/symbol_style_layer';\nimport type {Feature} from '../style-spec/expression';\nimport type {GlyphPosition} from '../render/glyph_atlas';\n\n/**\n * A textured quad for rendering a single icon or glyph.\n *\n * The zoom range the glyph can be shown is defined by minScale and maxScale.\n *\n * @param tl The offset of the top left corner from the anchor.\n * @param tr The offset of the top right corner from the anchor.\n * @param bl The offset of the bottom left corner from the anchor.\n * @param br The offset of the bottom right corner from the anchor.\n * @param tex The texture coordinates.\n *\n * @private\n */\nexport type SymbolQuad = {\n    tl: Point,\n    tr: Point,\n    bl: Point,\n    br: Point,\n    tex: {\n        x: number,\n        y: number,\n        w: number,\n        h: number\n    },\n    writingMode: any | void,\n    glyphOffset: [number, number]\n};\n\n/**\n * Create the quads used for rendering an icon.\n * @private\n */\nexport function getIconQuads(anchor: Anchor,\n                      shapedIcon: PositionedIcon,\n                      layer: SymbolStyleLayer,\n                      alongLine: boolean,\n                      shapedText: Shaping,\n                      feature: Feature): Array<SymbolQuad> {\n    const image = shapedIcon.image;\n    const layout = layer.layout;\n\n    // If you have a 10px icon that isn't perfectly aligned to the pixel grid it will cover 11 actual\n    // pixels. The quad needs to be padded to account for this, otherwise they'll look slightly clipped\n    // on one edge in some cases.\n    const border = 1;\n\n    const top = shapedIcon.top - border / image.pixelRatio;\n    const left = shapedIcon.left - border / image.pixelRatio;\n    const bottom = shapedIcon.bottom + border / image.pixelRatio;\n    const right = shapedIcon.right + border / image.pixelRatio;\n    let tl, tr, br, bl;\n\n    // text-fit mode\n    if (layout.get('icon-text-fit') !== 'none' && shapedText) {\n        const iconWidth = (right - left),\n            iconHeight = (bottom - top),\n            size = layout.get('text-size').evaluate(feature, {}) / 24,\n            textLeft = shapedText.left * size,\n            textRight = shapedText.right * size,\n            textTop = shapedText.top * size,\n            textBottom = shapedText.bottom * size,\n            textWidth = textRight - textLeft,\n            textHeight = textBottom - textTop,\n            padT = layout.get('icon-text-fit-padding')[0],\n            padR = layout.get('icon-text-fit-padding')[1],\n            padB = layout.get('icon-text-fit-padding')[2],\n            padL = layout.get('icon-text-fit-padding')[3],\n            offsetY = layout.get('icon-text-fit') === 'width' ? (textHeight - iconHeight) * 0.5 : 0,\n            offsetX = layout.get('icon-text-fit') === 'height' ? (textWidth - iconWidth) * 0.5 : 0,\n            width = layout.get('icon-text-fit') === 'width' || layout.get('icon-text-fit') === 'both' ? textWidth : iconWidth,\n            height = layout.get('icon-text-fit') === 'height' || layout.get('icon-text-fit') === 'both' ? textHeight : iconHeight;\n        tl = new Point(textLeft + offsetX - padL,         textTop + offsetY - padT);\n        tr = new Point(textLeft + offsetX + padR + width, textTop + offsetY - padT);\n        br = new Point(textLeft + offsetX + padR + width, textTop + offsetY + padB + height);\n        bl = new Point(textLeft + offsetX - padL,         textTop + offsetY + padB + height);\n    // Normal icon size mode\n    } else {\n        tl = new Point(left, top);\n        tr = new Point(right, top);\n        br = new Point(right, bottom);\n        bl = new Point(left, bottom);\n    }\n\n    const angle = layer.layout.get('icon-rotate').evaluate(feature, {}) * Math.PI / 180;\n\n    if (angle) {\n        const sin = Math.sin(angle),\n            cos = Math.cos(angle),\n            matrix = [cos, -sin, sin, cos];\n\n        tl._matMult(matrix);\n        tr._matMult(matrix);\n        bl._matMult(matrix);\n        br._matMult(matrix);\n    }\n\n    // Icon quad is padded, so texture coordinates also need to be padded.\n    return [{tl, tr, bl, br, tex: image.paddedRect, writingMode: undefined, glyphOffset: [0, 0]}];\n}\n\n/**\n * Create the quads used for rendering a text label.\n * @private\n */\nexport function getGlyphQuads(anchor: Anchor,\n                       shaping: Shaping,\n                       layer: SymbolStyleLayer,\n                       alongLine: boolean,\n                       feature: Feature,\n                       positions: {[string]: {[number]: GlyphPosition}}): Array<SymbolQuad> {\n\n    const oneEm = 24;\n    const textRotate = layer.layout.get('text-rotate').evaluate(feature, {}) * Math.PI / 180;\n    const textOffset = layer.layout.get('text-offset').evaluate(feature, {}).map((t) => t * oneEm);\n\n    const positionedGlyphs = shaping.positionedGlyphs;\n    const quads = [];\n\n\n    for (let k = 0; k < positionedGlyphs.length; k++) {\n        const positionedGlyph = positionedGlyphs[k];\n        const glyphPositions = positions[positionedGlyph.fontStack];\n        const glyph = glyphPositions && glyphPositions[positionedGlyph.glyph];\n        if (!glyph) continue;\n\n        const rect = glyph.rect;\n        if (!rect) continue;\n\n        // The rects have an addditional buffer that is not included in their size.\n        const glyphPadding = 1.0;\n        const rectBuffer = GLYPH_PBF_BORDER + glyphPadding;\n\n        const halfAdvance = glyph.metrics.advance * positionedGlyph.scale / 2;\n\n        const glyphOffset = alongLine ?\n            [positionedGlyph.x + halfAdvance, positionedGlyph.y] :\n            [0, 0];\n\n        const builtInOffset = alongLine ?\n            [0, 0] :\n            [positionedGlyph.x + halfAdvance + textOffset[0], positionedGlyph.y + textOffset[1]];\n\n        const x1 = (glyph.metrics.left - rectBuffer) * positionedGlyph.scale - halfAdvance + builtInOffset[0];\n        const y1 = (-glyph.metrics.top - rectBuffer) * positionedGlyph.scale + builtInOffset[1];\n        const x2 = x1 + rect.w * positionedGlyph.scale;\n        const y2 = y1 + rect.h * positionedGlyph.scale;\n\n        const tl = new Point(x1, y1);\n        const tr = new Point(x2, y1);\n        const bl  = new Point(x1, y2);\n        const br = new Point(x2, y2);\n\n        if (alongLine && positionedGlyph.vertical) {\n            // Vertical-supporting glyphs are laid out in 24x24 point boxes (1 square em)\n            // In horizontal orientation, the y values for glyphs are below the midline\n            // and we use a \"yOffset\" of -17 to pull them up to the middle.\n            // By rotating counter-clockwise around the point at the center of the left\n            // edge of a 24x24 layout box centered below the midline, we align the center\n            // of the glyphs with the horizontal midline, so the yOffset is no longer\n            // necessary, but we also pull the glyph to the left along the x axis\n            const center = new Point(-halfAdvance, halfAdvance);\n            const verticalRotation = -Math.PI / 2;\n            const xOffsetCorrection = new Point(5, 0);\n            tl._rotateAround(verticalRotation, center)._add(xOffsetCorrection);\n            tr._rotateAround(verticalRotation, center)._add(xOffsetCorrection);\n            bl._rotateAround(verticalRotation, center)._add(xOffsetCorrection);\n            br._rotateAround(verticalRotation, center)._add(xOffsetCorrection);\n        }\n\n        if (textRotate) {\n            const sin = Math.sin(textRotate),\n                cos = Math.cos(textRotate),\n                matrix = [cos, -sin, sin, cos];\n\n            tl._matMult(matrix);\n            tr._matMult(matrix);\n            bl._matMult(matrix);\n            br._matMult(matrix);\n        }\n\n        quads.push({tl, tr, bl, br, tex: rect, writingMode: shaping.writingMode, glyphOffset});\n    }\n\n    return quads;\n}\n","// @flow\n\nimport Point from '@mapbox/point-geometry';\n\nexport default clipLine;\n\n/**\n * Returns the part of a multiline that intersects with the provided rectangular box.\n *\n * @param lines\n * @param x1 the left edge of the box\n * @param y1 the top edge of the box\n * @param x2 the right edge of the box\n * @param y2 the bottom edge of the box\n * @returns lines\n * @private\n */\nfunction clipLine(lines: Array<Array<Point>>, x1: number, y1: number, x2: number, y2: number): Array<Array<Point>> {\n    const clippedLines = [];\n\n    for (let l = 0; l < lines.length; l++) {\n        const line = lines[l];\n        let clippedLine;\n\n        for (let i = 0; i < line.length - 1; i++) {\n            let p0 = line[i];\n            let p1 = line[i + 1];\n\n\n            if (p0.x < x1 && p1.x < x1) {\n                continue;\n            } else if (p0.x < x1) {\n                p0 = new Point(x1, p0.y + (p1.y - p0.y) * ((x1 - p0.x) / (p1.x - p0.x)))._round();\n            } else if (p1.x < x1) {\n                p1 = new Point(x1, p0.y + (p1.y - p0.y) * ((x1 - p0.x) / (p1.x - p0.x)))._round();\n            }\n\n            if (p0.y < y1 && p1.y < y1) {\n                continue;\n            } else if (p0.y < y1) {\n                p0 = new Point(p0.x + (p1.x - p0.x) * ((y1 - p0.y) / (p1.y - p0.y)), y1)._round();\n            } else if (p1.y < y1) {\n                p1 = new Point(p0.x + (p1.x - p0.x) * ((y1 - p0.y) / (p1.y - p0.y)), y1)._round();\n            }\n\n            if (p0.x >= x2 && p1.x >= x2) {\n                continue;\n            } else if (p0.x >= x2) {\n                p0 = new Point(x2, p0.y + (p1.y - p0.y) * ((x2 - p0.x) / (p1.x - p0.x)))._round();\n            } else if (p1.x >= x2) {\n                p1 = new Point(x2, p0.y + (p1.y - p0.y) * ((x2 - p0.x) / (p1.x - p0.x)))._round();\n            }\n\n            if (p0.y >= y2 && p1.y >= y2) {\n                continue;\n            } else if (p0.y >= y2) {\n                p0 = new Point(p0.x + (p1.x - p0.x) * ((y2 - p0.y) / (p1.y - p0.y)), y2)._round();\n            } else if (p1.y >= y2) {\n                p1 = new Point(p0.x + (p1.x - p0.x) * ((y2 - p0.y) / (p1.y - p0.y)), y2)._round();\n            }\n\n            if (!clippedLine || !p0.equals(clippedLine[clippedLine.length - 1])) {\n                clippedLine = [p0];\n                clippedLines.push(clippedLine);\n            }\n\n            clippedLine.push(p1);\n        }\n    }\n\n    return clippedLines;\n}\n","// @flow\n\nimport { AlphaImage } from '../util/image';\nimport { register } from '../util/web_worker_transfer';\nimport potpack from 'potpack';\n\nimport type {GlyphMetrics, StyleGlyph} from '../style/style_glyph';\n\nconst padding = 1;\n\ntype Rect = {\n    x: number,\n    y: number,\n    w: number,\n    h: number\n};\n\nexport type GlyphPosition = {\n    rect: Rect,\n    metrics: GlyphMetrics\n};\n\nexport type GlyphPositions = { [string]: { [number]: GlyphPosition } }\n\nexport default class GlyphAtlas {\n    image: AlphaImage;\n    positions: GlyphPositions;\n\n    constructor(stacks: { [string]: { [number]: ?StyleGlyph } }) {\n        const positions = {};\n        const bins = [];\n\n        for (const stack in stacks) {\n            const glyphs = stacks[stack];\n            const stackPositions = positions[stack] = {};\n\n            for (const id in glyphs) {\n                const src = glyphs[+id];\n                if (!src || src.bitmap.width === 0 || src.bitmap.height === 0) continue;\n\n                const bin = {\n                    x: 0,\n                    y: 0,\n                    w: src.bitmap.width + 2 * padding,\n                    h: src.bitmap.height + 2 * padding\n                };\n                bins.push(bin);\n                stackPositions[id] = {rect: bin, metrics: src.metrics};\n            }\n        }\n\n        const {w, h} = potpack(bins);\n        const image = new AlphaImage({width: w || 1, height: h || 1});\n\n        for (const stack in stacks) {\n            const glyphs = stacks[stack];\n\n            for (const id in glyphs) {\n                const src = glyphs[+id];\n                if (!src || src.bitmap.width === 0 || src.bitmap.height === 0) continue;\n                const bin = positions[stack][id].rect;\n                AlphaImage.copy(src.bitmap, image, {x: 0, y: 0}, {x: bin.x + padding, y: bin.y + padding}, src.bitmap);\n            }\n        }\n\n        this.image = image;\n        this.positions = positions;\n    }\n}\n\nregister('GlyphAtlas', GlyphAtlas);\n","// @flow\n\nimport FeatureIndex from '../data/feature_index';\n\nimport { performSymbolLayout } from '../symbol/symbol_layout';\nimport { CollisionBoxArray } from '../data/array_types';\nimport DictionaryCoder from '../util/dictionary_coder';\nimport SymbolBucket from '../data/bucket/symbol_bucket';\nimport LineBucket from '../data/bucket/line_bucket';\nimport FillBucket from '../data/bucket/fill_bucket';\nimport FillExtrusionBucket from '../data/bucket/fill_extrusion_bucket';\nimport { warnOnce, mapObject, values } from '../util/util';\nimport assert from 'assert';\nimport ImageAtlas from '../render/image_atlas';\nimport GlyphAtlas from '../render/glyph_atlas';\nimport EvaluationParameters from '../style/evaluation_parameters';\nimport { OverscaledTileID } from './tile_id';\n\nimport type {Bucket} from '../data/bucket';\nimport type Actor from '../util/actor';\nimport type StyleLayer from '../style/style_layer';\nimport type StyleLayerIndex from '../style/style_layer_index';\nimport type {StyleImage} from '../style/style_image';\nimport type {StyleGlyph} from '../style/style_glyph';\nimport type {\n    WorkerTileParameters,\n    WorkerTileCallback,\n} from '../source/worker_source';\n\nclass WorkerTile {\n    tileID: OverscaledTileID;\n    uid: string;\n    zoom: number;\n    pixelRatio: number;\n    tileSize: number;\n    source: string;\n    overscaling: number;\n    showCollisionBoxes: boolean;\n    collectResourceTiming: boolean;\n    returnDependencies: boolean;\n\n    status: 'parsing' | 'done';\n    data: VectorTile;\n    collisionBoxArray: CollisionBoxArray;\n\n    abort: ?() => void;\n    reloadCallback: WorkerTileCallback;\n    vectorTile: VectorTile;\n\n    constructor(params: WorkerTileParameters) {\n        this.tileID = new OverscaledTileID(params.tileID.overscaledZ, params.tileID.wrap, params.tileID.canonical.z, params.tileID.canonical.x, params.tileID.canonical.y);\n        this.uid = params.uid;\n        this.zoom = params.zoom;\n        this.pixelRatio = params.pixelRatio;\n        this.tileSize = params.tileSize;\n        this.source = params.source;\n        this.overscaling = this.tileID.overscaleFactor();\n        this.showCollisionBoxes = params.showCollisionBoxes;\n        this.collectResourceTiming = !!params.collectResourceTiming;\n        this.returnDependencies = !!params.returnDependencies;\n    }\n\n    parse(data: VectorTile, layerIndex: StyleLayerIndex, actor: Actor, callback: WorkerTileCallback) {\n        this.status = 'parsing';\n        this.data = data;\n\n        this.collisionBoxArray = new CollisionBoxArray();\n        const sourceLayerCoder = new DictionaryCoder(Object.keys(data.layers).sort());\n\n        const featureIndex = new FeatureIndex(this.tileID);\n        featureIndex.bucketLayerIDs = [];\n\n        const buckets: {[string]: Bucket} = {};\n\n        const options = {\n            featureIndex,\n            iconDependencies: {},\n            patternDependencies: {},\n            glyphDependencies: {}\n        };\n\n        const layerFamilies = layerIndex.familiesBySource[this.source];\n        for (const sourceLayerId in layerFamilies) {\n            const sourceLayer = data.layers[sourceLayerId];\n            if (!sourceLayer) {\n                continue;\n            }\n\n            if (sourceLayer.version === 1) {\n                warnOnce(`Vector tile source \"${this.source}\" layer \"${sourceLayerId}\" ` +\n                    `does not use vector tile spec v2 and therefore may have some rendering errors.`);\n            }\n\n            const sourceLayerIndex = sourceLayerCoder.encode(sourceLayerId);\n            const features = [];\n            for (let index = 0; index < sourceLayer.length; index++) {\n                const feature = sourceLayer.feature(index);\n                features.push({ feature, index, sourceLayerIndex });\n            }\n\n            for (const family of layerFamilies[sourceLayerId]) {\n                const layer = family[0];\n\n                assert(layer.source === this.source);\n                if (layer.minzoom && this.zoom < Math.floor(layer.minzoom)) continue;\n                if (layer.maxzoom && this.zoom >= layer.maxzoom) continue;\n                if (layer.visibility === 'none') continue;\n\n                recalculateLayers(family, this.zoom);\n\n                const bucket = buckets[layer.id] = layer.createBucket({\n                    index: featureIndex.bucketLayerIDs.length,\n                    layers: family,\n                    zoom: this.zoom,\n                    pixelRatio: this.pixelRatio,\n                    overscaling: this.overscaling,\n                    collisionBoxArray: this.collisionBoxArray,\n                    sourceLayerIndex,\n                    sourceID: this.source\n                });\n\n                bucket.populate(features, options);\n                featureIndex.bucketLayerIDs.push(family.map((l) => l.id));\n            }\n        }\n\n        let error: ?Error;\n        let glyphMap: ?{[string]: {[number]: ?StyleGlyph}};\n        let iconMap: ?{[string]: StyleImage};\n        let patternMap: ?{[string]: StyleImage};\n\n        const stacks = mapObject(options.glyphDependencies, (glyphs) => Object.keys(glyphs).map(Number));\n        if (Object.keys(stacks).length) {\n            actor.send('getGlyphs', {uid: this.uid, stacks}, (err, result) => {\n                if (!error) {\n                    error = err;\n                    glyphMap = result;\n                    maybePrepare.call(this);\n                }\n            });\n        } else {\n            glyphMap = {};\n        }\n\n        const icons = Object.keys(options.iconDependencies);\n        if (icons.length) {\n            actor.send('getImages', {icons}, (err, result) => {\n                if (!error) {\n                    error = err;\n                    iconMap = result;\n                    maybePrepare.call(this);\n                }\n            });\n        } else {\n            iconMap = {};\n        }\n\n        const patterns = Object.keys(options.patternDependencies);\n        if (patterns.length) {\n            actor.send('getImages', {icons: patterns}, (err, result) => {\n                if (!error) {\n                    error = err;\n                    patternMap = result;\n                    maybePrepare.call(this);\n                }\n            });\n        } else {\n            patternMap = {};\n        }\n\n\n        maybePrepare.call(this);\n\n        function maybePrepare() {\n            if (error) {\n                return callback(error);\n            } else if (glyphMap && iconMap && patternMap) {\n                const glyphAtlas = new GlyphAtlas(glyphMap);\n                const imageAtlas = new ImageAtlas(iconMap, patternMap);\n\n                for (const key in buckets) {\n                    const bucket = buckets[key];\n                    if (bucket instanceof SymbolBucket) {\n                        recalculateLayers(bucket.layers, this.zoom);\n                        performSymbolLayout(bucket, glyphMap, glyphAtlas.positions, iconMap, imageAtlas.iconPositions, this.showCollisionBoxes);\n                    } else if (bucket.hasPattern &&\n                        (bucket instanceof LineBucket ||\n                         bucket instanceof FillBucket ||\n                         bucket instanceof FillExtrusionBucket)) {\n                        recalculateLayers(bucket.layers, this.zoom);\n                        bucket.addFeatures(options, imageAtlas.patternPositions);\n                    }\n                }\n\n                this.status = 'done';\n                callback(null, {\n                    buckets: values(buckets).filter(b => !b.isEmpty()),\n                    featureIndex,\n                    collisionBoxArray: this.collisionBoxArray,\n                    glyphAtlasImage: glyphAtlas.image,\n                    imageAtlas,\n                    // Only used for benchmarking:\n                    glyphMap: this.returnDependencies ? glyphMap : null,\n                    iconMap: this.returnDependencies ? iconMap : null,\n                    glyphPositions: this.returnDependencies ? glyphAtlas.positions : null\n                });\n            }\n        }\n    }\n}\n\nfunction recalculateLayers(layers: $ReadOnlyArray<StyleLayer>, zoom: number) {\n    // Layers are shared and may have been used by a WorkerTile with a different zoom.\n    const parameters = new EvaluationParameters(zoom);\n    for (const layer of layers) {\n        layer.recalculate(parameters);\n    }\n}\n\nexport default WorkerTile;\n","// @flow\n\nimport type {RequestParameters} from '../util/ajax';\n\n// Wraps performance to facilitate testing\n// Not incorporated into browser.js because the latter is poisonous when used outside the main thread\nconst performanceExists = typeof performance !== 'undefined';\nconst wrapper = {};\n\nwrapper.getEntriesByName = (url: string) => {\n    if (performanceExists && performance && performance.getEntriesByName)\n        return performance.getEntriesByName(url);\n    else\n        return false;\n};\n\nwrapper.mark = (name: string) => {\n    if (performanceExists && performance && performance.mark)\n        return performance.mark(name);\n    else\n        return false;\n};\n\nwrapper.measure = (name: string, startMark: string, endMark: string) => {\n    if (performanceExists && performance && performance.measure)\n        return performance.measure(name, startMark, endMark);\n    else\n        return false;\n};\n\nwrapper.clearMarks = (name: string) => {\n    if (performanceExists && performance && performance.clearMarks)\n        return performance.clearMarks(name);\n    else\n        return false;\n};\n\nwrapper.clearMeasures = (name: string) => {\n    if (performanceExists && performance && performance.clearMeasures)\n        return performance.clearMeasures(name);\n    else\n        return false;\n};\n\n/**\n * Safe wrapper for the performance resource timing API in web workers with graceful degradation\n *\n * @param {RequestParameters} request\n * @private\n */\nclass Performance {\n    _marks: {start: string, end: string, measure: string};\n\n    constructor (request: RequestParameters) {\n        this._marks = {\n            start: [request.url, 'start'].join('#'),\n            end: [request.url, 'end'].join('#'),\n            measure: request.url.toString()\n        };\n\n        wrapper.mark(this._marks.start);\n    }\n\n    finish() {\n        wrapper.mark(this._marks.end);\n        let resourceTimingData = wrapper.getEntriesByName(this._marks.measure);\n\n        // fallback if web worker implementation of perf.getEntriesByName returns empty\n        if (resourceTimingData.length === 0) {\n            wrapper.measure(this._marks.measure, this._marks.start, this._marks.end);\n            resourceTimingData = wrapper.getEntriesByName(this._marks.measure);\n\n            // cleanup\n            wrapper.clearMarks(this._marks.start);\n            wrapper.clearMarks(this._marks.end);\n            wrapper.clearMeasures(this._marks.measure);\n        }\n\n        return resourceTimingData;\n    }\n}\n\nwrapper.Performance = Performance;\n\nexport default wrapper;\n","// @flow\n\nimport { getArrayBuffer } from '../util/ajax';\n\nimport vt from '@mapbox/vector-tile';\nimport Protobuf from 'pbf';\nimport WorkerTile from './worker_tile';\nimport { extend } from '../util/util';\nimport performance from '../util/performance';\n\nimport type {\n    WorkerSource,\n    WorkerTileParameters,\n    WorkerTileCallback,\n    TileParameters\n} from '../source/worker_source';\n\nimport type {PerformanceResourceTiming} from '../types/performance_resource_timing';\nimport type Actor from '../util/actor';\nimport type StyleLayerIndex from '../style/style_layer_index';\nimport type {Callback} from '../types/callback';\n\nexport type LoadVectorTileResult = {\n    vectorTile: VectorTile;\n    rawData: ArrayBuffer;\n    expires?: any;\n    cacheControl?: any;\n    resourceTiming?: Array<PerformanceResourceTiming>;\n};\n\n/**\n * @callback LoadVectorDataCallback\n * @param error\n * @param vectorTile\n * @private\n */\nexport type LoadVectorDataCallback = Callback<?LoadVectorTileResult>;\n\nexport type AbortVectorData = () => void;\nexport type LoadVectorData = (params: WorkerTileParameters, callback: LoadVectorDataCallback) => ?AbortVectorData;\n\n/**\n * @private\n */\nfunction loadVectorTile(params: WorkerTileParameters, callback: LoadVectorDataCallback) {\n    const request = getArrayBuffer(params.request, (err: ?Error, data: ?ArrayBuffer, cacheControl: ?string, expires: ?string) => {\n        if (err) {\n            callback(err);\n        } else if (data) {\n            callback(null, {\n                vectorTile: new vt.VectorTile(new Protobuf(data)),\n                rawData: data,\n                cacheControl,\n                expires\n            });\n        }\n    });\n    return () => {\n        request.cancel();\n        callback();\n    };\n}\n\n/**\n * The {@link WorkerSource} implementation that supports {@link VectorTileSource}.\n * This class is designed to be easily reused to support custom source types\n * for data formats that can be parsed/converted into an in-memory VectorTile\n * representation.  To do so, create it with\n * `new VectorTileWorkerSource(actor, styleLayers, customLoadVectorDataFunction)`.\n *\n * @private\n */\nclass VectorTileWorkerSource implements WorkerSource {\n    actor: Actor;\n    layerIndex: StyleLayerIndex;\n    loadVectorData: LoadVectorData;\n    loading: { [string]: WorkerTile };\n    loaded: { [string]: WorkerTile };\n\n    /**\n     * @param [loadVectorData] Optional method for custom loading of a VectorTile\n     * object based on parameters passed from the main-thread Source. See\n     * {@link VectorTileWorkerSource#loadTile}. The default implementation simply\n     * loads the pbf at `params.url`.\n     */\n    constructor(actor: Actor, layerIndex: StyleLayerIndex, loadVectorData: ?LoadVectorData) {\n        this.actor = actor;\n        this.layerIndex = layerIndex;\n        this.loadVectorData = loadVectorData || loadVectorTile;\n        this.loading = {};\n        this.loaded = {};\n    }\n\n    /**\n     * Implements {@link WorkerSource#loadTile}. Delegates to\n     * {@link VectorTileWorkerSource#loadVectorData} (which by default expects\n     * a `params.url` property) for fetching and producing a VectorTile object.\n     */\n    loadTile(params: WorkerTileParameters, callback: WorkerTileCallback) {\n        const uid = params.uid;\n\n        if (!this.loading)\n            this.loading = {};\n\n        const perf = (params && params.request && params.request.collectResourceTiming) ?\n            new performance.Performance(params.request) : false;\n\n        const workerTile = this.loading[uid] = new WorkerTile(params);\n        workerTile.abort = this.loadVectorData(params, (err, response) => {\n            delete this.loading[uid];\n\n            if (err || !response) {\n                workerTile.status = 'done';\n                this.loaded[uid] = workerTile;\n                return callback(err);\n            }\n\n            const rawTileData = response.rawData;\n            const cacheControl = {};\n            if (response.expires) cacheControl.expires = response.expires;\n            if (response.cacheControl) cacheControl.cacheControl = response.cacheControl;\n\n            const resourceTiming = {};\n            if (perf) {\n                const resourceTimingData = perf.finish();\n                // it's necessary to eval the result of getEntriesByName() here via parse/stringify\n                // late evaluation in the main thread causes TypeError: illegal invocation\n                if (resourceTimingData)\n                    resourceTiming.resourceTiming = JSON.parse(JSON.stringify(resourceTimingData));\n            }\n\n            workerTile.vectorTile = response.vectorTile;\n            workerTile.parse(response.vectorTile, this.layerIndex, this.actor, (err, result) => {\n                if (err || !result) return callback(err);\n\n                // Transferring a copy of rawTileData because the worker needs to retain its copy.\n                callback(null, extend({rawTileData: rawTileData.slice(0)}, result, cacheControl, resourceTiming));\n            });\n\n            this.loaded = this.loaded || {};\n            this.loaded[uid] = workerTile;\n        });\n    }\n\n    /**\n     * Implements {@link WorkerSource#reloadTile}.\n     */\n    reloadTile(params: WorkerTileParameters, callback: WorkerTileCallback) {\n        const loaded = this.loaded,\n            uid = params.uid,\n            vtSource = this;\n        if (loaded && loaded[uid]) {\n            const workerTile = loaded[uid];\n            workerTile.showCollisionBoxes = params.showCollisionBoxes;\n\n            const done = (err, data) => {\n                const reloadCallback = workerTile.reloadCallback;\n                if (reloadCallback) {\n                    delete workerTile.reloadCallback;\n                    workerTile.parse(workerTile.vectorTile, vtSource.layerIndex, vtSource.actor, reloadCallback);\n                }\n                callback(err, data);\n            };\n\n            if (workerTile.status === 'parsing') {\n                workerTile.reloadCallback = done;\n            } else if (workerTile.status === 'done') {\n                // if there was no vector tile data on the initial load, don't try and re-parse tile\n                if (workerTile.vectorTile) {\n                    workerTile.parse(workerTile.vectorTile, this.layerIndex, this.actor, done);\n                } else {\n                    done();\n                }\n            }\n        }\n    }\n\n    /**\n     * Implements {@link WorkerSource#abortTile}.\n     *\n     * @param params\n     * @param params.uid The UID for this tile.\n     */\n    abortTile(params: TileParameters, callback: WorkerTileCallback) {\n        const loading = this.loading,\n            uid = params.uid;\n        if (loading && loading[uid] && loading[uid].abort) {\n            loading[uid].abort();\n            delete loading[uid];\n        }\n        callback();\n    }\n\n    /**\n     * Implements {@link WorkerSource#removeTile}.\n     *\n     * @param params\n     * @param params.uid The UID for this tile.\n     */\n    removeTile(params: TileParameters, callback: WorkerTileCallback) {\n        const loaded = this.loaded,\n            uid = params.uid;\n        if (loaded && loaded[uid]) {\n            delete loaded[uid];\n        }\n        callback();\n    }\n}\n\nexport default VectorTileWorkerSource;\n","// @flow\n\nimport DEMData from '../data/dem_data';\n\nimport type Actor from '../util/actor';\nimport type {\n    WorkerDEMTileParameters,\n    WorkerDEMTileCallback,\n    TileParameters\n} from './worker_source';\n\n\nclass RasterDEMTileWorkerSource {\n    actor: Actor;\n    loaded: {[string]: DEMData};\n\n    constructor() {\n        this.loaded = {};\n    }\n\n    loadTile(params: WorkerDEMTileParameters, callback: WorkerDEMTileCallback) {\n        const {uid, encoding, rawImageData} = params;\n        const dem = new DEMData(uid, rawImageData, encoding);\n\n        this.loaded = this.loaded || {};\n        this.loaded[uid] = dem;\n        callback(null, dem);\n    }\n\n    removeTile(params: TileParameters) {\n        const loaded = this.loaded,\n            uid = params.uid;\n        if (loaded && loaded[uid]) {\n            delete loaded[uid];\n        }\n    }\n}\n\nexport default RasterDEMTileWorkerSource;\n","module.exports.RADIUS = 6378137;\nmodule.exports.FLATTENING = 1/298.257223563;\nmodule.exports.POLAR_RADIUS = 6356752.3142;\n","var wgs84 = require('wgs84');\n\nmodule.exports.geometry = geometry;\nmodule.exports.ring = ringArea;\n\nfunction geometry(_) {\n    var area = 0, i;\n    switch (_.type) {\n        case 'Polygon':\n            return polygonArea(_.coordinates);\n        case 'MultiPolygon':\n            for (i = 0; i < _.coordinates.length; i++) {\n                area += polygonArea(_.coordinates[i]);\n            }\n            return area;\n        case 'Point':\n        case 'MultiPoint':\n        case 'LineString':\n        case 'MultiLineString':\n            return 0;\n        case 'GeometryCollection':\n            for (i = 0; i < _.geometries.length; i++) {\n                area += geometry(_.geometries[i]);\n            }\n            return area;\n    }\n}\n\nfunction polygonArea(coords) {\n    var area = 0;\n    if (coords && coords.length > 0) {\n        area += Math.abs(ringArea(coords[0]));\n        for (var i = 1; i < coords.length; i++) {\n            area -= Math.abs(ringArea(coords[i]));\n        }\n    }\n    return area;\n}\n\n/**\n * Calculate the approximate area of the polygon were it projected onto\n *     the earth.  Note that this area will be positive if ring is oriented\n *     clockwise, otherwise it will be negative.\n *\n * Reference:\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for\n *     Polygons on a Sphere\", JPL Publication 07-03, Jet Propulsion\n *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409\n *\n * Returns:\n * {float} The approximate signed geodesic area of the polygon in square\n *     meters.\n */\n\nfunction ringArea(coords) {\n    var p1, p2, p3, lowerIndex, middleIndex, upperIndex, i,\n    area = 0,\n    coordsLength = coords.length;\n\n    if (coordsLength > 2) {\n        for (i = 0; i < coordsLength; i++) {\n            if (i === coordsLength - 2) {// i = N-2\n                lowerIndex = coordsLength - 2;\n                middleIndex = coordsLength -1;\n                upperIndex = 0;\n            } else if (i === coordsLength - 1) {// i = N-1\n                lowerIndex = coordsLength - 1;\n                middleIndex = 0;\n                upperIndex = 1;\n            } else { // i = 0 to N-3\n                lowerIndex = i;\n                middleIndex = i+1;\n                upperIndex = i+2;\n            }\n            p1 = coords[lowerIndex];\n            p2 = coords[middleIndex];\n            p3 = coords[upperIndex];\n            area += ( rad(p3[0]) - rad(p1[0]) ) * Math.sin( rad(p2[1]));\n        }\n\n        area = area * wgs84.RADIUS * wgs84.RADIUS / 2;\n    }\n\n    return area;\n}\n\nfunction rad(_) {\n    return _ * Math.PI / 180;\n}","var geojsonArea = require('@mapbox/geojson-area');\n\nmodule.exports = rewind;\n\nfunction rewind(gj, outer) {\n    switch ((gj && gj.type) || null) {\n        case 'FeatureCollection':\n            gj.features = gj.features.map(curryOuter(rewind, outer));\n            return gj;\n        case 'Feature':\n            gj.geometry = rewind(gj.geometry, outer);\n            return gj;\n        case 'Polygon':\n        case 'MultiPolygon':\n            return correct(gj, outer);\n        default:\n            return gj;\n    }\n}\n\nfunction curryOuter(a, b) {\n    return function(_) { return a(_, b); };\n}\n\nfunction correct(_, outer) {\n    if (_.type === 'Polygon') {\n        _.coordinates = correctRings(_.coordinates, outer);\n    } else if (_.type === 'MultiPolygon') {\n        _.coordinates = _.coordinates.map(curryOuter(correctRings, outer));\n    }\n    return _;\n}\n\nfunction correctRings(_, outer) {\n    outer = !!outer;\n    _[0] = wind(_[0], outer);\n    for (var i = 1; i < _.length; i++) {\n        _[i] = wind(_[i], !outer);\n    }\n    return _;\n}\n\nfunction wind(_, dir) {\n    return cw(_) === dir ? _ : _.reverse();\n}\n\nfunction cw(_) {\n    return geojsonArea.ring(_) >= 0;\n}\n","// @flow\n\nimport Point from '@mapbox/point-geometry';\n\nimport mvt from '@mapbox/vector-tile';\nconst toGeoJSON = mvt.VectorTileFeature.prototype.toGeoJSON;\nimport EXTENT from '../data/extent';\n\n// The feature type used by geojson-vt and supercluster. Should be extracted to\n// global type and used in module definitions for those two modules.\ntype Feature = {\n    type: 1,\n    id: mixed,\n    tags: {[string]: string | number | boolean},\n    geometry: Array<[number, number]>,\n} | {\n    type: 2 | 3,\n    id: mixed,\n    tags: {[string]: string | number | boolean},\n    geometry: Array<Array<[number, number]>>,\n}\n\nclass FeatureWrapper implements VectorTileFeature {\n    _feature: Feature;\n\n    extent: number;\n    type: 1 | 2 | 3;\n    id: number;\n    properties: {[string]: string | number | boolean};\n\n    constructor(feature: Feature) {\n        this._feature = feature;\n\n        this.extent = EXTENT;\n        this.type = feature.type;\n        this.properties = feature.tags;\n\n        // If the feature has a top-level `id` property, copy it over, but only\n        // if it can be coerced to an integer, because this wrapper is used for\n        // serializing geojson feature data into vector tile PBF data, and the\n        // vector tile spec only supports integer values for feature ids --\n        // allowing non-integer values here results in a non-compliant PBF\n        // that causes an exception when it is parsed with vector-tile-js\n        if ('id' in feature && !isNaN(feature.id)) {\n            this.id = parseInt(feature.id, 10);\n        }\n    }\n\n    loadGeometry() {\n        if (this._feature.type === 1) {\n            const geometry = [];\n            for (const point of this._feature.geometry) {\n                geometry.push([new Point(point[0], point[1])]);\n            }\n            return geometry;\n        } else {\n            const geometry = [];\n            for (const ring of this._feature.geometry) {\n                const newRing = [];\n                for (const point of ring) {\n                    newRing.push(new Point(point[0], point[1]));\n                }\n                geometry.push(newRing);\n            }\n            return geometry;\n        }\n    }\n\n    toGeoJSON(x: number, y: number, z: number) {\n        return toGeoJSON.call(this, x, y, z);\n    }\n}\n\nclass GeoJSONWrapper implements VectorTile, VectorTileLayer {\n    layers: {[string]: VectorTileLayer};\n    name: string;\n    extent: number;\n    length: number;\n    _features: Array<Feature>;\n\n    constructor(features: Array<Feature>) {\n        this.layers = { '_geojsonTileLayer': this };\n        this.name = '_geojsonTileLayer';\n        this.extent = EXTENT;\n        this.length = features.length;\n        this._features = features;\n    }\n\n    feature(i: number): VectorTileFeature {\n        return new FeatureWrapper(this._features[i]);\n    }\n}\n\nexport default GeoJSONWrapper;\n","'use strict'\n\nvar Point = require('@mapbox/point-geometry')\nvar VectorTileFeature = require('@mapbox/vector-tile').VectorTileFeature\n\nmodule.exports = GeoJSONWrapper\n\n// conform to vectortile api\nfunction GeoJSONWrapper (features, options) {\n  this.options = options || {}\n  this.features = features\n  this.length = features.length\n}\n\nGeoJSONWrapper.prototype.feature = function (i) {\n  return new FeatureWrapper(this.features[i], this.options.extent)\n}\n\nfunction FeatureWrapper (feature, extent) {\n  this.id = typeof feature.id === 'number' ? feature.id : undefined\n  this.type = feature.type\n  this.rawGeometry = feature.type === 1 ? [feature.geometry] : feature.geometry\n  this.properties = feature.tags\n  this.extent = extent || 4096\n}\n\nFeatureWrapper.prototype.loadGeometry = function () {\n  var rings = this.rawGeometry\n  this.geometry = []\n\n  for (var i = 0; i < rings.length; i++) {\n    var ring = rings[i]\n    var newRing = []\n    for (var j = 0; j < ring.length; j++) {\n      newRing.push(new Point(ring[j][0], ring[j][1]))\n    }\n    this.geometry.push(newRing)\n  }\n  return this.geometry\n}\n\nFeatureWrapper.prototype.bbox = function () {\n  if (!this.geometry) this.loadGeometry()\n\n  var rings = this.geometry\n  var x1 = Infinity\n  var x2 = -Infinity\n  var y1 = Infinity\n  var y2 = -Infinity\n\n  for (var i = 0; i < rings.length; i++) {\n    var ring = rings[i]\n\n    for (var j = 0; j < ring.length; j++) {\n      var coord = ring[j]\n\n      x1 = Math.min(x1, coord.x)\n      x2 = Math.max(x2, coord.x)\n      y1 = Math.min(y1, coord.y)\n      y2 = Math.max(y2, coord.y)\n    }\n  }\n\n  return [x1, y1, x2, y2]\n}\n\nFeatureWrapper.prototype.toGeoJSON = VectorTileFeature.prototype.toGeoJSON\n","var Pbf = require('pbf')\nvar GeoJSONWrapper = require('./lib/geojson_wrapper')\n\nmodule.exports = fromVectorTileJs\nmodule.exports.fromVectorTileJs = fromVectorTileJs\nmodule.exports.fromGeojsonVt = fromGeojsonVt\nmodule.exports.GeoJSONWrapper = GeoJSONWrapper\n\n/**\n * Serialize a vector-tile-js-created tile to pbf\n *\n * @param {Object} tile\n * @return {Buffer} uncompressed, pbf-serialized tile data\n */\nfunction fromVectorTileJs (tile) {\n  var out = new Pbf()\n  writeTile(tile, out)\n  return out.finish()\n}\n\n/**\n * Serialized a geojson-vt-created tile to pbf.\n *\n * @param {Object} layers - An object mapping layer names to geojson-vt-created vector tile objects\n * @param {Object} [options] - An object specifying the vector-tile specification version and extent that were used to create `layers`.\n * @param {Number} [options.version=1] - Version of vector-tile spec used\n * @param {Number} [options.extent=4096] - Extent of the vector tile\n * @return {Buffer} uncompressed, pbf-serialized tile data\n */\nfunction fromGeojsonVt (layers, options) {\n  options = options || {}\n  var l = {}\n  for (var k in layers) {\n    l[k] = new GeoJSONWrapper(layers[k].features, options)\n    l[k].name = k\n    l[k].version = options.version\n    l[k].extent = options.extent\n  }\n  return fromVectorTileJs({layers: l})\n}\n\nfunction writeTile (tile, pbf) {\n  for (var key in tile.layers) {\n    pbf.writeMessage(3, writeLayer, tile.layers[key])\n  }\n}\n\nfunction writeLayer (layer, pbf) {\n  pbf.writeVarintField(15, layer.version || 1)\n  pbf.writeStringField(1, layer.name || '')\n  pbf.writeVarintField(5, layer.extent || 4096)\n\n  var i\n  var context = {\n    keys: [],\n    values: [],\n    keycache: {},\n    valuecache: {}\n  }\n\n  for (i = 0; i < layer.length; i++) {\n    context.feature = layer.feature(i)\n    pbf.writeMessage(2, writeFeature, context)\n  }\n\n  var keys = context.keys\n  for (i = 0; i < keys.length; i++) {\n    pbf.writeStringField(3, keys[i])\n  }\n\n  var values = context.values\n  for (i = 0; i < values.length; i++) {\n    pbf.writeMessage(4, writeValue, values[i])\n  }\n}\n\nfunction writeFeature (context, pbf) {\n  var feature = context.feature\n\n  if (feature.id !== undefined) {\n    pbf.writeVarintField(1, feature.id)\n  }\n\n  pbf.writeMessage(2, writeProperties, context)\n  pbf.writeVarintField(3, feature.type)\n  pbf.writeMessage(4, writeGeometry, feature)\n}\n\nfunction writeProperties (context, pbf) {\n  var feature = context.feature\n  var keys = context.keys\n  var values = context.values\n  var keycache = context.keycache\n  var valuecache = context.valuecache\n\n  for (var key in feature.properties) {\n    var keyIndex = keycache[key]\n    if (typeof keyIndex === 'undefined') {\n      keys.push(key)\n      keyIndex = keys.length - 1\n      keycache[key] = keyIndex\n    }\n    pbf.writeVarint(keyIndex)\n\n    var value = feature.properties[key]\n    var type = typeof value\n    if (type !== 'string' && type !== 'boolean' && type !== 'number') {\n      value = JSON.stringify(value)\n    }\n    var valueKey = type + ':' + value\n    var valueIndex = valuecache[valueKey]\n    if (typeof valueIndex === 'undefined') {\n      values.push(value)\n      valueIndex = values.length - 1\n      valuecache[valueKey] = valueIndex\n    }\n    pbf.writeVarint(valueIndex)\n  }\n}\n\nfunction command (cmd, length) {\n  return (length << 3) + (cmd & 0x7)\n}\n\nfunction zigzag (num) {\n  return (num << 1) ^ (num >> 31)\n}\n\nfunction writeGeometry (feature, pbf) {\n  var geometry = feature.loadGeometry()\n  var type = feature.type\n  var x = 0\n  var y = 0\n  var rings = geometry.length\n  for (var r = 0; r < rings; r++) {\n    var ring = geometry[r]\n    var count = 1\n    if (type === 1) {\n      count = ring.length\n    }\n    pbf.writeVarint(command(1, count)) // moveto\n    // do not write polygon closing path as lineto\n    var lineCount = type === 3 ? ring.length - 1 : ring.length\n    for (var i = 0; i < lineCount; i++) {\n      if (i === 1 && type !== 1) {\n        pbf.writeVarint(command(2, lineCount - 1)) // lineto\n      }\n      var dx = ring[i].x - x\n      var dy = ring[i].y - y\n      pbf.writeVarint(zigzag(dx))\n      pbf.writeVarint(zigzag(dy))\n      x += dx\n      y += dy\n    }\n    if (type === 3) {\n      pbf.writeVarint(command(7, 1)) // closepath\n    }\n  }\n}\n\nfunction writeValue (value, pbf) {\n  var type = typeof value\n  if (type === 'string') {\n    pbf.writeStringField(1, value)\n  } else if (type === 'boolean') {\n    pbf.writeBooleanField(7, value)\n  } else if (type === 'number') {\n    if (value % 1 !== 0) {\n      pbf.writeDoubleField(3, value)\n    } else if (value < 0) {\n      pbf.writeSVarintField(6, value)\n    } else {\n      pbf.writeVarintField(5, value)\n    }\n  }\n}\n","// @flow\n\nimport { create as createSource } from './source';\n\nimport Tile from './tile';\nimport { Event, ErrorEvent, Evented } from '../util/evented';\nimport TileCache from './tile_cache';\nimport MercatorCoordinate from '../geo/mercator_coordinate';\nimport { keysDifference } from '../util/util';\nimport EXTENT from '../data/extent';\nimport Context from '../gl/context';\nimport Point from '@mapbox/point-geometry';\nimport browser from '../util/browser';\nimport { OverscaledTileID } from './tile_id';\nimport assert from 'assert';\nimport SourceFeatureState from './source_state';\n\nimport type {Source} from './source';\nimport type Map from '../ui/map';\nimport type Style from '../style/style';\nimport type Dispatcher from '../util/dispatcher';\nimport type Transform from '../geo/transform';\nimport type {TileState} from './tile';\nimport type {Callback} from '../types/callback';\nimport type {SourceSpecification} from '../style-spec/types';\n\n/**\n * `SourceCache` is responsible for\n *\n *  - creating an instance of `Source`\n *  - forwarding events from `Source`\n *  - caching tiles loaded from an instance of `Source`\n *  - loading the tiles needed to render a given viewport\n *  - unloading the cached tiles not needed to render a given viewport\n *\n * @private\n */\nclass SourceCache extends Evented {\n    id: string;\n    dispatcher: Dispatcher;\n    map: Map;\n    style: Style;\n\n    _source: Source;\n    _sourceLoaded: boolean;\n    _sourceErrored: boolean;\n    _tiles: {[any]: Tile};\n    _prevLng: number | void;\n    _cache: TileCache;\n    _timers: {[any]: TimeoutID};\n    _cacheTimers: {[any]: TimeoutID};\n    _maxTileCacheSize: ?number;\n    _paused: boolean;\n    _shouldReloadOnResume: boolean;\n    _coveredTiles: {[any]: boolean};\n    transform: Transform;\n    _isIdRenderable: (id: number, symbolLayer?: boolean) => boolean;\n    used: boolean;\n    _state: SourceFeatureState;\n\n    static maxUnderzooming: number;\n    static maxOverzooming: number;\n\n    constructor(id: string, options: SourceSpecification, dispatcher: Dispatcher) {\n        super();\n        this.id = id;\n        this.dispatcher = dispatcher;\n\n        this.on('data', (e) => {\n            // this._sourceLoaded signifies that the TileJSON is loaded if applicable.\n            // if the source type does not come with a TileJSON, the flag signifies the\n            // source data has loaded (i.e geojson has been tiled on the worker and is ready)\n            if (e.dataType === 'source' && e.sourceDataType === 'metadata') this._sourceLoaded = true;\n\n            // for sources with mutable data, this event fires when the underlying data\n            // to a source is changed. (i.e. GeoJSONSource#setData and ImageSource#serCoordinates)\n            if (this._sourceLoaded && !this._paused && e.dataType === \"source\" && e.sourceDataType === 'content') {\n                this.reload();\n                if (this.transform) {\n                    this.update(this.transform);\n                }\n            }\n        });\n\n        this.on('error', () => {\n            this._sourceErrored = true;\n        });\n\n        this._source = createSource(id, options, dispatcher, this);\n\n        this._tiles = {};\n        this._cache = new TileCache(0, this._unloadTile.bind(this));\n        this._timers = {};\n        this._cacheTimers = {};\n        this._maxTileCacheSize = null;\n\n        this._coveredTiles = {};\n        this._state = new SourceFeatureState();\n    }\n\n    onAdd(map: Map) {\n        this.map = map;\n        this._maxTileCacheSize = map ? map._maxTileCacheSize : null;\n        if (this._source && this._source.onAdd) {\n            this._source.onAdd(map);\n        }\n    }\n\n    onRemove(map: Map) {\n        if (this._source && this._source.onRemove) {\n            this._source.onRemove(map);\n        }\n    }\n\n    /**\n     * Return true if no tile data is pending, tiles will not change unless\n     * an additional API call is received.\n     */\n    loaded(): boolean {\n        if (this._sourceErrored) { return true; }\n        if (!this._sourceLoaded) { return false; }\n        for (const t in this._tiles) {\n            const tile = this._tiles[t];\n            if (tile.state !== 'loaded' && tile.state !== 'errored')\n                return false;\n        }\n        return true;\n    }\n\n    getSource(): Source {\n        return this._source;\n    }\n\n    pause() {\n        this._paused = true;\n    }\n\n    resume() {\n        if (!this._paused) return;\n        const shouldReload = this._shouldReloadOnResume;\n        this._paused = false;\n        this._shouldReloadOnResume = false;\n        if (shouldReload) this.reload();\n        if (this.transform) this.update(this.transform);\n    }\n\n    _loadTile(tile: Tile, callback: Callback<void>) {\n        return this._source.loadTile(tile, callback);\n    }\n\n    _unloadTile(tile: Tile) {\n        if (this._source.unloadTile)\n            return this._source.unloadTile(tile, () => {});\n    }\n\n    _abortTile(tile: Tile) {\n        if (this._source.abortTile)\n            return this._source.abortTile(tile, () => {});\n    }\n\n    serialize() {\n        return this._source.serialize();\n    }\n\n    prepare(context: Context) {\n        if  (this._source.prepare) {\n            this._source.prepare();\n        }\n\n        this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);\n        for (const i in this._tiles) {\n            this._tiles[i].upload(context);\n        }\n    }\n\n    /**\n     * Return all tile ids ordered with z-order, and cast to numbers\n     */\n    getIds(): Array<number> {\n        return Object.keys(this._tiles).map(Number).sort(compareKeyZoom);\n    }\n\n    getRenderableIds(symbolLayer?: boolean): Array<number> {\n        const ids = [];\n        for (const id in this._tiles) {\n            if (this._isIdRenderable(+id, symbolLayer)) ids.push(+id);\n        }\n        if (symbolLayer) {\n            return ids.sort((a_, b_) => {\n                const a = this._tiles[a_].tileID;\n                const b = this._tiles[b_].tileID;\n                const rotatedA = (new Point(a.canonical.x, a.canonical.y))._rotate(this.transform.angle);\n                const rotatedB = (new Point(b.canonical.x, b.canonical.y))._rotate(this.transform.angle);\n                return a.overscaledZ - b.overscaledZ || rotatedB.y - rotatedA.y || rotatedB.x - rotatedA.x;\n            });\n        }\n        return ids.sort(compareKeyZoom);\n    }\n\n    hasRenderableParent(tileID: OverscaledTileID) {\n        const parentTile = this.findLoadedParent(tileID, 0);\n        if (parentTile) {\n            return this._isIdRenderable(parentTile.tileID.key);\n        }\n        return false;\n    }\n\n    _isIdRenderable(id: number, symbolLayer?: boolean) {\n        return this._tiles[id] && this._tiles[id].hasData() &&\n            !this._coveredTiles[id] && (symbolLayer || !this._tiles[id].holdingForFade());\n    }\n\n    reload() {\n        if (this._paused) {\n            this._shouldReloadOnResume = true;\n            return;\n        }\n\n        this._cache.reset();\n\n        for (const i in this._tiles) {\n            if (this._tiles[i].state !== \"errored\") this._reloadTile(i, 'reloading');\n        }\n    }\n\n    _reloadTile(id: string | number, state: TileState) {\n        const tile = this._tiles[id];\n\n        // this potentially does not address all underlying\n        // issues https://github.com/mapbox/mapbox-gl-js/issues/4252\n        // - hard to tell without repro steps\n        if (!tile) return;\n\n        // The difference between \"loading\" tiles and \"reloading\" or \"expired\"\n        // tiles is that \"reloading\"/\"expired\" tiles are \"renderable\".\n        // Therefore, a \"loading\" tile cannot become a \"reloading\" tile without\n        // first becoming a \"loaded\" tile.\n        if (tile.state !== 'loading') {\n            tile.state = state;\n        }\n\n        this._loadTile(tile, this._tileLoaded.bind(this, tile, id, state));\n    }\n\n    _tileLoaded(tile: Tile, id: string | number, previousState: TileState, err: ?Error) {\n        if (err) {\n            tile.state = 'errored';\n            if ((err: any).status !== 404) this._source.fire(new ErrorEvent(err, {tile}));\n            // continue to try loading parent/children tiles if a tile doesn't exist (404)\n            else this.update(this.transform);\n            return;\n        }\n\n        tile.timeAdded = browser.now();\n        if (previousState === 'expired') tile.refreshedUponExpiration = true;\n        this._setTileReloadTimer(id, tile);\n        if (this.getSource().type === 'raster-dem' && tile.dem) this._backfillDEM(tile);\n        this._state.initializeTileState(tile, this.map ? this.map.painter : null);\n\n        this._source.fire(new Event('data', {dataType: 'source', tile, coord: tile.tileID}));\n    }\n\n    /**\n    * For raster terrain source, backfill DEM to eliminate visible tile boundaries\n    * @private\n    */\n    _backfillDEM(tile: Tile) {\n        const renderables = this.getRenderableIds();\n        for (let i = 0; i < renderables.length; i++) {\n            const borderId = renderables[i];\n            if (tile.neighboringTiles && tile.neighboringTiles[borderId]) {\n                const borderTile = this.getTileByID(borderId);\n                fillBorder(tile, borderTile);\n                fillBorder(borderTile, tile);\n            }\n        }\n\n        function fillBorder(tile, borderTile) {\n            tile.needsHillshadePrepare = true;\n            let dx = borderTile.tileID.canonical.x - tile.tileID.canonical.x;\n            const dy = borderTile.tileID.canonical.y - tile.tileID.canonical.y;\n            const dim = Math.pow(2, tile.tileID.canonical.z);\n            const borderId = borderTile.tileID.key;\n            if (dx === 0 && dy === 0) return;\n\n            if (Math.abs(dy) > 1) {\n                return;\n            }\n            if (Math.abs(dx) > 1) {\n                // Adjust the delta coordinate for world wraparound.\n                if (Math.abs(dx + dim) === 1) {\n                    dx += dim;\n                } else if (Math.abs(dx - dim) === 1) {\n                    dx -= dim;\n                }\n            }\n            if (!borderTile.dem || !tile.dem) return;\n            tile.dem.backfillBorder(borderTile.dem, dx, dy);\n            if (tile.neighboringTiles && tile.neighboringTiles[borderId])\n                tile.neighboringTiles[borderId].backfilled = true;\n        }\n    }\n    /**\n     * Get a specific tile by TileID\n     */\n    getTile(tileID: OverscaledTileID): Tile {\n        return this.getTileByID(tileID.key);\n    }\n\n    /**\n     * Get a specific tile by id\n     */\n    getTileByID(id: string | number): Tile {\n        return this._tiles[id];\n    }\n\n    /**\n     * get the zoom level adjusted for the difference in map and source tilesizes\n     */\n    getZoom(transform: Transform): number {\n        return transform.zoom + transform.scaleZoom(transform.tileSize / this._source.tileSize);\n    }\n\n    /**\n     * For a given set of tiles, retain children that are loaded and have a zoom\n     * between `zoom` (exclusive) and `maxCoveringZoom` (inclusive)\n     */\n    _retainLoadedChildren(\n        idealTiles: {[any]: OverscaledTileID},\n        zoom: number,\n        maxCoveringZoom: number,\n        retain: {[any]: OverscaledTileID}\n    ) {\n        for (const id in this._tiles) {\n            let tile = this._tiles[id];\n\n            // only consider renderable tiles up to maxCoveringZoom\n            if (retain[id] ||\n                !tile.hasData() ||\n                tile.tileID.overscaledZ <= zoom ||\n                tile.tileID.overscaledZ > maxCoveringZoom\n            ) continue;\n\n            // loop through parents and retain the topmost loaded one if found\n            let topmostLoadedID = tile.tileID;\n            while (tile && tile.tileID.overscaledZ > zoom + 1) {\n                const parentID = tile.tileID.scaledTo(tile.tileID.overscaledZ - 1);\n\n                tile = this._tiles[parentID.key];\n\n                if (tile && tile.hasData()) {\n                    topmostLoadedID = parentID;\n                }\n            }\n\n            // loop through ancestors of the topmost loaded child to see if there's one that needed it\n            let tileID = topmostLoadedID;\n            while (tileID.overscaledZ > zoom) {\n                tileID = tileID.scaledTo(tileID.overscaledZ - 1);\n\n                if (idealTiles[tileID.key]) {\n                    // found a parent that needed a loaded child; retain that child\n                    retain[topmostLoadedID.key] = topmostLoadedID;\n                    break;\n                }\n            }\n        }\n    }\n\n    /**\n     * Find a loaded parent of the given tile (up to minCoveringZoom)\n     */\n    findLoadedParent(tileID: OverscaledTileID, minCoveringZoom: number): ?Tile {\n        for (let z = tileID.overscaledZ - 1; z >= minCoveringZoom; z--) {\n            const parent = tileID.scaledTo(z);\n            if (!parent) return;\n            const id = String(parent.key);\n            const tile = this._tiles[id];\n            if (tile && tile.hasData()) {\n                return tile;\n            }\n            if (this._cache.has(parent)) {\n                return this._cache.get(parent);\n            }\n        }\n    }\n\n    /**\n     * Resizes the tile cache based on the current viewport's size\n     * or the maxTileCacheSize option passed during map creation\n     *\n     * Larger viewports use more tiles and need larger caches. Larger viewports\n     * are more likely to be found on devices with more memory and on pages where\n     * the map is more important.\n     */\n    updateCacheSize(transform: Transform) {\n        const widthInTiles = Math.ceil(transform.width / this._source.tileSize) + 1;\n        const heightInTiles = Math.ceil(transform.height / this._source.tileSize) + 1;\n        const approxTilesInView = widthInTiles * heightInTiles;\n        const commonZoomRange = 5;\n\n        const viewDependentMaxSize = Math.floor(approxTilesInView * commonZoomRange);\n        const maxSize = typeof this._maxTileCacheSize === 'number' ? Math.min(this._maxTileCacheSize, viewDependentMaxSize) : viewDependentMaxSize;\n\n        this._cache.setMaxSize(maxSize);\n    }\n\n    handleWrapJump(lng: number) {\n        // On top of the regular z/x/y values, TileIDs have a `wrap` value that specify\n        // which cppy of the world the tile belongs to. For example, at `lng: 10` you\n        // might render z/x/y/0 while at `lng: 370` you would render z/x/y/1.\n        //\n        // When lng values get wrapped (going from `lng: 370` to `long: 10`) you expect\n        // to see the same thing on the screen (370 degrees and 10 degrees is the same\n        // place in the world) but all the TileIDs will have different wrap values.\n        //\n        // In order to make this transition seamless, we calculate the rounded difference of\n        // \"worlds\" between the last frame and the current frame. If the map panned by\n        // a world, then we can assign all the tiles new TileIDs with updated wrap values.\n        // For example, assign z/x/y/1 a new id: z/x/y/0. It is the same tile, just rendered\n        // in a different position.\n        //\n        // This enables us to reuse the tiles at more ideal locations and prevent flickering.\n        const prevLng = this._prevLng === undefined ? lng : this._prevLng;\n        const lngDifference = lng - prevLng;\n        const worldDifference = lngDifference / 360;\n        const wrapDelta = Math.round(worldDifference);\n        this._prevLng = lng;\n\n        if (wrapDelta) {\n            const tiles = {};\n            for (const key in this._tiles) {\n                const tile = this._tiles[key];\n                tile.tileID = tile.tileID.unwrapTo(tile.tileID.wrap + wrapDelta);\n                tiles[tile.tileID.key] = tile;\n            }\n            this._tiles = tiles;\n\n            // Reset tile reload timers\n            for (const id in this._timers) {\n                clearTimeout(this._timers[id]);\n                delete this._timers[id];\n            }\n            for (const id in this._tiles) {\n                const tile = this._tiles[id];\n                this._setTileReloadTimer(id, tile);\n            }\n        }\n    }\n\n    /**\n     * Removes tiles that are outside the viewport and adds new tiles that\n     * are inside the viewport.\n     */\n    update(transform: Transform) {\n        this.transform = transform;\n        if (!this._sourceLoaded || this._paused) { return; }\n\n        this.updateCacheSize(transform);\n        this.handleWrapJump(this.transform.center.lng);\n\n        // Covered is a list of retained tiles who's areas are fully covered by other,\n        // better, retained tiles. They are not drawn separately.\n        this._coveredTiles = {};\n\n        let idealTileIDs;\n        if (!this.used) {\n            idealTileIDs = [];\n        } else if (this._source.tileID) {\n            idealTileIDs = transform.getVisibleUnwrappedCoordinates(this._source.tileID)\n                .map((unwrapped) => new OverscaledTileID(unwrapped.canonical.z, unwrapped.wrap, unwrapped.canonical.z, unwrapped.canonical.x, unwrapped.canonical.y));\n        } else {\n            idealTileIDs = transform.coveringTiles({\n                tileSize: this._source.tileSize,\n                minzoom: this._source.minzoom,\n                maxzoom: this._source.maxzoom,\n                roundZoom: this._source.roundZoom,\n                reparseOverscaled: this._source.reparseOverscaled\n            });\n\n            if (this._source.hasTile) {\n                idealTileIDs = idealTileIDs.filter((coord) => (this._source.hasTile: any)(coord));\n            }\n        }\n\n        // Determine the overzooming/underzooming amounts.\n        const zoom = (this._source.roundZoom ? Math.round : Math.floor)(this.getZoom(transform));\n        const minCoveringZoom = Math.max(zoom - SourceCache.maxOverzooming, this._source.minzoom);\n        const maxCoveringZoom = Math.max(zoom + SourceCache.maxUnderzooming,  this._source.minzoom);\n\n        // Retain is a list of tiles that we shouldn't delete, even if they are not\n        // the most ideal tile for the current viewport. This may include tiles like\n        // parent or child tiles that are *already* loaded.\n        const retain = this._updateRetainedTiles(idealTileIDs, zoom);\n\n        if (isRasterType(this._source.type)) {\n            const parentsForFading = {};\n            const fadingTiles = {};\n            const ids = Object.keys(retain);\n            for (const id of ids) {\n                const tileID = retain[id];\n                assert(tileID.key === +id);\n\n                const tile = this._tiles[id];\n                if (!tile || tile.fadeEndTime && tile.fadeEndTime <= browser.now()) continue;\n\n                // if the tile is loaded but still fading in, find parents to cross-fade with it\n                const parentTile = this.findLoadedParent(tileID, minCoveringZoom);\n                if (parentTile) {\n                    this._addTile(parentTile.tileID);\n                    parentsForFading[parentTile.tileID.key] = parentTile.tileID;\n                }\n\n                fadingTiles[id] = tileID;\n            }\n\n            // for tiles that are still fading in, also find children to cross-fade with\n            this._retainLoadedChildren(fadingTiles, zoom, maxCoveringZoom, retain);\n\n            for (const id in parentsForFading) {\n                if (!retain[id]) {\n                    // If a tile is only needed for fading, mark it as covered so that it isn't rendered on it's own.\n                    this._coveredTiles[id] = true;\n                    retain[id] = parentsForFading[id];\n                }\n            }\n        }\n\n        for (const retainedId in retain) {\n            // Make sure retained tiles always clear any existing fade holds\n            // so that if they're removed again their fade timer starts fresh.\n            this._tiles[retainedId].clearFadeHold();\n        }\n\n        // Remove the tiles we don't need anymore.\n        const remove = keysDifference(this._tiles, retain);\n        for (const tileID of remove) {\n            const tile = this._tiles[tileID];\n            if (tile.hasSymbolBuckets && !tile.holdingForFade()) {\n                tile.setHoldDuration(this.map._fadeDuration);\n            } else if (!tile.hasSymbolBuckets || tile.symbolFadeFinished()) {\n                this._removeTile(tileID);\n            }\n        }\n    }\n\n    releaseSymbolFadeTiles() {\n        for (const id in this._tiles) {\n            if (this._tiles[id].holdingForFade()) {\n                this._removeTile(id);\n            }\n        }\n    }\n\n    _updateRetainedTiles(idealTileIDs: Array<OverscaledTileID>, zoom: number): { [string]: OverscaledTileID} {\n        const retain = {};\n        const checked: {[number]: boolean } = {};\n        const minCoveringZoom = Math.max(zoom - SourceCache.maxOverzooming, this._source.minzoom);\n        const maxCoveringZoom = Math.max(zoom + SourceCache.maxUnderzooming,  this._source.minzoom);\n\n        const missingTiles = {};\n        for (const tileID of idealTileIDs) {\n            const tile = this._addTile(tileID);\n\n            // retain the tile even if it's not loaded because it's an ideal tile.\n            retain[tileID.key] = tileID;\n\n            if (tile.hasData()) continue;\n\n            if (zoom < this._source.maxzoom) {\n                // save missing tiles that potentially have loaded children\n                missingTiles[tileID.key] = tileID;\n            }\n        }\n\n        // retain any loaded children of ideal tiles up to maxCoveringZoom\n        this._retainLoadedChildren(missingTiles, zoom, maxCoveringZoom, retain);\n\n        for (const tileID of idealTileIDs) {\n            let tile = this._tiles[tileID.key];\n\n            if (tile.hasData()) continue;\n\n            // The tile we require is not yet loaded or does not exist;\n            // Attempt to find children that fully cover it.\n\n            if (zoom + 1 > this._source.maxzoom) {\n                // We're looking for an overzoomed child tile.\n                const childCoord = tileID.children(this._source.maxzoom)[0];\n                const childTile = this.getTile(childCoord);\n                if (!!childTile && childTile.hasData()) {\n                    retain[childCoord.key] = childCoord;\n                    continue; // tile is covered by overzoomed child\n                }\n            } else {\n                // check if all 4 immediate children are loaded (i.e. the missing ideal tile is covered)\n                const children = tileID.children(this._source.maxzoom);\n\n                if (retain[children[0].key] &&\n                    retain[children[1].key] &&\n                    retain[children[2].key] &&\n                    retain[children[3].key]) continue; // tile is covered by children\n            }\n\n            // We couldn't find child tiles that entirely cover the ideal tile; look for parents now.\n\n            // As we ascend up the tile pyramid of the ideal tile, we check whether the parent\n            // tile has been previously requested (and errored because we only loop over tiles with no data)\n            // in order to determine if we need to request its parent.\n            let parentWasRequested = tile.wasRequested();\n\n            for (let overscaledZ = tileID.overscaledZ - 1; overscaledZ >= minCoveringZoom; --overscaledZ) {\n                const parentId = tileID.scaledTo(overscaledZ);\n\n                // Break parent tile ascent if this route has been previously checked by another child.\n                if (checked[parentId.key]) break;\n                checked[parentId.key] = true;\n\n                tile = this.getTile(parentId);\n                if (!tile && parentWasRequested) {\n                    tile = this._addTile(parentId);\n                }\n                if (tile) {\n                    retain[parentId.key] = parentId;\n                    // Save the current values, since they're the parent of the next iteration\n                    // of the parent tile ascent loop.\n                    parentWasRequested = tile.wasRequested();\n                    if (tile.hasData()) break;\n                }\n            }\n        }\n\n        return retain;\n    }\n\n    /**\n     * Add a tile, given its coordinate, to the pyramid.\n     * @private\n     */\n    _addTile(tileID: OverscaledTileID): Tile {\n        let tile = this._tiles[tileID.key];\n        if (tile)\n            return tile;\n\n\n        tile = this._cache.getAndRemove(tileID);\n        if (tile) {\n            this._setTileReloadTimer(tileID.key, tile);\n            // set the tileID because the cached tile could have had a different wrap value\n            tile.tileID = tileID;\n            this._state.initializeTileState(tile, this.map ? this.map.painter : null);\n            if (this._cacheTimers[tileID.key]) {\n                clearTimeout(this._cacheTimers[tileID.key]);\n                delete this._cacheTimers[tileID.key];\n                this._setTileReloadTimer(tileID.key, tile);\n            }\n        }\n\n        const cached = Boolean(tile);\n        if (!cached) {\n            tile = new Tile(tileID, this._source.tileSize * tileID.overscaleFactor());\n            this._loadTile(tile, this._tileLoaded.bind(this, tile, tileID.key, tile.state));\n        }\n\n        // Impossible, but silence flow.\n        if (!tile) return (null: any);\n\n        tile.uses++;\n        this._tiles[tileID.key] = tile;\n        if (!cached) this._source.fire(new Event('dataloading', {tile, coord: tile.tileID, dataType: 'source'}));\n\n        return tile;\n    }\n\n    _setTileReloadTimer(id: string | number, tile: Tile) {\n        if (id in this._timers) {\n            clearTimeout(this._timers[id]);\n            delete this._timers[id];\n        }\n\n        const expiryTimeout = tile.getExpiryTimeout();\n        if (expiryTimeout) {\n            this._timers[id] = setTimeout(() => {\n                this._reloadTile(id, 'expired');\n                delete this._timers[id];\n            }, expiryTimeout);\n        }\n    }\n\n    /**\n     * Remove a tile, given its id, from the pyramid\n     * @private\n     */\n    _removeTile(id: string | number) {\n        const tile = this._tiles[id];\n        if (!tile)\n            return;\n\n        tile.uses--;\n        delete this._tiles[id];\n        if (this._timers[id]) {\n            clearTimeout(this._timers[id]);\n            delete this._timers[id];\n        }\n\n        if (tile.uses > 0)\n            return;\n\n        if (tile.hasData()) {\n            this._cache.add(tile.tileID, tile, tile.getExpiryTimeout());\n        } else {\n            tile.aborted = true;\n            this._abortTile(tile);\n            this._unloadTile(tile);\n        }\n    }\n\n    /**\n     * Remove all tiles from this pyramid\n     */\n    clearTiles() {\n        this._shouldReloadOnResume = false;\n        this._paused = false;\n\n        for (const id in this._tiles)\n            this._removeTile(id);\n\n        this._cache.reset();\n    }\n\n    /**\n     * Search through our current tiles and attempt to find the tiles that\n     * cover the given bounds.\n     * @param pointQueryGeometry coordinates of the corners of bounding rectangle\n     * @returns {Array<Object>} result items have {tile, minX, maxX, minY, maxY}, where min/max bounding values are the given bounds transformed in into the coordinate space of this tile.\n     */\n    tilesIn(pointQueryGeometry: Array<Point>, maxPitchScaleFactor: number, has3DLayer: boolean) {\n\n        const tileResults = [];\n\n        const transform = this.transform;\n        if (!transform) return tileResults;\n\n        const cameraPointQueryGeometry = has3DLayer ?\n            transform.getCameraQueryGeometry(pointQueryGeometry) :\n            pointQueryGeometry;\n\n        const queryGeometry = pointQueryGeometry.map((p) => transform.pointCoordinate(p));\n        const cameraQueryGeometry = cameraPointQueryGeometry.map((p) => transform.pointCoordinate(p));\n\n        const ids = this.getIds();\n\n        let minX = Infinity;\n        let minY = Infinity;\n        let maxX = -Infinity;\n        let maxY = -Infinity;\n\n        for (const p of cameraQueryGeometry) {\n            minX = Math.min(minX, p.x);\n            minY = Math.min(minY, p.y);\n            maxX = Math.max(maxX, p.x);\n            maxY = Math.max(maxY, p.y);\n        }\n\n        for (let i = 0; i < ids.length; i++) {\n            const tile = this._tiles[ids[i]];\n            if (tile.holdingForFade()) {\n                // Tiles held for fading are covered by tiles that are closer to ideal\n                continue;\n            }\n            const tileID = tile.tileID;\n            const scale = Math.pow(2, transform.zoom - tile.tileID.overscaledZ);\n            const queryPadding = maxPitchScaleFactor * tile.queryPadding * EXTENT / tile.tileSize / scale;\n\n            const tileSpaceBounds = [\n                tileID.getTilePoint(new MercatorCoordinate(minX, minY)),\n                tileID.getTilePoint(new MercatorCoordinate(maxX, maxY))\n            ];\n\n            if (tileSpaceBounds[0].x - queryPadding < EXTENT && tileSpaceBounds[0].y - queryPadding < EXTENT &&\n                tileSpaceBounds[1].x + queryPadding >= 0 && tileSpaceBounds[1].y + queryPadding >= 0) {\n\n                const tileSpaceQueryGeometry: Array<Point> = queryGeometry.map((c) => tileID.getTilePoint(c));\n                const tileSpaceCameraQueryGeometry = cameraQueryGeometry.map((c) => tileID.getTilePoint(c));\n\n                tileResults.push({\n                    tile,\n                    tileID,\n                    queryGeometry: tileSpaceQueryGeometry,\n                    cameraQueryGeometry: tileSpaceCameraQueryGeometry,\n                    scale\n                });\n            }\n        }\n\n        return tileResults;\n    }\n\n    getVisibleCoordinates(symbolLayer?: boolean): Array<OverscaledTileID> {\n        const coords = this.getRenderableIds(symbolLayer).map((id) => this._tiles[id].tileID);\n        for (const coord of coords) {\n            coord.posMatrix = this.transform.calculatePosMatrix(coord.toUnwrapped());\n        }\n        return coords;\n    }\n\n    hasTransition() {\n        if (this._source.hasTransition()) {\n            return true;\n        }\n\n        if (isRasterType(this._source.type)) {\n            for (const id in this._tiles) {\n                const tile = this._tiles[id];\n                if (tile.fadeEndTime !== undefined && tile.fadeEndTime >= browser.now()) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Set the value of a particular state for a feature\n     * @private\n     */\n    setFeatureState(sourceLayer?: string, feature: number, state: Object) {\n        sourceLayer = sourceLayer || '_geojsonTileLayer';\n        this._state.updateState(sourceLayer, feature, state);\n    }\n\n    /**\n     * Get the entire state object for a feature\n     * @private\n     */\n    getFeatureState(sourceLayer?: string, feature: number) {\n        sourceLayer = sourceLayer || '_geojsonTileLayer';\n        return this._state.getState(sourceLayer, feature);\n    }\n}\n\nSourceCache.maxOverzooming = 10;\nSourceCache.maxUnderzooming = 3;\n\nfunction compareKeyZoom(a, b) {\n    return ((a % 32) - (b % 32)) || (b - a);\n}\n\nfunction isRasterType(type) {\n    return type === 'raster' || type === 'image' || type === 'video';\n}\n\nexport default SourceCache;\n","// @flow\n\nimport WebWorker from './web_worker';\nimport type {WorkerInterface} from './web_worker';\nimport browser from './browser';\n\n/**\n * Constructs a worker pool.\n * @private\n */\nexport default class WorkerPool {\n    static workerCount: number;\n\n    active: {[number]: boolean};\n    workers: Array<WorkerInterface>;\n\n    constructor() {\n        this.active = {};\n    }\n\n    acquire(mapId: number): Array<WorkerInterface> {\n        if (!this.workers) {\n            // Lazily look up the value of mapboxgl.workerCount so that\n            // client code has had a chance to set it.\n            this.workers = [];\n            while (this.workers.length < WorkerPool.workerCount) {\n                this.workers.push(new WebWorker());\n            }\n        }\n\n        this.active[mapId] = true;\n        return this.workers.slice();\n    }\n\n    release(mapId: number) {\n        delete this.active[mapId];\n        if (Object.keys(this.active).length === 0) {\n            this.workers.forEach((w) => {\n                w.terminate();\n            });\n            this.workers = (null: any);\n        }\n    }\n}\n\nconst availableLogicalProcessors = Math.floor(browser.hardwareConcurrency / 2);\nWorkerPool.workerCount = Math.max(Math.min(availableLogicalProcessors, 6), 1);\n","// @flow\n\nimport { mat4 } from 'gl-matrix';\nimport EXTENT from '../data/extent';\nimport { PosArray } from '../data/array_types';\nimport { LineIndexArray } from '../data/index_array_type';\nimport posAttributes from '../data/pos_attributes';\nimport SegmentVector from '../data/segment';\nimport DepthMode from '../gl/depth_mode';\nimport StencilMode from '../gl/stencil_mode';\nimport CullFaceMode from '../gl/cull_face_mode';\nimport { debugUniformValues } from './program/debug_program';\nimport Color from '../style-spec/util/color';\n\nimport type Painter from './painter';\nimport type SourceCache from '../source/source_cache';\nimport type {OverscaledTileID} from '../source/tile_id';\n\nexport default drawDebug;\n\nfunction drawDebug(painter: Painter, sourceCache: SourceCache, coords: Array<OverscaledTileID>) {\n    for (let i = 0; i < coords.length; i++) {\n        drawDebugTile(painter, sourceCache, coords[i]);\n    }\n}\n\nfunction drawDebugTile(painter, sourceCache, coord) {\n    const context = painter.context;\n    const gl = context.gl;\n\n    const posMatrix = coord.posMatrix;\n    const program = painter.useProgram('debug');\n\n    const depthMode = DepthMode.disabled;\n    const stencilMode = StencilMode.disabled;\n    const colorMode = painter.colorModeForRenderPass();\n    const id = '$debug';\n\n    program.draw(context, gl.LINE_STRIP, depthMode, stencilMode, colorMode, CullFaceMode.disabled,\n        debugUniformValues(posMatrix, Color.red), id,\n        painter.debugBuffer, painter.tileBorderIndexBuffer, painter.debugSegments);\n\n    const vertices = createTextVertices(coord.toString(), 50, 200, 5);\n    const debugTextArray = new PosArray();\n    const debugTextIndices = new LineIndexArray();\n    for (let v = 0; v < vertices.length; v += 2) {\n        debugTextArray.emplaceBack(vertices[v], vertices[v + 1]);\n        debugTextIndices.emplaceBack(v, v + 1);\n    }\n    const debugTextBuffer = context.createVertexBuffer(debugTextArray, posAttributes.members);\n    const debugTextIndexBuffer = context.createIndexBuffer(debugTextIndices);\n    const debugTextSegment = SegmentVector.simpleSegment(0, 0, debugTextArray.length / 2, debugTextArray.length / 2);\n\n    // Draw the halo with multiple 1px lines instead of one wider line because\n    // the gl spec doesn't guarantee support for lines with width > 1.\n    const tileSize = sourceCache.getTile(coord).tileSize;\n    const onePixel = EXTENT / (Math.pow(2, painter.transform.zoom - coord.overscaledZ) * tileSize);\n    const translations = [[-1, -1], [-1, 1], [1, -1], [1, 1]];\n    for (let i = 0; i < translations.length; i++) {\n        const translation = translations[i];\n\n        program.draw(context, gl.LINES, depthMode, stencilMode, colorMode, CullFaceMode.disabled,\n            debugUniformValues(\n                mat4.translate([], posMatrix, [\n                    onePixel * translation[0],\n                    onePixel * translation[1], 0]),\n                Color.white),\n            id, debugTextBuffer, debugTextIndexBuffer, debugTextSegment);\n    }\n\n    program.draw(context, gl.LINES, depthMode, stencilMode, colorMode, CullFaceMode.disabled,\n        debugUniformValues(posMatrix, Color.black), id,\n        debugTextBuffer, debugTextIndexBuffer, debugTextSegment);\n}\n\n// Font data From Hershey Simplex Font\n// http://paulbourke.net/dataformats/hershey/\nconst simplexFont = {\n    \" \": [16, []],\n    \"!\": [10, [5, 21, 5, 7, -1, -1, 5, 2, 4, 1, 5, 0, 6, 1, 5, 2]],\n    \"\\\"\": [16, [4, 21, 4, 14, -1, -1, 12, 21, 12, 14]],\n    \"#\": [21, [11, 25, 4, -7, -1, -1, 17, 25, 10, -7, -1, -1, 4, 12, 18, 12, -1, -1, 3, 6, 17, 6]],\n    \"$\": [20, [8, 25, 8, -4, -1, -1, 12, 25, 12, -4, -1, -1, 17, 18, 15, 20, 12, 21, 8, 21, 5, 20, 3, 18, 3, 16, 4, 14, 5, 13, 7, 12, 13, 10, 15, 9, 16, 8, 17, 6, 17, 3, 15, 1, 12, 0, 8, 0, 5, 1, 3, 3]],\n    \"%\": [24, [21, 21, 3, 0, -1, -1, 8, 21, 10, 19, 10, 17, 9, 15, 7, 14, 5, 14, 3, 16, 3, 18, 4, 20, 6, 21, 8, 21, 10, 20, 13, 19, 16, 19, 19, 20, 21, 21, -1, -1, 17, 7, 15, 6, 14, 4, 14, 2, 16, 0, 18, 0, 20, 1, 21, 3, 21, 5, 19, 7, 17, 7]],\n    \"&\": [26, [23, 12, 23, 13, 22, 14, 21, 14, 20, 13, 19, 11, 17, 6, 15, 3, 13, 1, 11, 0, 7, 0, 5, 1, 4, 2, 3, 4, 3, 6, 4, 8, 5, 9, 12, 13, 13, 14, 14, 16, 14, 18, 13, 20, 11, 21, 9, 20, 8, 18, 8, 16, 9, 13, 11, 10, 16, 3, 18, 1, 20, 0, 22, 0, 23, 1, 23, 2]],\n    \"'\": [10, [5, 19, 4, 20, 5, 21, 6, 20, 6, 18, 5, 16, 4, 15]],\n    \"(\": [14, [11, 25, 9, 23, 7, 20, 5, 16, 4, 11, 4, 7, 5, 2, 7, -2, 9, -5, 11, -7]],\n    \")\": [14, [3, 25, 5, 23, 7, 20, 9, 16, 10, 11, 10, 7, 9, 2, 7, -2, 5, -5, 3, -7]],\n    \"*\": [16, [8, 21, 8, 9, -1, -1, 3, 18, 13, 12, -1, -1, 13, 18, 3, 12]],\n    \"+\": [26, [13, 18, 13, 0, -1, -1, 4, 9, 22, 9]],\n    \",\": [10, [6, 1, 5, 0, 4, 1, 5, 2, 6, 1, 6, -1, 5, -3, 4, -4]],\n    \"-\": [26, [4, 9, 22, 9]],\n    \".\": [10, [5, 2, 4, 1, 5, 0, 6, 1, 5, 2]],\n    \"/\": [22, [20, 25, 2, -7]],\n    \"0\": [20, [9, 21, 6, 20, 4, 17, 3, 12, 3, 9, 4, 4, 6, 1, 9, 0, 11, 0, 14, 1, 16, 4, 17, 9, 17, 12, 16, 17, 14, 20, 11, 21, 9, 21]],\n    \"1\": [20, [6, 17, 8, 18, 11, 21, 11, 0]],\n    \"2\": [20, [4, 16, 4, 17, 5, 19, 6, 20, 8, 21, 12, 21, 14, 20, 15, 19, 16, 17, 16, 15, 15, 13, 13, 10, 3, 0, 17, 0]],\n    \"3\": [20, [5, 21, 16, 21, 10, 13, 13, 13, 15, 12, 16, 11, 17, 8, 17, 6, 16, 3, 14, 1, 11, 0, 8, 0, 5, 1, 4, 2, 3, 4]],\n    \"4\": [20, [13, 21, 3, 7, 18, 7, -1, -1, 13, 21, 13, 0]],\n    \"5\": [20, [15, 21, 5, 21, 4, 12, 5, 13, 8, 14, 11, 14, 14, 13, 16, 11, 17, 8, 17, 6, 16, 3, 14, 1, 11, 0, 8, 0, 5, 1, 4, 2, 3, 4]],\n    \"6\": [20, [16, 18, 15, 20, 12, 21, 10, 21, 7, 20, 5, 17, 4, 12, 4, 7, 5, 3, 7, 1, 10, 0, 11, 0, 14, 1, 16, 3, 17, 6, 17, 7, 16, 10, 14, 12, 11, 13, 10, 13, 7, 12, 5, 10, 4, 7]],\n    \"7\": [20, [17, 21, 7, 0, -1, -1, 3, 21, 17, 21]],\n    \"8\": [20, [8, 21, 5, 20, 4, 18, 4, 16, 5, 14, 7, 13, 11, 12, 14, 11, 16, 9, 17, 7, 17, 4, 16, 2, 15, 1, 12, 0, 8, 0, 5, 1, 4, 2, 3, 4, 3, 7, 4, 9, 6, 11, 9, 12, 13, 13, 15, 14, 16, 16, 16, 18, 15, 20, 12, 21, 8, 21]],\n    \"9\": [20, [16, 14, 15, 11, 13, 9, 10, 8, 9, 8, 6, 9, 4, 11, 3, 14, 3, 15, 4, 18, 6, 20, 9, 21, 10, 21, 13, 20, 15, 18, 16, 14, 16, 9, 15, 4, 13, 1, 10, 0, 8, 0, 5, 1, 4, 3]],\n    \":\": [10, [5, 14, 4, 13, 5, 12, 6, 13, 5, 14, -1, -1, 5, 2, 4, 1, 5, 0, 6, 1, 5, 2]],\n    \";\": [10, [5, 14, 4, 13, 5, 12, 6, 13, 5, 14, -1, -1, 6, 1, 5, 0, 4, 1, 5, 2, 6, 1, 6, -1, 5, -3, 4, -4]],\n    \"<\": [24, [20, 18, 4, 9, 20, 0]],\n    \"=\": [26, [4, 12, 22, 12, -1, -1, 4, 6, 22, 6]],\n    \">\": [24, [4, 18, 20, 9, 4, 0]],\n    \"?\": [18, [3, 16, 3, 17, 4, 19, 5, 20, 7, 21, 11, 21, 13, 20, 14, 19, 15, 17, 15, 15, 14, 13, 13, 12, 9, 10, 9, 7, -1, -1, 9, 2, 8, 1, 9, 0, 10, 1, 9, 2]],\n    \"@\": [27, [18, 13, 17, 15, 15, 16, 12, 16, 10, 15, 9, 14, 8, 11, 8, 8, 9, 6, 11, 5, 14, 5, 16, 6, 17, 8, -1, -1, 12, 16, 10, 14, 9, 11, 9, 8, 10, 6, 11, 5, -1, -1, 18, 16, 17, 8, 17, 6, 19, 5, 21, 5, 23, 7, 24, 10, 24, 12, 23, 15, 22, 17, 20, 19, 18, 20, 15, 21, 12, 21, 9, 20, 7, 19, 5, 17, 4, 15, 3, 12, 3, 9, 4, 6, 5, 4, 7, 2, 9, 1, 12, 0, 15, 0, 18, 1, 20, 2, 21, 3, -1, -1, 19, 16, 18, 8, 18, 6, 19, 5]],\n    \"A\": [18, [9, 21, 1, 0, -1, -1, 9, 21, 17, 0, -1, -1, 4, 7, 14, 7]],\n    \"B\": [21, [4, 21, 4, 0, -1, -1, 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 15, 17, 13, 16, 12, 13, 11, -1, -1, 4, 11, 13, 11, 16, 10, 17, 9, 18, 7, 18, 4, 17, 2, 16, 1, 13, 0, 4, 0]],\n    \"C\": [21, [18, 16, 17, 18, 15, 20, 13, 21, 9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5]],\n    \"D\": [21, [4, 21, 4, 0, -1, -1, 4, 21, 11, 21, 14, 20, 16, 18, 17, 16, 18, 13, 18, 8, 17, 5, 16, 3, 14, 1, 11, 0, 4, 0]],\n    \"E\": [19, [4, 21, 4, 0, -1, -1, 4, 21, 17, 21, -1, -1, 4, 11, 12, 11, -1, -1, 4, 0, 17, 0]],\n    \"F\": [18, [4, 21, 4, 0, -1, -1, 4, 21, 17, 21, -1, -1, 4, 11, 12, 11]],\n    \"G\": [21, [18, 16, 17, 18, 15, 20, 13, 21, 9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 18, 8, -1, -1, 13, 8, 18, 8]],\n    \"H\": [22, [4, 21, 4, 0, -1, -1, 18, 21, 18, 0, -1, -1, 4, 11, 18, 11]],\n    \"I\": [8, [4, 21, 4, 0]],\n    \"J\": [16, [12, 21, 12, 5, 11, 2, 10, 1, 8, 0, 6, 0, 4, 1, 3, 2, 2, 5, 2, 7]],\n    \"K\": [21, [4, 21, 4, 0, -1, -1, 18, 21, 4, 7, -1, -1, 9, 12, 18, 0]],\n    \"L\": [17, [4, 21, 4, 0, -1, -1, 4, 0, 16, 0]],\n    \"M\": [24, [4, 21, 4, 0, -1, -1, 4, 21, 12, 0, -1, -1, 20, 21, 12, 0, -1, -1, 20, 21, 20, 0]],\n    \"N\": [22, [4, 21, 4, 0, -1, -1, 4, 21, 18, 0, -1, -1, 18, 21, 18, 0]],\n    \"O\": [22, [9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 19, 8, 19, 13, 18, 16, 17, 18, 15, 20, 13, 21, 9, 21]],\n    \"P\": [21, [4, 21, 4, 0, -1, -1, 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 14, 17, 12, 16, 11, 13, 10, 4, 10]],\n    \"Q\": [22, [9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 19, 8, 19, 13, 18, 16, 17, 18, 15, 20, 13, 21, 9, 21, -1, -1, 12, 4, 18, -2]],\n    \"R\": [21, [4, 21, 4, 0, -1, -1, 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 15, 17, 13, 16, 12, 13, 11, 4, 11, -1, -1, 11, 11, 18, 0]],\n    \"S\": [20, [17, 18, 15, 20, 12, 21, 8, 21, 5, 20, 3, 18, 3, 16, 4, 14, 5, 13, 7, 12, 13, 10, 15, 9, 16, 8, 17, 6, 17, 3, 15, 1, 12, 0, 8, 0, 5, 1, 3, 3]],\n    \"T\": [16, [8, 21, 8, 0, -1, -1, 1, 21, 15, 21]],\n    \"U\": [22, [4, 21, 4, 6, 5, 3, 7, 1, 10, 0, 12, 0, 15, 1, 17, 3, 18, 6, 18, 21]],\n    \"V\": [18, [1, 21, 9, 0, -1, -1, 17, 21, 9, 0]],\n    \"W\": [24, [2, 21, 7, 0, -1, -1, 12, 21, 7, 0, -1, -1, 12, 21, 17, 0, -1, -1, 22, 21, 17, 0]],\n    \"X\": [20, [3, 21, 17, 0, -1, -1, 17, 21, 3, 0]],\n    \"Y\": [18, [1, 21, 9, 11, 9, 0, -1, -1, 17, 21, 9, 11]],\n    \"Z\": [20, [17, 21, 3, 0, -1, -1, 3, 21, 17, 21, -1, -1, 3, 0, 17, 0]],\n    \"[\": [14, [4, 25, 4, -7, -1, -1, 5, 25, 5, -7, -1, -1, 4, 25, 11, 25, -1, -1, 4, -7, 11, -7]],\n    \"\\\\\": [14, [0, 21, 14, -3]],\n    \"]\": [14, [9, 25, 9, -7, -1, -1, 10, 25, 10, -7, -1, -1, 3, 25, 10, 25, -1, -1, 3, -7, 10, -7]],\n    \"^\": [16, [6, 15, 8, 18, 10, 15, -1, -1, 3, 12, 8, 17, 13, 12, -1, -1, 8, 17, 8, 0]],\n    \"_\": [16, [0, -2, 16, -2]],\n    \"`\": [10, [6, 21, 5, 20, 4, 18, 4, 16, 5, 15, 6, 16, 5, 17]],\n    \"a\": [19, [15, 14, 15, 0, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],\n    \"b\": [19, [4, 21, 4, 0, -1, -1, 4, 11, 6, 13, 8, 14, 11, 14, 13, 13, 15, 11, 16, 8, 16, 6, 15, 3, 13, 1, 11, 0, 8, 0, 6, 1, 4, 3]],\n    \"c\": [18, [15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],\n    \"d\": [19, [15, 21, 15, 0, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],\n    \"e\": [18, [3, 8, 15, 8, 15, 10, 14, 12, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],\n    \"f\": [12, [10, 21, 8, 21, 6, 20, 5, 17, 5, 0, -1, -1, 2, 14, 9, 14]],\n    \"g\": [19, [15, 14, 15, -2, 14, -5, 13, -6, 11, -7, 8, -7, 6, -6, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],\n    \"h\": [19, [4, 21, 4, 0, -1, -1, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0]],\n    \"i\": [8, [3, 21, 4, 20, 5, 21, 4, 22, 3, 21, -1, -1, 4, 14, 4, 0]],\n    \"j\": [10, [5, 21, 6, 20, 7, 21, 6, 22, 5, 21, -1, -1, 6, 14, 6, -3, 5, -6, 3, -7, 1, -7]],\n    \"k\": [17, [4, 21, 4, 0, -1, -1, 14, 14, 4, 4, -1, -1, 8, 8, 15, 0]],\n    \"l\": [8, [4, 21, 4, 0]],\n    \"m\": [30, [4, 14, 4, 0, -1, -1, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0, -1, -1, 15, 10, 18, 13, 20, 14, 23, 14, 25, 13, 26, 10, 26, 0]],\n    \"n\": [19, [4, 14, 4, 0, -1, -1, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0]],\n    \"o\": [19, [8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3, 16, 6, 16, 8, 15, 11, 13, 13, 11, 14, 8, 14]],\n    \"p\": [19, [4, 14, 4, -7, -1, -1, 4, 11, 6, 13, 8, 14, 11, 14, 13, 13, 15, 11, 16, 8, 16, 6, 15, 3, 13, 1, 11, 0, 8, 0, 6, 1, 4, 3]],\n    \"q\": [19, [15, 14, 15, -7, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],\n    \"r\": [13, [4, 14, 4, 0, -1, -1, 4, 8, 5, 11, 7, 13, 9, 14, 12, 14]],\n    \"s\": [17, [14, 11, 13, 13, 10, 14, 7, 14, 4, 13, 3, 11, 4, 9, 6, 8, 11, 7, 13, 6, 14, 4, 14, 3, 13, 1, 10, 0, 7, 0, 4, 1, 3, 3]],\n    \"t\": [12, [5, 21, 5, 4, 6, 1, 8, 0, 10, 0, -1, -1, 2, 14, 9, 14]],\n    \"u\": [19, [4, 14, 4, 4, 5, 1, 7, 0, 10, 0, 12, 1, 15, 4, -1, -1, 15, 14, 15, 0]],\n    \"v\": [16, [2, 14, 8, 0, -1, -1, 14, 14, 8, 0]],\n    \"w\": [22, [3, 14, 7, 0, -1, -1, 11, 14, 7, 0, -1, -1, 11, 14, 15, 0, -1, -1, 19, 14, 15, 0]],\n    \"x\": [17, [3, 14, 14, 0, -1, -1, 14, 14, 3, 0]],\n    \"y\": [16, [2, 14, 8, 0, -1, -1, 14, 14, 8, 0, 6, -4, 4, -6, 2, -7, 1, -7]],\n    \"z\": [17, [14, 14, 3, 0, -1, -1, 3, 14, 14, 14, -1, -1, 3, 0, 14, 0]],\n    \"{\": [14, [9, 25, 7, 24, 6, 23, 5, 21, 5, 19, 6, 17, 7, 16, 8, 14, 8, 12, 6, 10, -1, -1, 7, 24, 6, 22, 6, 20, 7, 18, 8, 17, 9, 15, 9, 13, 8, 11, 4, 9, 8, 7, 9, 5, 9, 3, 8, 1, 7, 0, 6, -2, 6, -4, 7, -6, -1, -1, 6, 8, 8, 6, 8, 4, 7, 2, 6, 1, 5, -1, 5, -3, 6, -5, 7, -6, 9, -7]],\n    \"|\": [8, [4, 25, 4, -7]],\n    \"}\": [14, [5, 25, 7, 24, 8, 23, 9, 21, 9, 19, 8, 17, 7, 16, 6, 14, 6, 12, 8, 10, -1, -1, 7, 24, 8, 22, 8, 20, 7, 18, 6, 17, 5, 15, 5, 13, 6, 11, 10, 9, 6, 7, 5, 5, 5, 3, 6, 1, 7, 0, 8, -2, 8, -4, 7, -6, -1, -1, 8, 8, 6, 6, 6, 4, 7, 2, 8, 1, 9, -1, 9, -3, 8, -5, 7, -6, 5, -7]],\n    \"~\": [24, [3, 6, 3, 8, 4, 11, 6, 12, 8, 12, 10, 11, 14, 8, 16, 7, 18, 7, 20, 8, 21, 10, -1, -1, 3, 8, 4, 10, 6, 11, 8, 11, 10, 10, 14, 7, 16, 6, 18, 6, 20, 7, 21, 10, 21, 12]]\n};\n\nfunction createTextVertices(text, left, baseline, scale) {\n    scale = scale || 1;\n\n    const strokes = [];\n    let i, len, j, len2, glyph, x, y, prev;\n\n    for (i = 0, len = text.length; i < len; i++) {\n        glyph = simplexFont[text[i]];\n        if (!glyph) continue;\n        prev = null;\n\n        for (j = 0, len2 = glyph[1].length; j < len2; j += 2) {\n            if (glyph[1][j] === -1 && glyph[1][j + 1] === -1) {\n                prev = null;\n\n            } else {\n                x = left + glyph[1][j] * scale;\n                y = baseline - glyph[1][j + 1] * scale;\n                if (prev) {\n                    strokes.push(prev.x, prev.y, x, y);\n                }\n                prev = {x, y};\n            }\n        }\n        left += glyph[0] * scale;\n    }\n\n    return strokes;\n}\n","// @flow\n\nimport DOM from '../../util/dom';\n\nimport { bindAll } from '../../util/util';\n\nimport type Map from '../map';\n\n/**\n * A `LogoControl` is a control that adds the Mapbox watermark\n * to the map as required by the [terms of service](https://www.mapbox.com/tos/) for Mapbox\n * vector tiles and core styles.\n *\n * @implements {IControl}\n * @private\n**/\n\nclass LogoControl {\n    _map: Map;\n    _container: HTMLElement;\n\n    constructor() {\n        bindAll(['_updateLogo'], this);\n        bindAll(['_updateCompact'], this);\n    }\n\n    onAdd(map: Map) {\n        this._map = map;\n        this._container = DOM.create('div', 'mapboxgl-ctrl');\n        const anchor = DOM.create('a', 'mapboxgl-ctrl-logo');\n        anchor.target = \"_blank\";\n        anchor.href = \"https://www.mapbox.com/\";\n        anchor.setAttribute(\"aria-label\", \"Mapbox logo\");\n        anchor.setAttribute(\"rel\", \"noopener\");\n        this._container.appendChild(anchor);\n        this._container.style.display = 'none';\n\n        this._map.on('sourcedata', this._updateLogo);\n        this._updateLogo();\n\n        this._map.on('resize', this._updateCompact);\n        this._updateCompact();\n\n        return this._container;\n    }\n\n    onRemove() {\n        DOM.remove(this._container);\n        this._map.off('sourcedata', this._updateLogo);\n        this._map.off('resize', this._updateCompact);\n    }\n\n    getDefaultPosition() {\n        return 'bottom-left';\n    }\n\n    _updateLogo(e: any) {\n        if (!e || e.sourceDataType === 'metadata') {\n            this._container.style.display = this._logoRequired() ? 'block' : 'none';\n        }\n    }\n\n    _logoRequired() {\n        if (!this._map.style) return;\n\n        const sourceCaches = this._map.style.sourceCaches;\n        for (const id in sourceCaches) {\n            const source = sourceCaches[id].getSource();\n            if (source.mapbox_logo) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    _updateCompact() {\n        const containerChildren = this._container.children;\n        if (containerChildren.length) {\n            const anchor = containerChildren[0];\n            if (this._map.getCanvasContainer().offsetWidth < 250) {\n                anchor.classList.add('mapboxgl-compact');\n            } else {\n                anchor.classList.remove('mapboxgl-compact');\n            }\n        }\n    }\n\n}\n\n\nexport default LogoControl;\n","// @flow\nimport assert from 'assert';\n\nexport type TaskID = number; // can't mark opaque due to https://github.com/flowtype/flow-remove-types/pull/61\ntype Task = {\n    callback: () => void;\n    id: TaskID;\n    cancelled: boolean;\n};\n\nclass TaskQueue {\n    _queue: Array<Task>;\n    _id: TaskID;\n    _cleared: boolean;\n    _currentlyRunning: Array<Task> | false;\n\n    constructor()  {\n        this._queue = [];\n        this._id = 0;\n        this._cleared = false;\n        this._currentlyRunning = false;\n    }\n\n    add(callback: () => void): TaskID {\n        const id = ++this._id;\n        const queue = this._queue;\n        queue.push({callback, id, cancelled: false});\n        return id;\n    }\n\n    remove(id: TaskID) {\n        const running = this._currentlyRunning;\n        const queue = running ? this._queue.concat(running) : this._queue;\n        for (const task of queue) {\n            if (task.id === id) {\n                task.cancelled = true;\n                return;\n            }\n        }\n    }\n\n    run() {\n        assert(!this._currentlyRunning);\n        const queue = this._currentlyRunning = this._queue;\n\n        // Tasks queued by callbacks in the current queue should be executed\n        // on the next run, not the current run.\n        this._queue = [];\n\n        for (const task of queue) {\n            if (task.cancelled) continue;\n            task.callback();\n            if (this._cleared) break;\n        }\n\n        this._cleared = false;\n        this._currentlyRunning = false;\n    }\n\n    clear() {\n        if (this._currentlyRunning) {\n            this._cleared = true;\n        }\n        this._queue = [];\n    }\n}\n\nexport default TaskQueue;\n","// @flow\n\nimport { extend, bindAll, warnOnce, uniqueId } from '../util/util';\n\nimport browser from '../util/browser';\nimport window from '../util/window';\nconst { HTMLImageElement, HTMLElement } = window;\nimport DOM from '../util/dom';\nimport { getImage, getJSON, ResourceType } from '../util/ajax';\nimport { normalizeStyleURL } from '../util/mapbox';\nimport Style from '../style/style';\nimport EvaluationParameters from '../style/evaluation_parameters';\nimport Painter from '../render/painter';\nimport Transform from '../geo/transform';\nimport Hash from './hash';\nimport bindHandlers from './bind_handlers';\nimport Camera from './camera';\nimport LngLat from '../geo/lng_lat';\nimport LngLatBounds from '../geo/lng_lat_bounds';\nimport Point from '@mapbox/point-geometry';\nimport AttributionControl from './control/attribution_control';\nimport LogoControl from './control/logo_control';\nimport isSupported from '@mapbox/mapbox-gl-supported';\nimport { RGBAImage } from '../util/image';\nimport { Event, ErrorEvent } from '../util/evented';\nimport { MapMouseEvent } from './events';\nimport TaskQueue from '../util/task_queue';\nimport webpSupported from '../util/webp_supported';\n\nimport type {PointLike} from '@mapbox/point-geometry';\nimport type {LngLatLike} from '../geo/lng_lat';\nimport type {LngLatBoundsLike} from '../geo/lng_lat_bounds';\nimport type {RequestParameters} from '../util/ajax';\nimport type {StyleOptions, StyleSetterOptions} from '../style/style';\nimport type {MapEvent, MapDataEvent} from './events';\nimport type {CustomLayerInterface} from '../style/style_layer/custom_style_layer';\n\nimport type ScrollZoomHandler from './handler/scroll_zoom';\nimport type BoxZoomHandler from './handler/box_zoom';\nimport type DragRotateHandler from './handler/drag_rotate';\nimport type DragPanHandler from './handler/drag_pan';\nimport type KeyboardHandler from './handler/keyboard';\nimport type DoubleClickZoomHandler from './handler/dblclick_zoom';\nimport type TouchZoomRotateHandler from './handler/touch_zoom_rotate';\nimport type {TaskID} from '../util/task_queue';\nimport type {Cancelable} from '../types/cancelable';\nimport type {\n    LayerSpecification,\n    FilterSpecification,\n    StyleSpecification,\n    LightSpecification,\n    SourceSpecification\n} from '../style-spec/types';\n\ntype ControlPosition = 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';\n/* eslint-disable no-use-before-define */\ntype IControl = {\n    onAdd(map: Map): HTMLElement;\n    onRemove(map: Map): void;\n\n    +getDefaultPosition?: () => ControlPosition;\n}\n/* eslint-enable no-use-before-define */\n\ntype ResourceTypeEnum = $Keys<typeof ResourceType>;\nexport type RequestTransformFunction = (url: string, resourceType?: ResourceTypeEnum) => RequestParameters;\n\ntype MapOptions = {\n    hash?: boolean,\n    interactive?: boolean,\n    container: HTMLElement | string,\n    bearingSnap?: number,\n    attributionControl?: boolean,\n    customAttribution?: string | Array<string>,\n    logoPosition?: ControlPosition,\n    failIfMajorPerformanceCaveat?: boolean,\n    preserveDrawingBuffer?: boolean,\n    refreshExpiredTiles?: boolean,\n    maxBounds?: LngLatBoundsLike,\n    scrollZoom?: boolean,\n    minZoom?: ?number,\n    maxZoom?: ?number,\n    boxZoom?: boolean,\n    dragRotate?: boolean,\n    dragPan?: boolean,\n    keyboard?: boolean,\n    doubleClickZoom?: boolean,\n    touchZoomRotate?: boolean,\n    trackResize?: boolean,\n    center?: LngLatLike,\n    zoom?: number,\n    bearing?: number,\n    pitch?: number,\n    renderWorldCopies?: boolean,\n    maxTileCacheSize?: number,\n    transformRequest?: RequestTransformFunction\n};\n\nconst defaultMinZoom = 0;\nconst defaultMaxZoom = 22;\nconst defaultOptions = {\n    center: [0, 0],\n    zoom: 0,\n    bearing: 0,\n    pitch: 0,\n\n    minZoom: defaultMinZoom,\n    maxZoom: defaultMaxZoom,\n\n    interactive: true,\n    scrollZoom: true,\n    boxZoom: true,\n    dragRotate: true,\n    dragPan: true,\n    keyboard: true,\n    doubleClickZoom: true,\n    touchZoomRotate: true,\n\n    bearingSnap: 7,\n    clickTolerance: 3,\n\n    hash: false,\n    attributionControl: true,\n\n    failIfMajorPerformanceCaveat: false,\n    preserveDrawingBuffer: false,\n    trackResize: true,\n    renderWorldCopies: true,\n    refreshExpiredTiles: true,\n    maxTileCacheSize: null,\n    transformRequest: null,\n    fadeDuration: 300,\n    crossSourceCollisions: true\n};\n\n/**\n * The `Map` object represents the map on your page. It exposes methods\n * and properties that enable you to programmatically change the map,\n * and fires events as users interact with it.\n *\n * You create a `Map` by specifying a `container` and other options.\n * Then Mapbox GL JS initializes the map on the page and returns your `Map`\n * object.\n *\n * @extends Evented\n * @param {Object} options\n * @param {HTMLElement|string} options.container The HTML element in which Mapbox GL JS will render the map, or the element's string `id`. The specified element must have no children.\n * @param {number} [options.minZoom=0] The minimum zoom level of the map (0-24).\n * @param {number} [options.maxZoom=22] The maximum zoom level of the map (0-24).\n * @param {Object|string} [options.style] The map's Mapbox style. This must be an a JSON object conforming to\n * the schema described in the [Mapbox Style Specification](https://mapbox.com/mapbox-gl-style-spec/), or a URL to\n * such JSON.\n *\n * To load a style from the Mapbox API, you can use a URL of the form `mapbox://styles/:owner/:style`,\n * where `:owner` is your Mapbox account name and `:style` is the style ID. Or you can use one of the following\n * [the predefined Mapbox styles](https://www.mapbox.com/maps/):\n *\n *  * `mapbox://styles/mapbox/streets-v10`\n *  * `mapbox://styles/mapbox/outdoors-v10`\n *  * `mapbox://styles/mapbox/light-v9`\n *  * `mapbox://styles/mapbox/dark-v9`\n *  * `mapbox://styles/mapbox/satellite-v9`\n *  * `mapbox://styles/mapbox/satellite-streets-v10`\n *  * `mapbox://styles/mapbox/navigation-preview-day-v2`\n *  * `mapbox://styles/mapbox/navigation-preview-night-v2`\n *  * `mapbox://styles/mapbox/navigation-guidance-day-v2`\n *  * `mapbox://styles/mapbox/navigation-guidance-night-v2`\n *\n * Tilesets hosted with Mapbox can be style-optimized if you append `?optimize=true` to the end of your style URL, like `mapbox://styles/mapbox/streets-v9?optimize=true`.\n * Learn more about style-optimized vector tiles in our [API documentation](https://www.mapbox.com/api-documentation/#retrieve-tiles).\n *\n * @param {boolean} [options.hash=false] If `true`, the map's position (zoom, center latitude, center longitude, bearing, and pitch) will be synced with the hash fragment of the page's URL.\n *   For example, `http://path/to/my/page.html#2.59/39.26/53.07/-24.1/60`.\n * @param {boolean} [options.interactive=true] If `false`, no mouse, touch, or keyboard listeners will be attached to the map, so it will not respond to interaction.\n * @param {number} [options.bearingSnap=7] The threshold, measured in degrees, that determines when the map's\n *   bearing will snap to north. For example, with a `bearingSnap` of 7, if the user rotates\n *   the map within 7 degrees of north, the map will automatically snap to exact north.\n * @param {boolean} [options.pitchWithRotate=true] If `false`, the map's pitch (tilt) control with \"drag to rotate\" interaction will be disabled.\n * @param {number} [options.clickTolerance=3] The max number of pixels a user can shift the mouse pointer during a click for it to be considered a valid click (as opposed to a mouse drag).\n * @param {boolean} [options.attributionControl=true] If `true`, an {@link AttributionControl} will be added to the map.\n * @param {string | Array<string>} [options.customAttribution] String or strings to show in an {@link AttributionControl}. Only applicable if `options.attributionControl` is `true`.\n * @param {string} [options.logoPosition='bottom-left'] A string representing the position of the Mapbox wordmark on the map. Valid options are `top-left`,`top-right`, `bottom-left`, `bottom-right`.\n * @param {boolean} [options.failIfMajorPerformanceCaveat=false] If `true`, map creation will fail if the performance of Mapbox\n *   GL JS would be dramatically worse than expected (i.e. a software renderer would be used).\n * @param {boolean} [options.preserveDrawingBuffer=false] If `true`, the map's canvas can be exported to a PNG using `map.getCanvas().toDataURL()`. This is `false` by default as a performance optimization.\n * @param {boolean} [options.refreshExpiredTiles=true] If `false`, the map won't attempt to re-request tiles once they expire per their HTTP `cacheControl`/`expires` headers.\n * @param {LngLatBoundsLike} [options.maxBounds] If set, the map will be constrained to the given bounds.\n * @param {boolean|Object} [options.scrollZoom=true] If `true`, the \"scroll to zoom\" interaction is enabled. An `Object` value is passed as options to {@link ScrollZoomHandler#enable}.\n * @param {boolean} [options.boxZoom=true] If `true`, the \"box zoom\" interaction is enabled (see {@link BoxZoomHandler}).\n * @param {boolean} [options.dragRotate=true] If `true`, the \"drag to rotate\" interaction is enabled (see {@link DragRotateHandler}).\n * @param {boolean} [options.dragPan=true] If `true`, the \"drag to pan\" interaction is enabled (see {@link DragPanHandler}).\n * @param {boolean} [options.keyboard=true] If `true`, keyboard shortcuts are enabled (see {@link KeyboardHandler}).\n * @param {boolean} [options.doubleClickZoom=true] If `true`, the \"double click to zoom\" interaction is enabled (see {@link DoubleClickZoomHandler}).\n * @param {boolean|Object} [options.touchZoomRotate=true] If `true`, the \"pinch to rotate and zoom\" interaction is enabled. An `Object` value is passed as options to {@link TouchZoomRotateHandler#enable}.\n * @param {boolean} [options.trackResize=true]  If `true`, the map will automatically resize when the browser window resizes.\n * @param {LngLatLike} [options.center=[0, 0]] The inital geographical centerpoint of the map. If `center` is not specified in the constructor options, Mapbox GL JS will look for it in the map's style object. If it is not specified in the style, either, it will default to `[0, 0]` Note: Mapbox GL uses longitude, latitude coordinate order (as opposed to latitude, longitude) to match GeoJSON.\n * @param {number} [options.zoom=0] The initial zoom level of the map. If `zoom` is not specified in the constructor options, Mapbox GL JS will look for it in the map's style object. If it is not specified in the style, either, it will default to `0`.\n * @param {number} [options.bearing=0] The initial bearing (rotation) of the map, measured in degrees counter-clockwise from north. If `bearing` is not specified in the constructor options, Mapbox GL JS will look for it in the map's style object. If it is not specified in the style, either, it will default to `0`.\n * @param {number} [options.pitch=0] The initial pitch (tilt) of the map, measured in degrees away from the plane of the screen (0-60). If `pitch` is not specified in the constructor options, Mapbox GL JS will look for it in the map's style object. If it is not specified in the style, either, it will default to `0`.\n * @param {LngLatBoundsLike} [options.bounds] The initial bounds of the map. If `bounds` is specified, it overrides `center` and `zoom` constructor options.\n * @param {Object} [options.fitBoundsOptions] A [`fitBounds`](#Map#fitBounds) options object to use _only_ when fitting the initial `bounds` provided above.\n * @param {boolean} [options.renderWorldCopies=true]  If `true`, multiple copies of the world will be rendered, when zoomed out.\n * @param {number} [options.maxTileCacheSize=null]  The maximum number of tiles stored in the tile cache for a given source. If omitted, the cache will be dynamically sized based on the current viewport.\n * @param {string} [options.localIdeographFontFamily=null] If specified, defines a CSS font-family\n *   for locally overriding generation of glyphs in the 'CJK Unified Ideographs' and 'Hangul Syllables' ranges.\n *   In these ranges, font settings from the map's style will be ignored, except for font-weight keywords (light/regular/medium/bold).\n *   The purpose of this option is to avoid bandwidth-intensive glyph server requests. (see [Use locally generated ideographs](https://www.mapbox.com/mapbox-gl-js/example/local-ideographs))\n * @param {RequestTransformFunction} [options.transformRequest=null] A callback run before the Map makes a request for an external URL. The callback can be used to modify the url, set headers, or set the credentials property for cross-origin requests.\n *   Expected to return an object with a `url` property and optionally `headers` and `credentials` properties.\n * @param {boolean} [options.collectResourceTiming=false] If `true`, Resource Timing API information will be collected for requests made by GeoJSON and Vector Tile web workers (this information is normally inaccessible from the main Javascript thread). Information will be returned in a `resourceTiming` property of relevant `data` events.\n * @param {number} [options.fadeDuration=300] Controls the duration of the fade-in/fade-out animation for label collisions, in milliseconds. This setting affects all symbol layers. This setting does not affect the duration of runtime styling transitions or raster tile cross-fading.\n * @param {boolean} [options.crossSourceCollisions=true] If `true`, symbols from multiple sources can collide with each other during collision detection. If `false`, collision detection is run separately for the symbols in each source.\n * @example\n * var map = new mapboxgl.Map({\n *   container: 'map',\n *   center: [-122.420679, 37.772537],\n *   zoom: 13,\n *   style: style_object,\n *   hash: true,\n *   transformRequest: (url, resourceType)=> {\n *     if(resourceType === 'Source' && url.startsWith('http://myHost')) {\n *       return {\n *        url: url.replace('http', 'https'),\n *        headers: { 'my-custom-header': true},\n *        credentials: 'include'  // Include cookies for cross-origin requests\n *      }\n *     }\n *   }\n * });\n * @see [Display a map](https://www.mapbox.com/mapbox-gl-js/examples/)\n */\nclass Map extends Camera {\n    style: Style;\n    painter: Painter;\n\n    _container: HTMLElement;\n    _missingCSSCanary: HTMLElement;\n    _canvasContainer: HTMLElement;\n    _controlContainer: HTMLElement;\n    _controlPositions: {[string]: HTMLElement};\n    _interactive: ?boolean;\n    _showTileBoundaries: ?boolean;\n    _showCollisionBoxes: ?boolean;\n    _showOverdrawInspector: boolean;\n    _repaint: ?boolean;\n    _vertices: ?boolean;\n    _canvas: HTMLCanvasElement;\n    _transformRequest: RequestTransformFunction;\n    _maxTileCacheSize: number;\n    _frame: ?Cancelable;\n    _styleDirty: ?boolean;\n    _sourcesDirty: ?boolean;\n    _placementDirty: ?boolean;\n    _loaded: boolean;\n    _trackResize: boolean;\n    _preserveDrawingBuffer: boolean;\n    _failIfMajorPerformanceCaveat: boolean;\n    _refreshExpiredTiles: boolean;\n    _hash: Hash;\n    _delegatedListeners: any;\n    _fadeDuration: number;\n    _crossSourceCollisions: boolean;\n    _crossFadingFactor: number;\n    _collectResourceTiming: boolean;\n    _renderTaskQueue: TaskQueue;\n    _controls: Array<IControl>;\n    _mapId: number;\n\n    /**\n     * The map's {@link ScrollZoomHandler}, which implements zooming in and out with a scroll wheel or trackpad.\n     */\n    scrollZoom: ScrollZoomHandler;\n\n    /**\n     * The map's {@link BoxZoomHandler}, which implements zooming using a drag gesture with the Shift key pressed.\n     */\n    boxZoom: BoxZoomHandler;\n\n    /**\n     * The map's {@link DragRotateHandler}, which implements rotating the map while dragging with the right\n     * mouse button or with the Control key pressed.\n     */\n    dragRotate: DragRotateHandler;\n\n    /**\n     * The map's {@link DragPanHandler}, which implements dragging the map with a mouse or touch gesture.\n     */\n    dragPan: DragPanHandler;\n\n    /**\n     * The map's {@link KeyboardHandler}, which allows the user to zoom, rotate, and pan the map using keyboard\n     * shortcuts.\n     */\n    keyboard: KeyboardHandler;\n\n    /**\n     * The map's {@link DoubleClickZoomHandler}, which allows the user to zoom by double clicking.\n     */\n    doubleClickZoom: DoubleClickZoomHandler;\n\n    /**\n     * The map's {@link TouchZoomRotateHandler}, which allows the user to zoom or rotate the map with touch gestures.\n     */\n    touchZoomRotate: TouchZoomRotateHandler;\n\n    constructor(options: MapOptions) {\n        options = extend({}, defaultOptions, options);\n\n        if (options.minZoom != null && options.maxZoom != null && options.minZoom > options.maxZoom) {\n            throw new Error(`maxZoom must be greater than minZoom`);\n        }\n\n        const transform = new Transform(options.minZoom, options.maxZoom, options.renderWorldCopies);\n        super(transform, options);\n\n        this._interactive = options.interactive;\n        this._maxTileCacheSize = options.maxTileCacheSize;\n        this._failIfMajorPerformanceCaveat = options.failIfMajorPerformanceCaveat;\n        this._preserveDrawingBuffer = options.preserveDrawingBuffer;\n        this._trackResize = options.trackResize;\n        this._bearingSnap = options.bearingSnap;\n        this._refreshExpiredTiles = options.refreshExpiredTiles;\n        this._fadeDuration = options.fadeDuration;\n        this._crossSourceCollisions = options.crossSourceCollisions;\n        this._crossFadingFactor = 1;\n        this._collectResourceTiming = options.collectResourceTiming;\n        this._renderTaskQueue = new TaskQueue();\n        this._controls = [];\n        this._mapId = uniqueId();\n\n        const transformRequestFn = options.transformRequest;\n        this._transformRequest = transformRequestFn ?\n            (url, type) => transformRequestFn(url, type) || ({ url }) :\n            (url) => ({ url });\n\n        if (typeof options.container === 'string') {\n            this._container = window.document.getElementById(options.container);\n            if (!this._container) {\n                throw new Error(`Container '${options.container}' not found.`);\n            }\n        } else if (options.container instanceof HTMLElement) {\n            this._container = options.container;\n        } else {\n            throw new Error(`Invalid type: 'container' must be a String or HTMLElement.`);\n        }\n\n        if (options.maxBounds) {\n            this.setMaxBounds(options.maxBounds);\n        }\n\n        bindAll([\n            '_onWindowOnline',\n            '_onWindowResize',\n            '_contextLost',\n            '_contextRestored'\n        ], this);\n\n        this._setupContainer();\n        this._setupPainter();\n        if (this.painter === undefined) {\n            throw new Error(`Failed to initialize WebGL.`);\n        }\n\n        this.on('move', () => this._update(false));\n        this.on('moveend', () => this._update(false));\n        this.on('zoom', () => this._update(true));\n\n        if (typeof window !== 'undefined') {\n            window.addEventListener('online', this._onWindowOnline, false);\n            window.addEventListener('resize', this._onWindowResize, false);\n        }\n\n        bindHandlers(this, options);\n\n        this._hash = options.hash && (new Hash()).addTo(this);\n        // don't set position from options if set through hash\n        if (!this._hash || !this._hash._onHashChange()) {\n            this.jumpTo({\n                center: options.center,\n                zoom: options.zoom,\n                bearing: options.bearing,\n                pitch: options.pitch\n            });\n\n            if (options.bounds) {\n                this.resize();\n                this.fitBounds(options.bounds, extend({}, options.fitBoundsOptions, { duration: 0 }));\n            }\n        }\n\n        this.resize();\n\n        if (options.style) this.setStyle(options.style, { localIdeographFontFamily: options.localIdeographFontFamily });\n\n        if (options.attributionControl)\n            this.addControl(new AttributionControl({ customAttribution: options.customAttribution }));\n\n        this.addControl(new LogoControl(), options.logoPosition);\n\n        this.on('style.load', () => {\n            if (this.transform.unmodified) {\n                this.jumpTo((this.style.stylesheet: any));\n            }\n        });\n        this.on('data', (event: MapDataEvent) => {\n            this._update(event.dataType === 'style');\n            this.fire(new Event(`${event.dataType}data`, event));\n        });\n        this.on('dataloading', (event: MapDataEvent) => {\n            this.fire(new Event(`${event.dataType}dataloading`, event));\n        });\n    }\n\n    /*\n    * Returns a unique number for this map instance which is used for the MapLoadEvent\n    * to make sure we only fire one event per instantiated map object.\n    * @private\n    * @returns {number}\n    */\n    _getMapId() {\n        return this._mapId;\n    }\n\n    /**\n     * Adds a {@link IControl} to the map, calling `control.onAdd(this)`.\n     *\n     * @param {IControl} control The {@link IControl} to add.\n     * @param {string} [position] position on the map to which the control will be added.\n     * Valid values are `'top-left'`, `'top-right'`, `'bottom-left'`, and `'bottom-right'`. Defaults to `'top-right'`.\n     * @returns {Map} `this`\n     * @see [Display map navigation controls](https://www.mapbox.com/mapbox-gl-js/example/navigation/)\n     */\n    addControl(control: IControl, position?: ControlPosition) {\n        if (position === undefined && control.getDefaultPosition) {\n            position = control.getDefaultPosition();\n        }\n        if (position === undefined) {\n            position = 'top-right';\n        }\n        if (!control || !control.onAdd) {\n            return this.fire(new ErrorEvent(new Error(\n                'Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.')));\n        }\n        const controlElement = control.onAdd(this);\n        this._controls.push(control);\n\n        const positionContainer = this._controlPositions[position];\n        if (position.indexOf('bottom') !== -1) {\n            positionContainer.insertBefore(controlElement, positionContainer.firstChild);\n        } else {\n            positionContainer.appendChild(controlElement);\n        }\n        return this;\n    }\n\n    /**\n     * Removes the control from the map.\n     *\n     * @param {IControl} control The {@link IControl} to remove.\n     * @returns {Map} `this`\n     */\n    removeControl(control: IControl) {\n        if (!control || !control.onRemove) {\n            return this.fire(new ErrorEvent(new Error(\n                'Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.')));\n        }\n        const ci = this._controls.indexOf(control);\n        if (ci > -1) this._controls.splice(ci, 1);\n        control.onRemove(this);\n        return this;\n    }\n\n    /**\n     * Resizes the map according to the dimensions of its\n     * `container` element.\n     *\n     * This method must be called after the map's `container` is resized by another script,\n     * or when the map is shown after being initially hidden with CSS.\n     *\n     * @param eventData Additional properties to be added to event objects of events triggered by this method.\n     * @returns {Map} `this`\n     */\n    resize(eventData?: Object) {\n        const dimensions = this._containerDimensions();\n        const width = dimensions[0];\n        const height = dimensions[1];\n\n        this._resizeCanvas(width, height);\n        this.transform.resize(width, height);\n        this.painter.resize(width, height);\n\n        this.fire(new Event('movestart', eventData))\n            .fire(new Event('move', eventData))\n            .fire(new Event('resize', eventData))\n            .fire(new Event('moveend', eventData));\n        return this;\n    }\n\n    /**\n     * Returns the map's geographical bounds. When the bearing or pitch is non-zero, the visible region is not\n     * an axis-aligned rectangle, and the result is the smallest bounds that encompasses the visible region.\n     */\n    getBounds(): LngLatBounds {\n        return this.transform.getBounds();\n    }\n\n    /**\n     * Returns the maximum geographical bounds the map is constrained to, or `null` if none set.\n     */\n    getMaxBounds(): LngLatBounds | null {\n        return this.transform.getMaxBounds();\n    }\n\n    /**\n     * Sets or clears the map's geographical bounds.\n     *\n     * Pan and zoom operations are constrained within these bounds.\n     * If a pan or zoom is performed that would\n     * display regions outside these bounds, the map will\n     * instead display a position and zoom level\n     * as close as possible to the operation's request while still\n     * remaining within the bounds.\n     *\n     * @param {LngLatBoundsLike | null | undefined} bounds The maximum bounds to set. If `null` or `undefined` is provided, the function removes the map's maximum bounds.\n     * @returns {Map} `this`\n     */\n    setMaxBounds(bounds: LngLatBoundsLike) {\n        this.transform.setMaxBounds(LngLatBounds.convert(bounds));\n        return this._update();\n    }\n\n    /**\n     * Sets or clears the map's minimum zoom level.\n     * If the map's current zoom level is lower than the new minimum,\n     * the map will zoom to the new minimum.\n     *\n     * @param {number | null | undefined} minZoom The minimum zoom level to set (0-24).\n     *   If `null` or `undefined` is provided, the function removes the current minimum zoom (i.e. sets it to 0).\n     * @returns {Map} `this`\n     */\n    setMinZoom(minZoom?: ?number) {\n\n        minZoom = minZoom === null || minZoom === undefined ? defaultMinZoom : minZoom;\n\n        if (minZoom >= defaultMinZoom && minZoom <= this.transform.maxZoom) {\n            this.transform.minZoom = minZoom;\n            this._update();\n\n            if (this.getZoom() < minZoom) this.setZoom(minZoom);\n\n            return this;\n\n        } else throw new Error(`minZoom must be between ${defaultMinZoom} and the current maxZoom, inclusive`);\n    }\n\n    /**\n     * Returns the map's minimum allowable zoom level.\n     *\n     * @returns {number} minZoom\n     */\n    getMinZoom() { return this.transform.minZoom; }\n\n    /**\n     * Sets or clears the map's maximum zoom level.\n     * If the map's current zoom level is higher than the new maximum,\n     * the map will zoom to the new maximum.\n     *\n     * @param {number | null | undefined} maxZoom The maximum zoom level to set.\n     *   If `null` or `undefined` is provided, the function removes the current maximum zoom (sets it to 22).\n     * @returns {Map} `this`\n     */\n    setMaxZoom(maxZoom?: ?number) {\n\n        maxZoom = maxZoom === null || maxZoom === undefined ? defaultMaxZoom : maxZoom;\n\n        if (maxZoom >= this.transform.minZoom) {\n            this.transform.maxZoom = maxZoom;\n            this._update();\n\n            if (this.getZoom() > maxZoom) this.setZoom(maxZoom);\n\n            return this;\n\n        } else throw new Error(`maxZoom must be greater than the current minZoom`);\n    }\n\n    /**\n     * Returns the state of renderWorldCopies.\n     *\n     * @returns {boolean} renderWorldCopies\n     */\n    getRenderWorldCopies() { return this.transform.renderWorldCopies; }\n\n    /**\n     * Sets the state of renderWorldCopies.\n     *\n     * @param {boolean} renderWorldCopies If `true`, multiple copies of the world will be rendered, when zoomed out. `undefined` is treated as `true`, `null` is treated as `false`.\n     * @returns {Map} `this`\n     */\n    setRenderWorldCopies(renderWorldCopies?: ?boolean) {\n        this.transform.renderWorldCopies = renderWorldCopies;\n        return this._update();\n    }\n\n    /**\n     * Returns the map's maximum allowable zoom level.\n     *\n     * @returns {number} maxZoom\n     */\n    getMaxZoom() { return this.transform.maxZoom; }\n\n    /**\n     * Returns a {@link Point} representing pixel coordinates, relative to the map's `container`,\n     * that correspond to the specified geographical location.\n     *\n     * @param {LngLatLike} lnglat The geographical location to project.\n     * @returns {Point} The {@link Point} corresponding to `lnglat`, relative to the map's `container`.\n     */\n    project(lnglat: LngLatLike) {\n        return this.transform.locationPoint(LngLat.convert(lnglat));\n    }\n\n    /**\n     * Returns a {@link LngLat} representing geographical coordinates that correspond\n     * to the specified pixel coordinates.\n     *\n     * @param {PointLike} point The pixel coordinates to unproject.\n     * @returns {LngLat} The {@link LngLat} corresponding to `point`.\n     * @see [Show polygon information on click](https://www.mapbox.com/mapbox-gl-js/example/polygon-popup-on-click/)\n     */\n    unproject(point: PointLike) {\n        return this.transform.pointLocation(Point.convert(point));\n    }\n\n    /**\n     * Returns true if the map is panning, zooming, rotating, or pitching due to a camera animation or user gesture.\n     */\n    isMoving(): boolean {\n        return this._moving ||\n            this.dragPan.isActive() ||\n            this.dragRotate.isActive() ||\n            this.scrollZoom.isActive();\n    }\n\n    /**\n     * Returns true if the map is zooming due to a camera animation or user gesture.\n     */\n    isZooming(): boolean {\n        return this._zooming ||\n            this.scrollZoom.isZooming();\n    }\n\n    /**\n     * Returns true if the map is rotating due to a camera animation or user gesture.\n     */\n    isRotating(): boolean {\n        return this._rotating ||\n            this.dragRotate.isActive();\n    }\n\n    /**\n     * Adds a listener for events of a specified type.\n     *\n     * @method\n     * @name on\n     * @memberof Map\n     * @instance\n     * @param {string} type The event type to add a listen for.\n     * @param {Function} listener The function to be called when the event is fired.\n     *   The listener function is called with the data object passed to `fire`,\n     *   extended with `target` and `type` properties.\n     * @returns {Map} `this`\n     */\n\n    /**\n     * Adds a listener for events of a specified type occurring on features in a specified style layer.\n     *\n     * @param {string} type The event type to listen for; one of `'mousedown'`, `'mouseup'`, `'click'`, `'dblclick'`,\n     * `'mousemove'`, `'mouseenter'`, `'mouseleave'`, `'mouseover'`, `'mouseout'`, `'contextmenu'`, `'touchstart'`,\n     * `'touchend'`, or `'touchcancel'`. `mouseenter` and `mouseover` events are triggered when the cursor enters\n     * a visible portion of the specified layer from outside that layer or outside the map canvas. `mouseleave`\n     * and `mouseout` events are triggered when the cursor leaves a visible portion of the specified layer, or leaves\n     * the map canvas.\n     * @param {string} layer The ID of a style layer. Only events whose location is within a visible\n     * feature in this layer will trigger the listener. The event will have a `features` property containing\n     * an array of the matching features.\n     * @param {Function} listener The function to be called when the event is fired.\n     * @returns {Map} `this`\n     */\n    on(type: MapEvent, layer: any, listener: any) {\n        if (listener === undefined) {\n            return super.on(type, layer);\n        }\n\n        const delegatedListener = (() => {\n            if (type === 'mouseenter' || type === 'mouseover') {\n                let mousein = false;\n                const mousemove = (e) => {\n                    const features = this.getLayer(layer) ? this.queryRenderedFeatures(e.point, {layers: [layer]}) : [];\n                    if (!features.length) {\n                        mousein = false;\n                    } else if (!mousein) {\n                        mousein = true;\n                        listener.call(this, new MapMouseEvent(type, this, e.originalEvent, {features}));\n                    }\n                };\n                const mouseout = () => {\n                    mousein = false;\n                };\n                return {layer, listener, delegates: {mousemove, mouseout}};\n            } else if (type === 'mouseleave' || type === 'mouseout') {\n                let mousein = false;\n                const mousemove = (e) => {\n                    const features = this.getLayer(layer) ? this.queryRenderedFeatures(e.point, {layers: [layer]}) : [];\n                    if (features.length) {\n                        mousein = true;\n                    } else if (mousein) {\n                        mousein = false;\n                        listener.call(this, new MapMouseEvent(type, this, e.originalEvent));\n                    }\n                };\n                const mouseout = (e) => {\n                    if (mousein) {\n                        mousein = false;\n                        listener.call(this, new MapMouseEvent(type, this, e.originalEvent));\n                    }\n                };\n                return {layer, listener, delegates: {mousemove, mouseout}};\n            } else {\n                const delegate = (e) => {\n                    const features = this.getLayer(layer) ? this.queryRenderedFeatures(e.point, {layers: [layer]}) : [];\n                    if (features.length) {\n                        // Here we need to mutate the original event, so that preventDefault works as expected.\n                        e.features = features;\n                        listener.call(this, e);\n                        delete e.features;\n                    }\n                };\n                return {layer, listener, delegates: {[type]: delegate}};\n            }\n        })();\n\n        this._delegatedListeners = this._delegatedListeners || {};\n        this._delegatedListeners[type] = this._delegatedListeners[type] || [];\n        this._delegatedListeners[type].push(delegatedListener);\n\n        for (const event in delegatedListener.delegates) {\n            this.on((event: any), delegatedListener.delegates[event]);\n        }\n\n        return this;\n    }\n\n    /**\n     * Removes an event listener previously added with `Map#on`.\n     *\n     * @method\n     * @name off\n     * @memberof Map\n     * @instance\n     * @param {string} type The event type previously used to install the listener.\n     * @param {Function} listener The function previously installed as a listener.\n     * @returns {Map} `this`\n     */\n\n    /**\n     * Removes an event listener for layer-specific events previously added with `Map#on`.\n     *\n     * @param {string} type The event type previously used to install the listener.\n     * @param {string} layer The layer ID previously used to install the listener.\n     * @param {Function} listener The function previously installed as a listener.\n     * @returns {Map} `this`\n     */\n    off(type: MapEvent, layer: any, listener: any) {\n        if (listener === undefined) {\n            return super.off(type, layer);\n        }\n\n        if (this._delegatedListeners && this._delegatedListeners[type]) {\n            const listeners = this._delegatedListeners[type];\n            for (let i = 0; i < listeners.length; i++) {\n                const delegatedListener = listeners[i];\n                if (delegatedListener.layer === layer && delegatedListener.listener === listener) {\n                    for (const event in delegatedListener.delegates) {\n                        this.off((event: any), delegatedListener.delegates[event]);\n                    }\n                    listeners.splice(i, 1);\n                    return this;\n                }\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Returns an array of [GeoJSON](http://geojson.org/)\n     * [Feature objects](https://tools.ietf.org/html/rfc7946#section-3.2)\n     * representing visible features that satisfy the query parameters.\n     *\n     * @param {PointLike|Array<PointLike>} [geometry] - The geometry of the query region:\n     * either a single point or southwest and northeast points describing a bounding box.\n     * Omitting this parameter (i.e. calling {@link Map#queryRenderedFeatures} with zero arguments,\n     * or with only a `options` argument) is equivalent to passing a bounding box encompassing the entire\n     * map viewport.\n     * @param {Object} [options]\n     * @param {Array<string>} [options.layers] An array of style layer IDs for the query to inspect.\n     *   Only features within these layers will be returned. If this parameter is undefined, all layers will be checked.\n     * @param {Array} [options.filter] A [filter](https://www.mapbox.com/mapbox-gl-js/style-spec/#other-filter)\n     *   to limit query results.\n     *\n     * @returns {Array<Object>} An array of [GeoJSON](http://geojson.org/)\n     * [feature objects](https://tools.ietf.org/html/rfc7946#section-3.2).\n     *\n     * The `properties` value of each returned feature object contains the properties of its source feature. For GeoJSON sources, only\n     * string and numeric property values are supported (i.e. `null`, `Array`, and `Object` values are not supported).\n     *\n     * Each feature includes top-level `layer`, `source`, and `sourceLayer` properties. The `layer` property is an object\n     * representing the style layer to  which the feature belongs. Layout and paint properties in this object contain values\n     * which are fully evaluated for the given zoom level and feature.\n     *\n     * Features from layers whose `visibility` property is `\"none\"`, or from layers whose zoom range excludes the\n     * current zoom level are not included. Symbol features that have been hidden due to text or icon collision are\n     * not included. Features from all other layers are included, including features that may have no visible\n     * contribution to the rendered result; for example, because the layer's opacity or color alpha component is set to\n     * 0.\n     *\n     * The topmost rendered feature appears first in the returned array, and subsequent features are sorted by\n     * descending z-order. Features that are rendered multiple times (due to wrapping across the antimeridian at low\n     * zoom levels) are returned only once (though subject to the following caveat).\n     *\n     * Because features come from tiled vector data or GeoJSON data that is converted to tiles internally, feature\n     * geometries may be split or duplicated across tile boundaries and, as a result, features may appear multiple\n     * times in query results. For example, suppose there is a highway running through the bounding rectangle of a query.\n     * The results of the query will be those parts of the highway that lie within the map tiles covering the bounding\n     * rectangle, even if the highway extends into other tiles, and the portion of the highway within each map tile\n     * will be returned as a separate feature. Similarly, a point feature near a tile boundary may appear in multiple\n     * tiles due to tile buffering.\n     *\n     * @example\n     * // Find all features at a point\n     * var features = map.queryRenderedFeatures(\n     *   [20, 35],\n     *   { layers: ['my-layer-name'] }\n     * );\n     *\n     * @example\n     * // Find all features within a static bounding box\n     * var features = map.queryRenderedFeatures(\n     *   [[10, 20], [30, 50]],\n     *   { layers: ['my-layer-name'] }\n     * );\n     *\n     * @example\n     * // Find all features within a bounding box around a point\n     * var width = 10;\n     * var height = 20;\n     * var features = map.queryRenderedFeatures([\n     *   [point.x - width / 2, point.y - height / 2],\n     *   [point.x + width / 2, point.y + height / 2]\n     * ], { layers: ['my-layer-name'] });\n     *\n     * @example\n     * // Query all rendered features from a single layer\n     * var features = map.queryRenderedFeatures({ layers: ['my-layer-name'] });\n     * @see [Get features under the mouse pointer](https://www.mapbox.com/mapbox-gl-js/example/queryrenderedfeatures/)\n     * @see [Highlight features within a bounding box](https://www.mapbox.com/mapbox-gl-js/example/using-box-queryrenderedfeatures/)\n     * @see [Center the map on a clicked symbol](https://www.mapbox.com/mapbox-gl-js/example/center-on-symbol/)\n     */\n    queryRenderedFeatures(geometry?: PointLike | [PointLike, PointLike], options?: Object) {\n        // The first parameter can be omitted entirely, making this effectively an overloaded method\n        // with two signatures:\n        //\n        //     queryRenderedFeatures(geometry: PointLike | [PointLike, PointLike], options?: Object)\n        //     queryRenderedFeatures(options?: Object)\n        //\n        // There no way to express that in a way that's compatible with both flow and documentation.js.\n        // Related: https://github.com/facebook/flow/issues/1556\n\n        if (!this.style) {\n            return [];\n        }\n\n        if (options === undefined && geometry !== undefined && !(geometry instanceof Point) && !Array.isArray(geometry)) {\n            options = (geometry: Object);\n            geometry = undefined;\n        }\n\n        options = options || {};\n        geometry = geometry || [[0, 0], [this.transform.width, this.transform.height]];\n\n        let queryGeometry;\n        if (geometry instanceof Point || typeof geometry[0] === 'number') {\n            queryGeometry = [Point.convert(geometry)];\n        } else {\n            const tl = Point.convert(geometry[0]);\n            const br = Point.convert(geometry[1]);\n            queryGeometry = [tl, new Point(br.x, tl.y), br, new Point(tl.x, br.y), tl];\n        }\n\n        return this.style.queryRenderedFeatures(queryGeometry, options, this.transform);\n    }\n\n    /**\n     * Returns an array of [GeoJSON](http://geojson.org/)\n     * [Feature objects](https://tools.ietf.org/html/rfc7946#section-3.2)\n     * representing features within the specified vector tile or GeoJSON source that satisfy the query parameters.\n     *\n     * @param {string} sourceID The ID of the vector tile or GeoJSON source to query.\n     * @param {Object} [parameters]\n     * @param {string} [parameters.sourceLayer] The name of the vector tile layer to query. *For vector tile\n     *   sources, this parameter is required.* For GeoJSON sources, it is ignored.\n     * @param {Array} [parameters.filter] A [filter](https://www.mapbox.com/mapbox-gl-js/style-spec/#other-filter)\n     *   to limit query results.\n     *\n     * @returns {Array<Object>} An array of [GeoJSON](http://geojson.org/)\n     * [Feature objects](https://tools.ietf.org/html/rfc7946#section-3.2).\n     *\n     * In contrast to {@link Map#queryRenderedFeatures}, this function\n     * returns all features matching the query parameters,\n     * whether or not they are rendered by the current style (i.e. visible). The domain of the query includes all currently-loaded\n     * vector tiles and GeoJSON source tiles: this function does not check tiles outside the currently\n     * visible viewport.\n     *\n     * Because features come from tiled vector data or GeoJSON data that is converted to tiles internally, feature\n     * geometries may be split or duplicated across tile boundaries and, as a result, features may appear multiple\n     * times in query results. For example, suppose there is a highway running through the bounding rectangle of a query.\n     * The results of the query will be those parts of the highway that lie within the map tiles covering the bounding\n     * rectangle, even if the highway extends into other tiles, and the portion of the highway within each map tile\n     * will be returned as a separate feature. Similarly, a point feature near a tile boundary may appear in multiple\n     * tiles due to tile buffering.\n     * @see [Filter features within map view](https://www.mapbox.com/mapbox-gl-js/example/filter-features-within-map-view/)\n     * @see [Highlight features containing similar data](https://www.mapbox.com/mapbox-gl-js/example/query-similar-features/)\n     */\n    querySourceFeatures(sourceID: string, parameters: ?{sourceLayer: ?string, filter: ?Array<any>}) {\n        return this.style.querySourceFeatures(sourceID, parameters);\n    }\n\n    /**\n     * Updates the map's Mapbox style object with a new value. If a style already is set and options.diff is true,\n     * this compares the style against the map's current state and performs only the changes necessary to make\n     * the map style match the desired state.\n     *\n     * @param style A JSON object conforming to the schema described in the\n     *   [Mapbox Style Specification](https://mapbox.com/mapbox-gl-style-spec/), or a URL to such JSON.\n     * @param {Object} [options]\n     * @param {boolean} [options.diff=true] If false, force a 'full' update, removing the current style\n     *   and building the given one instead of attempting a diff-based update.\n     * @param {string} [options.localIdeographFontFamily=null] If non-null, defines a css font-family\n     *   for locally overriding generation of glyphs in the 'CJK Unified Ideographs' and 'Hangul Syllables'\n     *   ranges. Forces a full update.\n     * @returns {Map} `this`\n     * @see [Change a map's style](https://www.mapbox.com/mapbox-gl-js/example/setstyle/)\n     */\n    setStyle(style: StyleSpecification | string | null, options?: {diff?: boolean} & StyleOptions) {\n        if ((!options || (options.diff !== false && !options.localIdeographFontFamily)) && this.style && style) {\n            this._diffStyle(style, options);\n            return this;\n        } else {\n            return this._updateStyle(style, options);\n        }\n    }\n\n    _updateStyle(style: StyleSpecification | string | null,  options?: {diff?: boolean} & StyleOptions) {\n        if (this.style) {\n            this.style.setEventedParent(null);\n            this.style._remove();\n        }\n\n        if (!style) {\n            delete this.style;\n            return this;\n        } else {\n            this.style = new Style(this, options || {});\n        }\n\n        this.style.setEventedParent(this, {style: this.style});\n\n        if (typeof style === 'string') {\n            this.style.loadURL(style);\n        } else {\n            this.style.loadJSON(style);\n        }\n\n        return this;\n    }\n\n    _diffStyle(style: StyleSpecification | string,  options?: {diff?: boolean} & StyleOptions) {\n        if (typeof style === 'string') {\n            const url = normalizeStyleURL(style);\n            const request = this._transformRequest(url, ResourceType.Style);\n            getJSON(request, (error: ?Error, json: ?Object) => {\n                if (error) {\n                    this.fire(new ErrorEvent(error));\n                } else if (json) {\n                    this._updateDiff(json, options);\n                }\n            });\n        } else if (typeof style === 'object') {\n            this._updateDiff(style, options);\n        }\n    }\n\n    _updateDiff(style: StyleSpecification,  options?: {diff?: boolean} & StyleOptions) {\n        try {\n            if (this.style.setState(style)) {\n                this._update(true);\n            }\n        } catch (e) {\n            warnOnce(\n                `Unable to perform style diff: ${e.message || e.error || e}.  Rebuilding the style from scratch.`\n            );\n            this._updateStyle(style, options);\n        }\n    }\n\n    /**\n     * Returns the map's Mapbox style object, which can be used to recreate the map's style.\n     *\n     * @returns {Object} The map's style object.\n     */\n    getStyle() {\n        if (this.style) {\n            return this.style.serialize();\n        }\n    }\n\n    /**\n     * Returns a Boolean indicating whether the map's style is fully loaded.\n     *\n     * @returns {boolean} A Boolean indicating whether the style is fully loaded.\n     */\n    isStyleLoaded() {\n        if (!this.style) return warnOnce('There is no style added to the map.');\n        return this.style.loaded();\n    }\n\n    /**\n     * Adds a source to the map's style.\n     *\n     * @param {string} id The ID of the source to add. Must not conflict with existing sources.\n     * @param {Object} source The source object, conforming to the\n     * Mapbox Style Specification's [source definition](https://www.mapbox.com/mapbox-gl-style-spec/#sources) or\n     * {@link CanvasSourceOptions}.\n     * @fires source.add\n     * @returns {Map} `this`\n     * @see [Draw GeoJSON points](https://www.mapbox.com/mapbox-gl-js/example/geojson-markers/)\n     * @see [Style circles using data-driven styling](https://www.mapbox.com/mapbox-gl-js/example/data-driven-circle-colors/)\n     * @see [Set a point after Geocoder result](https://www.mapbox.com/mapbox-gl-js/example/point-from-geocoder-result/)\n     */\n    addSource(id: string, source: SourceSpecification) {\n        this.style.addSource(id, source);\n        return this._update(true);\n    }\n\n    /**\n     * Returns a Boolean indicating whether the source is loaded.\n     *\n     * @param {string} id The ID of the source to be checked.\n     * @returns {boolean} A Boolean indicating whether the source is loaded.\n     */\n    isSourceLoaded(id: string) {\n        const source = this.style && this.style.sourceCaches[id];\n        if (source === undefined) {\n            this.fire(new ErrorEvent(new Error(`There is no source with ID '${id}'`)));\n            return;\n        }\n        return source.loaded();\n    }\n\n    /**\n     * Returns a Boolean indicating whether all tiles in the viewport from all sources on\n     * the style are loaded.\n     *\n     * @returns {boolean} A Boolean indicating whether all tiles are loaded.\n     */\n\n    areTilesLoaded() {\n        const sources = this.style && this.style.sourceCaches;\n        for (const id in sources) {\n            const source = sources[id];\n            const tiles = source._tiles;\n            for (const t in tiles) {\n                const tile = tiles[t];\n                if (!(tile.state === 'loaded' || tile.state === 'errored')) return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Adds a [custom source type](#Custom Sources), making it available for use with\n     * {@link Map#addSource}.\n     * @private\n     * @param {string} name The name of the source type; source definition objects use this name in the `{type: ...}` field.\n     * @param {Function} SourceType A {@link Source} constructor.\n     * @param {Function} callback Called when the source type is ready or with an error argument if there is an error.\n     */\n    addSourceType(name: string, SourceType: any, callback: Function) {\n        return this.style.addSourceType(name, SourceType, callback);\n    }\n\n    /**\n     * Removes a source from the map's style.\n     *\n     * @param {string} id The ID of the source to remove.\n     * @returns {Map} `this`\n     */\n    removeSource(id: string) {\n        this.style.removeSource(id);\n        return this._update(true);\n    }\n\n    /**\n     * Returns the source with the specified ID in the map's style.\n     *\n     * @param {string} id The ID of the source to get.\n     * @returns {?Object} The style source with the specified ID, or `undefined`\n     *   if the ID corresponds to no existing sources.\n     * @see [Create a draggable point](https://www.mapbox.com/mapbox-gl-js/example/drag-a-point/)\n     * @see [Animate a point](https://www.mapbox.com/mapbox-gl-js/example/animate-point-along-line/)\n     * @see [Add live realtime data](https://www.mapbox.com/mapbox-gl-js/example/live-geojson/)\n     */\n    getSource(id: string) {\n        return this.style.getSource(id);\n    }\n\n    /**\n     * Add an image to the style. This image can be used in `icon-image`,\n     * `background-pattern`, `fill-pattern`, and `line-pattern`. An\n     * {@link Map#error} event will be fired if there is not enough space in the\n     * sprite to add this image.\n     *\n     * @see [Add an icon to the map](https://www.mapbox.com/mapbox-gl-js/example/add-image/)\n     * @see [Add a generated icon to the map](https://www.mapbox.com/mapbox-gl-js/example/add-image-generated/)\n     * @param id The ID of the image.\n     * @param image The image as an `HTMLImageElement`, `ImageData`, or object with `width`, `height`, and `data`\n     * properties with the same format as `ImageData`.\n     * @param options\n     * @param options.pixelRatio The ratio of pixels in the image to physical pixels on the screen\n     * @param options.sdf Whether the image should be interpreted as an SDF image\n     */\n    addImage(id: string,\n             image: HTMLImageElement | ImageData | {width: number, height: number, data: Uint8Array | Uint8ClampedArray},\n             {pixelRatio = 1, sdf = false}: {pixelRatio?: number, sdf?: boolean} = {}) {\n        if (image instanceof HTMLImageElement) {\n            const {width, height, data} = browser.getImageData(image);\n            this.style.addImage(id, { data: new RGBAImage({width, height}, data), pixelRatio, sdf });\n        } else if (image.width === undefined || image.height === undefined) {\n            return this.fire(new ErrorEvent(new Error(\n                'Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, ' +\n                'or object with `width`, `height`, and `data` properties with the same format as `ImageData`')));\n        } else {\n            const {width, height, data} = image;\n            this.style.addImage(id, { data: new RGBAImage({width, height}, new Uint8Array(data)), pixelRatio, sdf });\n        }\n    }\n\n    /**\n     * Define wether the image has been added or not\n     *\n     * @param id The ID of the image.\n     */\n    hasImage(id: string): boolean {\n        if (!id) {\n            this.fire(new ErrorEvent(new Error('Missing required image id')));\n            return false;\n        }\n\n        return !!this.style.getImage(id);\n    }\n\n    /**\n     * Remove an image from the style (such as one used by `icon-image` or `background-pattern`).\n     *\n     * @param id The ID of the image.\n     */\n    removeImage(id: string) {\n        this.style.removeImage(id);\n    }\n\n    /**\n     * Load an image from an external URL for use with `Map#addImage`. External\n     * domains must support [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS).\n     *\n     * @param {string} url The URL of the image file. Image file must be in png, webp, or jpg format.\n     * @param {Function} callback Expecting `callback(error, data)`. Called when the image has loaded or with an error argument if there is an error.\n     * @see [Add an icon to the map](https://www.mapbox.com/mapbox-gl-js/example/add-image/)\n     */\n    loadImage(url: string, callback: Function) {\n        getImage(this._transformRequest(url, ResourceType.Image), callback);\n    }\n\n    /**\n    * Returns an Array of strings containing the names of all sprites/images currently available in the map\n    *\n    * @returns {Array<string>} An Array of strings containing the names of all sprites/images currently available in the map\n    *\n    */\n    listImages() {\n        return this.style.listImages();\n    }\n\n    /**\n     * Adds a [Mapbox style layer](https://www.mapbox.com/mapbox-gl-style-spec/#layers)\n     * to the map's style.\n     *\n     * A layer defines styling for data from a specified source.\n     *\n     * @param {Object | CustomLayerInterface} layer The style layer to add, conforming to the Mapbox Style Specification's\n     *   [layer definition](https://www.mapbox.com/mapbox-gl-style-spec/#layers).\n     * @param {string} [before] The ID of an existing layer to insert the new layer before.\n     *   If this argument is omitted, the layer will be appended to the end of the layers array.\n     * @returns {Map} `this`\n     * @see [Create and style clusters](https://www.mapbox.com/mapbox-gl-js/example/cluster/)\n     * @see [Add a vector tile source](https://www.mapbox.com/mapbox-gl-js/example/vector-source/)\n     * @see [Add a WMS source](https://www.mapbox.com/mapbox-gl-js/example/wms/)\n     */\n    addLayer(layer: LayerSpecification | CustomLayerInterface, before?: string) {\n        this.style.addLayer(layer, before);\n        return this._update(true);\n    }\n\n    /**\n     * Moves a layer to a different z-position.\n     *\n     * @param {string} id The ID of the layer to move.\n     * @param {string} [beforeId] The ID of an existing layer to insert the new layer before.\n     *   If this argument is omitted, the layer will be appended to the end of the layers array.\n     * @returns {Map} `this`\n     */\n    moveLayer(id: string, beforeId?: string) {\n        this.style.moveLayer(id, beforeId);\n        return this._update(true);\n    }\n\n    /**\n     * Removes the layer with the given id from the map's style.\n     *\n     * If no such layer exists, an `error` event is fired.\n     *\n     * @param {string} id id of the layer to remove\n     * @fires error\n     */\n    removeLayer(id: string) {\n        this.style.removeLayer(id);\n        return this._update(true);\n    }\n\n    /**\n     * Returns the layer with the specified ID in the map's style.\n     *\n     * @param {string} id The ID of the layer to get.\n     * @returns {?Object} The layer with the specified ID, or `undefined`\n     *   if the ID corresponds to no existing layers.\n     * @see [Filter symbols by toggling a list](https://www.mapbox.com/mapbox-gl-js/example/filter-markers/)\n     * @see [Filter symbols by text input](https://www.mapbox.com/mapbox-gl-js/example/filter-markers-by-input/)\n     */\n    getLayer(id: string) {\n        return this.style.getLayer(id);\n    }\n\n    /**\n     * Sets the filter for the specified style layer.\n     *\n     * @param {string} layer The ID of the layer to which the filter will be applied.\n     * @param {Array | null | undefined} filter The filter, conforming to the Mapbox Style Specification's\n     *   [filter definition](https://www.mapbox.com/mapbox-gl-js/style-spec/#other-filter).  If `null` or `undefined` is provided, the function removes any existing filter from the layer.\n     * @param {Object} [options]\n     * @param {boolean} [options.validate=true] Whether to check if the filter conforms to the Mapbox GL Style Specification. Disabling validation is a performance optimization that should only be used if you have previously validated the values you will be passing to this function.\n     *\n     * @returns {Map} `this`\n     * @example\n     * map.setFilter('my-layer', ['==', 'name', 'USA']);\n     * @see [Filter features within map view](https://www.mapbox.com/mapbox-gl-js/example/filter-features-within-map-view/)\n     * @see [Highlight features containing similar data](https://www.mapbox.com/mapbox-gl-js/example/query-similar-features/)\n     * @see [Create a timeline animation](https://www.mapbox.com/mapbox-gl-js/example/timeline-animation/)\n     */\n    setFilter(layer: string, filter: ?FilterSpecification,  options: StyleSetterOptions = {}) {\n        this.style.setFilter(layer, filter, options);\n        return this._update(true);\n    }\n\n    /**\n     * Sets the zoom extent for the specified style layer.\n     *\n     * @param {string} layerId The ID of the layer to which the zoom extent will be applied.\n     * @param {number} minzoom The minimum zoom to set (0-24).\n     * @param {number} maxzoom The maximum zoom to set (0-24).\n     * @returns {Map} `this`\n     * @example\n     * map.setLayerZoomRange('my-layer', 2, 5);\n     */\n    setLayerZoomRange(layerId: string, minzoom: number, maxzoom: number) {\n        this.style.setLayerZoomRange(layerId, minzoom, maxzoom);\n        return this._update(true);\n    }\n\n    /**\n     * Returns the filter applied to the specified style layer.\n     *\n     * @param {string} layer The ID of the style layer whose filter to get.\n     * @returns {Array} The layer's filter.\n     */\n    getFilter(layer: string) {\n        return this.style.getFilter(layer);\n    }\n\n    /**\n     * Sets the value of a paint property in the specified style layer.\n     *\n     * @param {string} layer The ID of the layer to set the paint property in.\n     * @param {string} name The name of the paint property to set.\n     * @param {*} value The value of the paint propery to set.\n     *   Must be of a type appropriate for the property, as defined in the [Mapbox Style Specification](https://www.mapbox.com/mapbox-gl-style-spec/).\n     * @param {Object} [options]\n     * @param {boolean} [options.validate=true] Whether to check if `value` conforms to the Mapbox GL Style Specification. Disabling validation is a performance optimization that should only be used if you have previously validated the values you will be passing to this function.\n     * @returns {Map} `this`\n     * @example\n     * map.setPaintProperty('my-layer', 'fill-color', '#faafee');\n     * @see [Change a layer's color with buttons](https://www.mapbox.com/mapbox-gl-js/example/color-switcher/)\n     * @see [Adjust a layer's opacity](https://www.mapbox.com/mapbox-gl-js/example/adjust-layer-opacity/)\n     * @see [Create a draggable point](https://www.mapbox.com/mapbox-gl-js/example/drag-a-point/)\n     */\n    setPaintProperty(layer: string, name: string, value: any, options: StyleSetterOptions = {}) {\n        this.style.setPaintProperty(layer, name, value, options);\n        return this._update(true);\n    }\n\n    /**\n     * Returns the value of a paint property in the specified style layer.\n     *\n     * @param {string} layer The ID of the layer to get the paint property from.\n     * @param {string} name The name of a paint property to get.\n     * @returns {*} The value of the specified paint property.\n     */\n    getPaintProperty(layer: string, name: string) {\n        return this.style.getPaintProperty(layer, name);\n    }\n\n    /**\n     * Sets the value of a layout property in the specified style layer.\n     *\n     * @param {string} layer The ID of the layer to set the layout property in.\n     * @param {string} name The name of the layout property to set.\n     * @param {*} value The value of the layout propery. Must be of a type appropriate for the property, as defined in the [Mapbox Style Specification](https://www.mapbox.com/mapbox-gl-style-spec/).\n     * @param {Object} [options]\n     * @param {boolean} [options.validate=true] Whether to check if `value` conforms to the Mapbox GL Style Specification. Disabling validation is a performance optimization that should only be used if you have previously validated the values you will be passing to this function.\n     * @returns {Map} `this`\n     * @example\n     * map.setLayoutProperty('my-layer', 'visibility', 'none');\n     */\n    setLayoutProperty(layer: string, name: string, value: any, options: StyleSetterOptions = {}) {\n        this.style.setLayoutProperty(layer, name, value, options);\n        return this._update(true);\n    }\n\n    /**\n     * Returns the value of a layout property in the specified style layer.\n     *\n     * @param {string} layer The ID of the layer to get the layout property from.\n     * @param {string} name The name of the layout property to get.\n     * @returns {*} The value of the specified layout property.\n     */\n    getLayoutProperty(layer: string, name: string) {\n        return this.style.getLayoutProperty(layer, name);\n    }\n\n    /**\n     * Sets the any combination of light values.\n     *\n     * @param light Light properties to set. Must conform to the [Mapbox Style Specification](https://www.mapbox.com/mapbox-gl-style-spec/#light).\n     * @param {Object} [options]\n     * @param {boolean} [options.validate=true] Whether to check if the filter conforms to the Mapbox GL Style Specification. Disabling validation is a performance optimization that should only be used if you have previously validated the values you will be passing to this function.\n     * @returns {Map} `this`\n     */\n    setLight(light: LightSpecification, options: StyleSetterOptions = {}) {\n        this.style.setLight(light, options);\n        return this._update(true);\n    }\n\n    /**\n     * Returns the value of the light object.\n     *\n     * @returns {Object} light Light properties of the style.\n     */\n    getLight() {\n        return this.style.getLight();\n    }\n\n    /**\n     * Sets the state of a feature. The `state` object is merged in with the existing state of the feature.\n     *\n     * @param {Object} feature Feature identifier. Feature objects returned from\n     * {@link Map#queryRenderedFeatures} or event handlers can be used as feature identifiers.\n     * @param {string | number} feature.id Unique id of the feature.\n     * @param {string} feature.source The Id of the vector source or GeoJSON source for the feature.\n     * @param {string} [feature.sourceLayer] (optional)  *For vector tile sources, the sourceLayer is\n     *  required.*\n     * @param {Object} state A set of key-value pairs. The values should be valid JSON types.\n     *\n     * This method requires the `feature.id` attribute on data sets. For GeoJSON sources without\n     * feature ids, set the `generateIds` option in the `GeoJSONSourceSpecification` to auto-assign them. This\n     * option assigns ids based on a feature's index in the source data. If you change feature data using\n     * `map.getSource('some id').setData(..)`, you may need to re-apply state taking into account updated `id` values.\n     */\n    setFeatureState(feature: { source: string; sourceLayer?: string; id: string | number; }, state: Object) {\n        this.style.setFeatureState(feature, state);\n        return this._update();\n    }\n\n    /**\n     * Gets the state of a feature.\n     *\n     * @param {Object} feature Feature identifier. Feature objects returned from\n     * {@link Map#queryRenderedFeatures} or event handlers can be used as feature identifiers.\n     * @param {string | number} feature.id Unique id of the feature.\n     * @param {string} feature.source The Id of the vector source or GeoJSON source for the feature.\n     * @param {string} [feature.sourceLayer] (optional)  *For vector tile sources, the sourceLayer is\n     *  required.*\n     *\n     * @returns {Object} The state of the feature.\n     */\n    getFeatureState(feature: { source: string; sourceLayer?: string; id: string | number; }): any {\n        return this.style.getFeatureState(feature);\n    }\n\n    /**\n     * Returns the map's containing HTML element.\n     *\n     * @returns {HTMLElement} The map's container.\n     */\n    getContainer() {\n        return this._container;\n    }\n\n    /**\n     * Returns the HTML element containing the map's `<canvas>` element.\n     *\n     * If you want to add non-GL overlays to the map, you should append them to this element.\n     *\n     * This is the element to which event bindings for map interactivity (such as panning and zooming) are\n     * attached. It will receive bubbled events from child elements such as the `<canvas>`, but not from\n     * map controls.\n     *\n     * @returns {HTMLElement} The container of the map's `<canvas>`.\n     * @see [Create a draggable point](https://www.mapbox.com/mapbox-gl-js/example/drag-a-point/)\n     * @see [Highlight features within a bounding box](https://www.mapbox.com/mapbox-gl-js/example/using-box-queryrenderedfeatures/)\n     */\n    getCanvasContainer() {\n        return this._canvasContainer;\n    }\n\n    /**\n     * Returns the map's `<canvas>` element.\n     *\n     * @returns {HTMLCanvasElement} The map's `<canvas>` element.\n     * @see [Measure distances](https://www.mapbox.com/mapbox-gl-js/example/measure/)\n     * @see [Display a popup on hover](https://www.mapbox.com/mapbox-gl-js/example/popup-on-hover/)\n     * @see [Center the map on a clicked symbol](https://www.mapbox.com/mapbox-gl-js/example/center-on-symbol/)\n     */\n    getCanvas() {\n        return this._canvas;\n    }\n\n    _containerDimensions() {\n        let width = 0;\n        let height = 0;\n\n        if (this._container) {\n            width = this._container.clientWidth || 400;\n            height = this._container.clientHeight || 300;\n        }\n\n        return [width, height];\n    }\n\n    _detectMissingCSS(): void {\n        const computedColor = window.getComputedStyle(this._missingCSSCanary).getPropertyValue('background-color');\n        if (computedColor !== 'rgb(250, 128, 114)') {\n            warnOnce('This page appears to be missing CSS declarations for ' +\n                'Mapbox GL JS, which may cause the map to display incorrectly. ' +\n                'Please ensure your page includes mapbox-gl.css, as described ' +\n                'in https://www.mapbox.com/mapbox-gl-js/api/.');\n        }\n    }\n\n    _setupContainer() {\n        const container = this._container;\n        container.classList.add('mapboxgl-map');\n\n        const missingCSSCanary = this._missingCSSCanary = DOM.create('div', 'mapboxgl-canary', container);\n        missingCSSCanary.style.visibility = 'hidden';\n        this._detectMissingCSS();\n\n        const canvasContainer = this._canvasContainer = DOM.create('div', 'mapboxgl-canvas-container', container);\n        if (this._interactive) {\n            canvasContainer.classList.add('mapboxgl-interactive');\n        }\n\n        this._canvas = DOM.create('canvas', 'mapboxgl-canvas', canvasContainer);\n        this._canvas.style.position = 'absolute';\n        this._canvas.addEventListener('webglcontextlost', this._contextLost, false);\n        this._canvas.addEventListener('webglcontextrestored', this._contextRestored, false);\n        this._canvas.setAttribute('tabindex', '0');\n        this._canvas.setAttribute('aria-label', 'Map');\n\n        const dimensions = this._containerDimensions();\n        this._resizeCanvas(dimensions[0], dimensions[1]);\n\n        const controlContainer = this._controlContainer = DOM.create('div', 'mapboxgl-control-container', container);\n        const positions = this._controlPositions = {};\n        ['top-left', 'top-right', 'bottom-left', 'bottom-right'].forEach((positionName) => {\n            positions[positionName] = DOM.create('div', `mapboxgl-ctrl-${positionName}`, controlContainer);\n        });\n    }\n\n    _resizeCanvas(width: number, height: number) {\n        const pixelRatio = window.devicePixelRatio || 1;\n\n        // Request the required canvas size taking the pixelratio into account.\n        this._canvas.width = pixelRatio * width;\n        this._canvas.height = pixelRatio * height;\n\n        // Maintain the same canvas size, potentially downscaling it for HiDPI displays\n        this._canvas.style.width = `${width}px`;\n        this._canvas.style.height = `${height}px`;\n    }\n\n    _setupPainter() {\n        const attributes = extend({\n            failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat,\n            preserveDrawingBuffer: this._preserveDrawingBuffer\n        }, isSupported.webGLContextAttributes);\n\n        const gl = this._canvas.getContext('webgl', attributes) ||\n            this._canvas.getContext('experimental-webgl', attributes);\n\n        if (!gl) {\n            this.fire(new ErrorEvent(new Error('Failed to initialize WebGL')));\n            return;\n        }\n\n        this.painter = new Painter(gl, this.transform);\n\n        webpSupported.testSupport(gl);\n    }\n\n    _contextLost(event: *) {\n        event.preventDefault();\n        if (this._frame) {\n            this._frame.cancel();\n            this._frame = null;\n        }\n        this.fire(new Event('webglcontextlost', {originalEvent: event}));\n    }\n\n    _contextRestored(event: *) {\n        this._setupPainter();\n        this.resize();\n        this._update();\n        this.fire(new Event('webglcontextrestored', {originalEvent: event}));\n    }\n\n    /**\n     * Returns a Boolean indicating whether the map is fully loaded.\n     *\n     * Returns `false` if the style is not yet fully loaded,\n     * or if there has been a change to the sources or style that\n     * has not yet fully loaded.\n     *\n     * @returns {boolean} A Boolean indicating whether the map is fully loaded.\n     */\n    loaded() {\n        return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();\n    }\n\n    /**\n     * Update this map's style and sources, and re-render the map.\n     *\n     * @param {boolean} updateStyle mark the map's style for reprocessing as\n     * well as its sources\n     * @returns {Map} this\n     * @private\n     */\n    _update(updateStyle?: boolean) {\n        if (!this.style) return this;\n\n        this._styleDirty = this._styleDirty || updateStyle;\n        this._sourcesDirty = true;\n        this.triggerRepaint();\n\n        return this;\n    }\n\n    /**\n     * Request that the given callback be executed during the next render\n     * frame.  Schedule a render frame if one is not already scheduled.\n     * @returns An id that can be used to cancel the callback\n     * @private\n     */\n    _requestRenderFrame(callback: () => void): TaskID {\n        this._update();\n        return this._renderTaskQueue.add(callback);\n    }\n\n    _cancelRenderFrame(id: TaskID) {\n        this._renderTaskQueue.remove(id);\n    }\n\n    /**\n     * Call when a (re-)render of the map is required:\n     * - The style has changed (`setPaintProperty()`, etc.)\n     * - Source data has changed (e.g. tiles have finished loading)\n     * - The map has is moving (or just finished moving)\n     * - A transition is in progress\n     *\n     * @returns {Map} this\n     * @private\n     */\n    _render() {\n        // A custom layer may have used the context asynchronously. Mark the state as dirty.\n        this.painter.context.setDirty();\n        this.painter.setBaseState();\n\n        this._renderTaskQueue.run();\n\n        let crossFading = false;\n\n        // If the style has changed, the map is being zoomed, or a transition or fade is in progress:\n        //  - Apply style changes (in a batch)\n        //  - Recalculate paint properties.\n        if (this.style && this._styleDirty) {\n            this._styleDirty = false;\n\n            const zoom = this.transform.zoom;\n            const now = browser.now();\n            this.style.zoomHistory.update(zoom, now);\n\n            const parameters = new EvaluationParameters(zoom, {\n                now,\n                fadeDuration: this._fadeDuration,\n                zoomHistory: this.style.zoomHistory,\n                transition: this.style.getTransition()\n            });\n\n            const factor = parameters.crossFadingFactor();\n            if (factor !== 1 || factor !== this._crossFadingFactor) {\n                crossFading = true;\n                this._crossFadingFactor = factor;\n            }\n\n            this.style.update(parameters);\n        }\n\n        // If we are in _render for any reason other than an in-progress paint\n        // transition, update source caches to check for and load any tiles we\n        // need for the current transform\n        if (this.style && this._sourcesDirty) {\n            this._sourcesDirty = false;\n            this.style._updateSources(this.transform);\n        }\n\n        this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, this._fadeDuration, this._crossSourceCollisions);\n\n        // Actually draw\n        this.painter.render(this.style, {\n            showTileBoundaries: this.showTileBoundaries,\n            showOverdrawInspector: this._showOverdrawInspector,\n            rotating: this.isRotating(),\n            zooming: this.isZooming(),\n            moving: this.isMoving(),\n            fadeDuration: this._fadeDuration\n        });\n\n        this.fire(new Event('render'));\n\n        if (this.loaded() && !this._loaded) {\n            this._loaded = true;\n            this.fire(new Event('load'));\n        }\n\n        if (this.style && (this.style.hasTransitions() || crossFading)) {\n            this._styleDirty = true;\n        }\n\n        if (this.style && !this._placementDirty) {\n            // Since no fade operations are in progress, we can release\n            // all tiles held for fading. If we didn't do this, the tiles\n            // would just sit in the SourceCaches until the next render\n            this.style._releaseSymbolFadeTiles();\n        }\n\n        // Schedule another render frame if it's needed.\n        //\n        // Even though `_styleDirty` and `_sourcesDirty` are reset in this\n        // method, synchronous events fired during Style#update or\n        // Style#_updateSources could have caused them to be set again.\n        if (this._sourcesDirty || this._repaint || this._styleDirty || this._placementDirty) {\n            this.triggerRepaint();\n        } else if (!this.isMoving() && this.loaded()) {\n            this.fire(new Event('idle'));\n        }\n\n        return this;\n    }\n\n    /**\n     * Clean up and release all internal resources associated with this map.\n     *\n     * This includes DOM elements, event bindings, web workers, and WebGL resources.\n     *\n     * Use this method when you are done using the map and wish to ensure that it no\n     * longer consumes browser resources. Afterwards, you must not call any other\n     * methods on the map.\n     */\n    remove() {\n        if (this._hash) this._hash.remove();\n\n        for (const control of this._controls) control.onRemove(this);\n        this._controls = [];\n\n        if (this._frame) {\n            this._frame.cancel();\n            this._frame = null;\n        }\n        this._renderTaskQueue.clear();\n        this.setStyle(null);\n        if (typeof window !== 'undefined') {\n            window.removeEventListener('resize', this._onWindowResize, false);\n            window.removeEventListener('online', this._onWindowOnline, false);\n        }\n\n        const extension = this.painter.context.gl.getExtension('WEBGL_lose_context');\n        if (extension) extension.loseContext();\n        removeNode(this._canvasContainer);\n        removeNode(this._controlContainer);\n        removeNode(this._missingCSSCanary);\n        this._container.classList.remove('mapboxgl-map');\n        this.fire(new Event('remove'));\n    }\n\n    /**\n     * Trigger the rendering of a single frame. Use this method with custom layers to\n     * repaint the map when the layer changes. Calling this multiple times before the\n     * next frame is rendered will still result in only a single frame being rendered.\n     */\n    triggerRepaint() {\n        if (this.style && !this._frame) {\n            this._frame = browser.frame(() => {\n                this._frame = null;\n                this._render();\n            });\n        }\n    }\n\n    _onWindowOnline() {\n        this._update();\n    }\n\n    _onWindowResize() {\n        if (this._trackResize) {\n            this.resize()._update();\n        }\n    }\n\n    /**\n     * Gets and sets a Boolean indicating whether the map will render an outline\n     * around each tile. These tile boundaries are useful for debugging.\n     *\n     * @name showTileBoundaries\n     * @type {boolean}\n     * @instance\n     * @memberof Map\n     */\n    get showTileBoundaries(): boolean { return !!this._showTileBoundaries; }\n    set showTileBoundaries(value: boolean) {\n        if (this._showTileBoundaries === value) return;\n        this._showTileBoundaries = value;\n        this._update();\n    }\n\n    /**\n     * Gets and sets a Boolean indicating whether the map will render boxes\n     * around all symbols in the data source, revealing which symbols\n     * were rendered or which were hidden due to collisions.\n     * This information is useful for debugging.\n     *\n     * @name showCollisionBoxes\n     * @type {boolean}\n     * @instance\n     * @memberof Map\n     */\n    get showCollisionBoxes(): boolean { return !!this._showCollisionBoxes; }\n    set showCollisionBoxes(value: boolean) {\n        if (this._showCollisionBoxes === value) return;\n        this._showCollisionBoxes = value;\n        if (value) {\n            // When we turn collision boxes on we have to generate them for existing tiles\n            // When we turn them off, there's no cost to leaving existing boxes in place\n            this.style._generateCollisionBoxes();\n        } else {\n            // Otherwise, call an update to remove collision boxes\n            this._update();\n        }\n    }\n\n    /*\n     * Gets and sets a Boolean indicating whether the map should color-code\n     * each fragment to show how many times it has been shaded.\n     * White fragments have been shaded 8 or more times.\n     * Black fragments have been shaded 0 times.\n     * This information is useful for debugging.\n     *\n     * @name showOverdraw\n     * @type {boolean}\n     * @instance\n     * @memberof Map\n     */\n    get showOverdrawInspector(): boolean { return !!this._showOverdrawInspector; }\n    set showOverdrawInspector(value: boolean) {\n        if (this._showOverdrawInspector === value) return;\n        this._showOverdrawInspector = value;\n        this._update();\n    }\n\n    /**\n     * Gets and sets a Boolean indicating whether the map will\n     * continuously repaint. This information is useful for analyzing performance.\n     *\n     * @name repaint\n     * @type {boolean}\n     * @instance\n     * @memberof Map\n     */\n    get repaint(): boolean { return !!this._repaint; }\n    set repaint(value: boolean) {\n        if (this._repaint !== value) {\n            this._repaint = value;\n            this.triggerRepaint();\n        }\n    }\n\n    // show vertices\n    get vertices(): boolean { return !!this._vertices; }\n    set vertices(value: boolean) { this._vertices = value; this._update(); }\n}\n\nexport default Map;\n\nfunction removeNode(node) {\n    if (node.parentNode) {\n        node.parentNode.removeChild(node);\n    }\n}\n\n/**\n * Interface for interactive controls added to the map. This is an\n * specification for implementers to model: it is not\n * an exported method or class.\n *\n * Controls must implement `onAdd` and `onRemove`, and must own an\n * element, which is often a `div` element. To use Mapbox GL JS's\n * default control styling, add the `mapboxgl-ctrl` class to your control's\n * node.\n *\n * @interface IControl\n * @example\n * // Control implemented as ES6 class\n * class HelloWorldControl {\n *     onAdd(map) {\n *         this._map = map;\n *         this._container = document.createElement('div');\n *         this._container.className = 'mapboxgl-ctrl';\n *         this._container.textContent = 'Hello, world';\n *         return this._container;\n *     }\n *\n *     onRemove() {\n *         this._container.parentNode.removeChild(this._container);\n *         this._map = undefined;\n *     }\n * }\n *\n * // Control implemented as ES5 prototypical class\n * function HelloWorldControl() { }\n *\n * HelloWorldControl.prototype.onAdd = function(map) {\n *     this._map = map;\n *     this._container = document.createElement('div');\n *     this._container.className = 'mapboxgl-ctrl';\n *     this._container.textContent = 'Hello, world';\n *     return this._container;\n * };\n *\n * HelloWorldControl.prototype.onRemove = function () {\n *      this._container.parentNode.removeChild(this._container);\n *      this._map = undefined;\n * };\n */\n\n/**\n * Register a control on the map and give it a chance to register event listeners\n * and resources. This method is called by {@link Map#addControl}\n * internally.\n *\n * @function\n * @memberof IControl\n * @instance\n * @name onAdd\n * @param {Map} map the Map this control will be added to\n * @returns {HTMLElement} The control's container element. This should\n * be created by the control and returned by onAdd without being attached\n * to the DOM: the map will insert the control's element into the DOM\n * as necessary.\n */\n\n/**\n * Unregister a control on the map and give it a chance to detach event listeners\n * and resources. This method is called by {@link Map#removeControl}\n * internally.\n *\n * @function\n * @memberof IControl\n * @instance\n * @name onRemove\n * @param {Map} map the Map this control will be removed from\n * @returns {undefined} there is no required return value for this method\n */\n\n/**\n * Optionally provide a default position for this control. If this method\n * is implemented and {@link Map#addControl} is called without the `position`\n * parameter, the value returned by getDefaultPosition will be used as the\n * control's position.\n *\n * @function\n * @memberof IControl\n * @instance\n * @name getDefaultPosition\n * @returns {string} a control position, one of the values valid in addControl.\n */\n\n/**\n * A [`Point` geometry](https://github.com/mapbox/point-geometry) object, which has\n * `x` and `y` properties representing screen coordinates in pixels.\n *\n * @typedef {Object} Point\n */\n\n/**\n * A {@link Point} or an array of two numbers representing `x` and `y` screen coordinates in pixels.\n *\n * @typedef {(Point | Array<number>)} PointLike\n */\n","// @flow\n\nimport { MapMouseEvent, MapTouchEvent, MapWheelEvent } from '../ui/events';\nimport DOM from '../util/dom';\nimport type Map from './map';\nimport scrollZoom from './handler/scroll_zoom';\nimport boxZoom from './handler/box_zoom';\nimport dragRotate from './handler/drag_rotate';\nimport dragPan from './handler/drag_pan';\nimport keyboard from './handler/keyboard';\nimport doubleClickZoom from './handler/dblclick_zoom';\nimport touchZoomRotate from './handler/touch_zoom_rotate';\n\nconst handlers = {\n    scrollZoom,\n    boxZoom,\n    dragRotate,\n    dragPan,\n    keyboard,\n    doubleClickZoom,\n    touchZoomRotate\n};\n\nexport default function bindHandlers(map: Map, options: {interactive: boolean, clickTolerance: number}) {\n    const el = map.getCanvasContainer();\n    let contextMenuEvent = null;\n    let mouseDown = false;\n    let startPos = null;\n\n    for (const name in handlers) {\n        (map: any)[name] = new handlers[name](map, options);\n        if (options.interactive && options[name]) {\n            (map: any)[name].enable(options[name]);\n        }\n    }\n\n    DOM.addEventListener(el, 'mouseout', onMouseOut);\n    DOM.addEventListener(el, 'mousedown', onMouseDown);\n    DOM.addEventListener(el, 'mouseup', onMouseUp);\n    DOM.addEventListener(el, 'mousemove', onMouseMove);\n    DOM.addEventListener(el, 'mouseover', onMouseOver);\n\n    // Bind touchstart and touchmove with passive: false because, even though\n    // they only fire a map events and therefore could theoretically be\n    // passive, binding with passive: true causes iOS not to respect\n    // e.preventDefault() in _other_ handlers, even if they are non-passive\n    // (see https://bugs.webkit.org/show_bug.cgi?id=184251)\n    DOM.addEventListener(el, 'touchstart', onTouchStart, {passive: false});\n    DOM.addEventListener(el, 'touchmove', onTouchMove, {passive: false});\n\n    DOM.addEventListener(el, 'touchend', onTouchEnd);\n    DOM.addEventListener(el, 'touchcancel', onTouchCancel);\n    DOM.addEventListener(el, 'click', onClick);\n    DOM.addEventListener(el, 'dblclick', onDblClick);\n    DOM.addEventListener(el, 'contextmenu', onContextMenu);\n    DOM.addEventListener(el, 'wheel', onWheel, {passive: false});\n\n    function onMouseDown(e: MouseEvent) {\n        mouseDown = true;\n        startPos = DOM.mousePos(el, e);\n\n        const mapEvent = new MapMouseEvent('mousedown', map, e);\n        map.fire(mapEvent);\n\n        if (mapEvent.defaultPrevented) {\n            return;\n        }\n\n        if (options.interactive && !map.doubleClickZoom.isActive()) {\n            map.stop();\n        }\n\n        map.boxZoom.onMouseDown(e);\n\n        if (!map.boxZoom.isActive() && !map.dragPan.isActive()) {\n            map.dragRotate.onMouseDown(e);\n        }\n\n        if (!map.boxZoom.isActive() && !map.dragRotate.isActive()) {\n            map.dragPan.onMouseDown(e);\n        }\n    }\n\n    function onMouseUp(e: MouseEvent) {\n        const rotating = map.dragRotate.isActive();\n\n        if (contextMenuEvent && !rotating) {\n            // This will be the case for Mac\n            map.fire(new MapMouseEvent('contextmenu', map, contextMenuEvent));\n        }\n\n        contextMenuEvent = null;\n        mouseDown = false;\n\n        map.fire(new MapMouseEvent('mouseup', map, e));\n    }\n\n    function onMouseMove(e: MouseEvent) {\n        if (map.dragPan.isActive()) return;\n        if (map.dragRotate.isActive()) return;\n\n        let target: ?Node = (e.target: any);\n        while (target && target !== el) target = target.parentNode;\n        if (target !== el) return;\n\n        map.fire(new MapMouseEvent('mousemove', map, e));\n    }\n\n    function onMouseOver(e: MouseEvent) {\n        let target: ?Node = (e.target: any);\n        while (target && target !== el) target = target.parentNode;\n        if (target !== el) return;\n\n        map.fire(new MapMouseEvent('mouseover', map, e));\n    }\n\n    function onMouseOut(e: MouseEvent) {\n        map.fire(new MapMouseEvent('mouseout', map, e));\n    }\n\n    function onTouchStart(e: TouchEvent) {\n        const mapEvent = new MapTouchEvent('touchstart', map, e);\n        map.fire(mapEvent);\n\n        if (mapEvent.defaultPrevented) {\n            return;\n        }\n\n        if (options.interactive) {\n            map.stop();\n        }\n\n        if (!map.boxZoom.isActive() && !map.dragRotate.isActive()) {\n            map.dragPan.onTouchStart(e);\n        }\n\n        map.touchZoomRotate.onStart(e);\n        map.doubleClickZoom.onTouchStart(mapEvent);\n    }\n\n    function onTouchMove(e: TouchEvent) {\n        map.fire(new MapTouchEvent('touchmove', map, e));\n    }\n\n    function onTouchEnd(e: TouchEvent) {\n        map.fire(new MapTouchEvent('touchend', map, e));\n    }\n\n    function onTouchCancel(e: TouchEvent) {\n        map.fire(new MapTouchEvent('touchcancel', map, e));\n    }\n\n    function onClick(e: MouseEvent) {\n        const pos = DOM.mousePos(el, e);\n        if (pos.equals(startPos) || pos.dist(startPos) < options.clickTolerance) {\n            map.fire(new MapMouseEvent('click', map, e));\n        }\n    }\n\n    function onDblClick(e: MouseEvent) {\n        const mapEvent = new MapMouseEvent('dblclick', map, e);\n        map.fire(mapEvent);\n\n        if (mapEvent.defaultPrevented) {\n            return;\n        }\n\n        map.doubleClickZoom.onDblClick(mapEvent);\n    }\n\n    function onContextMenu(e: MouseEvent) {\n        const rotating = map.dragRotate.isActive();\n        if (!mouseDown && !rotating) {\n            // Windows: contextmenu fired on mouseup, so fire event now\n            map.fire(new MapMouseEvent('contextmenu', map, e));\n        } else if (mouseDown) {\n            // Mac: contextmenu fired on mousedown; we save it until mouseup for consistency's sake\n            contextMenuEvent = e;\n        }\n\n        // prevent browser context menu when necessary; we don't allow it with rotation\n        // because we can't discern rotation gesture start from contextmenu on Mac\n        if (map.dragRotate.isEnabled() || map.listens('contextmenu')) {\n            e.preventDefault();\n        }\n    }\n\n    function onWheel(e: WheelEvent) {\n        if (options.interactive) {\n            map.stop();\n        }\n\n        const mapEvent = new MapWheelEvent('wheel', map, e);\n        map.fire(mapEvent);\n\n        if (mapEvent.defaultPrevented) {\n            return;\n        }\n\n        map.scrollZoom.onWheel(e);\n    }\n}\n","// @flow\n\nimport DOM from '../util/dom';\nimport window from '../util/window';\nimport LngLat from '../geo/lng_lat';\nimport Point from '@mapbox/point-geometry';\nimport smartWrap from '../util/smart_wrap';\nimport { bindAll, extend } from '../util/util';\nimport { type Anchor, anchorTranslate, applyAnchorClass } from './anchor';\nimport { Event, Evented } from '../util/evented';\nimport type Map from './map';\nimport type Popup from './popup';\nimport type {LngLatLike} from \"../geo/lng_lat\";\nimport type {MapMouseEvent, MapTouchEvent} from './events';\nimport type {PointLike} from '@mapbox/point-geometry';\n\ntype Options = {\n    element?: HTMLElement,\n    offset?: PointLike,\n    anchor?: Anchor,\n    color?: string,\n    draggable?: boolean\n};\n\n/**\n * Creates a marker component\n * @param {Object} [options]\n * @param {HTMLElement} [options.element] DOM element to use as a marker. The default is a light blue, droplet-shaped SVG marker.\n * @param {string} [options.anchor='center'] A string indicating the part of the Marker that should be positioned closest to the coordinate set via {@link Marker#setLngLat}.\n *   Options are `'center'`, `'top'`, `'bottom'`, `'left'`, `'right'`, `'top-left'`, `'top-right'`, `'bottom-left'`, and `'bottom-right'`.\n * @param {PointLike} [options.offset] The offset in pixels as a {@link PointLike} object to apply relative to the element's center. Negatives indicate left and up.\n * @param {string} [options.color='#3FB1CE'] The color to use for the default marker if options.element is not provided. The default is light blue.\n * @param {boolean} [options.draggable=false] A boolean indicating whether or not a marker is able to be dragged to a new position on the map.\n * @example\n * var marker = new mapboxgl.Marker()\n *   .setLngLat([30.5, 50.5])\n *   .addTo(map);\n * @see [Add custom icons with Markers](https://www.mapbox.com/mapbox-gl-js/example/custom-marker-icons/)\n * @see [Create a draggable Marker](https://www.mapbox.com/mapbox-gl-js/example/drag-a-marker/)\n */\nexport default class Marker extends Evented {\n    _map: Map;\n    _anchor: Anchor;\n    _offset: Point;\n    _element: HTMLElement;\n    _popup: ?Popup;\n    _lngLat: LngLat;\n    _pos: ?Point;\n    _color: ?string;\n    _defaultMarker: boolean;\n    _draggable: boolean;\n    _state: 'inactive' | 'pending' | 'active'; // used for handling drag events\n    _positionDelta: ?number;\n\n    constructor(options?: Options, legacyOptions?: Options) {\n        super();\n        // For backward compatibility -- the constructor used to accept the element as a\n        // required first argument, before it was made optional.\n        if (options instanceof window.HTMLElement || legacyOptions) {\n            options = extend({element: options}, legacyOptions);\n        }\n\n        bindAll([\n            '_update',\n            '_onMove',\n            '_onUp',\n            '_addDragHandler',\n            '_onMapClick'\n        ], this);\n\n        this._anchor = options && options.anchor || 'center';\n        this._color = options && options.color || '#3FB1CE';\n        this._draggable = options && options.draggable || false;\n        this._state = 'inactive';\n\n        if (!options || !options.element) {\n            this._defaultMarker = true;\n            this._element = DOM.create('div');\n\n            // create default map marker SVG\n            const svg = DOM.createNS('http://www.w3.org/2000/svg', 'svg');\n            svg.setAttributeNS(null, 'height', '41px');\n            svg.setAttributeNS(null, 'width', '27px');\n            svg.setAttributeNS(null, 'viewBox', '0 0 27 41');\n\n            const markerLarge = DOM.createNS('http://www.w3.org/2000/svg', 'g');\n            markerLarge.setAttributeNS(null, 'stroke', 'none');\n            markerLarge.setAttributeNS(null, 'stroke-width', '1');\n            markerLarge.setAttributeNS(null, 'fill', 'none');\n            markerLarge.setAttributeNS(null, 'fill-rule', 'evenodd');\n\n            const page1 = DOM.createNS('http://www.w3.org/2000/svg', 'g');\n            page1.setAttributeNS(null, 'fill-rule', 'nonzero');\n\n            const shadow = DOM.createNS('http://www.w3.org/2000/svg', 'g');\n            shadow.setAttributeNS(null, 'transform', 'translate(3.0, 29.0)');\n            shadow.setAttributeNS(null, 'fill', '#000000');\n\n            const ellipses = [\n                {'rx': '10.5', 'ry': '5.25002273'},\n                {'rx': '10.5', 'ry': '5.25002273'},\n                {'rx': '9.5', 'ry': '4.77275007'},\n                {'rx': '8.5', 'ry': '4.29549936'},\n                {'rx': '7.5', 'ry': '3.81822308'},\n                {'rx': '6.5', 'ry': '3.34094679'},\n                {'rx': '5.5', 'ry': '2.86367051'},\n                {'rx': '4.5', 'ry': '2.38636864'}\n            ];\n\n            for (const data of ellipses) {\n                const ellipse = DOM.createNS('http://www.w3.org/2000/svg', 'ellipse');\n                ellipse.setAttributeNS(null, 'opacity', '0.04');\n                ellipse.setAttributeNS(null, 'cx', '10.5');\n                ellipse.setAttributeNS(null, 'cy', '5.80029008');\n                ellipse.setAttributeNS(null, 'rx', data['rx']);\n                ellipse.setAttributeNS(null, 'ry', data['ry']);\n                shadow.appendChild(ellipse);\n            }\n\n            const background = DOM.createNS('http://www.w3.org/2000/svg', 'g');\n            background.setAttributeNS(null, 'fill', this._color);\n\n            const bgPath = DOM.createNS('http://www.w3.org/2000/svg', 'path');\n            bgPath.setAttributeNS(null, 'd', 'M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z');\n\n            background.appendChild(bgPath);\n\n            const border = DOM.createNS('http://www.w3.org/2000/svg', 'g');\n            border.setAttributeNS(null, 'opacity', '0.25');\n            border.setAttributeNS(null, 'fill', '#000000');\n\n            const borderPath = DOM.createNS('http://www.w3.org/2000/svg', 'path');\n            borderPath.setAttributeNS(null, 'd', 'M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z');\n\n            border.appendChild(borderPath);\n\n            const maki = DOM.createNS('http://www.w3.org/2000/svg', 'g');\n            maki.setAttributeNS(null, 'transform', 'translate(6.0, 7.0)');\n            maki.setAttributeNS(null, 'fill', '#FFFFFF');\n\n            const circleContainer = DOM.createNS('http://www.w3.org/2000/svg', 'g');\n            circleContainer.setAttributeNS(null, 'transform', 'translate(8.0, 8.0)');\n\n            const circle1 = DOM.createNS('http://www.w3.org/2000/svg', 'circle');\n            circle1.setAttributeNS(null, 'fill', '#000000');\n            circle1.setAttributeNS(null, 'opacity', '0.25');\n            circle1.setAttributeNS(null, 'cx', '5.5');\n            circle1.setAttributeNS(null, 'cy', '5.5');\n            circle1.setAttributeNS(null, 'r', '5.4999962');\n\n            const circle2 = DOM.createNS('http://www.w3.org/2000/svg', 'circle');\n            circle2.setAttributeNS(null, 'fill', '#FFFFFF');\n            circle2.setAttributeNS(null, 'cx', '5.5');\n            circle2.setAttributeNS(null, 'cy', '5.5');\n            circle2.setAttributeNS(null, 'r', '5.4999962');\n\n            circleContainer.appendChild(circle1);\n            circleContainer.appendChild(circle2);\n\n            page1.appendChild(shadow);\n            page1.appendChild(background);\n            page1.appendChild(border);\n            page1.appendChild(maki);\n            page1.appendChild(circleContainer);\n\n            svg.appendChild(page1);\n\n            this._element.appendChild(svg);\n\n            // if no element and no offset option given apply an offset for the default marker\n            // the -14 as the y value of the default marker offset was determined as follows\n            //\n            // the marker tip is at the center of the shadow ellipse from the default svg\n            // the y value of the center of the shadow ellipse relative to the svg top left is \"shadow transform translate-y (29.0) + ellipse cy (5.80029008)\"\n            // offset to the svg center \"height (41 / 2)\" gives (29.0 + 5.80029008) - (41 / 2) and rounded for an integer pixel offset gives 14\n            // negative is used to move the marker up from the center so the tip is at the Marker lngLat\n            this._offset = Point.convert(options && options.offset || [0, -14]);\n        } else {\n            this._element = options.element;\n            this._offset = Point.convert(options && options.offset || [0, 0]);\n        }\n\n        this._element.classList.add('mapboxgl-marker');\n\n        this._popup = null;\n    }\n\n    /**\n     * Attaches the marker to a map\n     * @param {Map} map\n     * @returns {Marker} `this`\n     */\n    addTo(map: Map) {\n        this.remove();\n        this._map = map;\n        map.getCanvasContainer().appendChild(this._element);\n        map.on('move', this._update);\n        map.on('moveend', this._update);\n        this.setDraggable(this._draggable);\n        this._update();\n\n        // If we attached the `click` listener to the marker element, the popup\n        // would close once the event propogated to `map` due to the\n        // `Popup#_onClickClose` listener.\n        this._map.on('click', this._onMapClick);\n\n        return this;\n    }\n\n    /**\n     * Removes the marker from a map\n     * @example\n     * var marker = new mapboxgl.Marker().addTo(map);\n     * marker.remove();\n     * @returns {Marker} `this`\n     */\n    remove() {\n        if (this._map) {\n            this._map.off('click', this._onMapClick);\n            this._map.off('move', this._update);\n            this._map.off('moveend', this._update);\n            this._map.off('mousedown', this._addDragHandler);\n            this._map.off('touchstart', this._addDragHandler);\n            this._map.off('mouseup', this._onUp);\n            this._map.off('touchend', this._onUp);\n            delete this._map;\n        }\n        DOM.remove(this._element);\n        if (this._popup) this._popup.remove();\n        return this;\n    }\n\n    /**\n     * Get the marker's geographical location.\n     *\n     * The longitude of the result may differ by a multiple of 360 degrees from the longitude previously\n     * set by `setLngLat` because `Marker` wraps the anchor longitude across copies of the world to keep\n     * the marker on screen.\n     *\n     * @returns {LngLat}\n     */\n    getLngLat() {\n        return this._lngLat;\n    }\n\n    /**\n     * Set the marker's geographical position and move it.\n     * @returns {Marker} `this`\n     */\n    setLngLat(lnglat: LngLatLike) {\n        this._lngLat = LngLat.convert(lnglat);\n        this._pos = null;\n        if (this._popup) this._popup.setLngLat(this._lngLat);\n        this._update();\n        return this;\n    }\n\n    /**\n     * Returns the `Marker`'s HTML element.\n     * @returns {HTMLElement} element\n     */\n    getElement() {\n        return this._element;\n    }\n\n    /**\n     * Binds a Popup to the Marker\n     * @param popup an instance of the `Popup` class. If undefined or null, any popup\n     * set on this `Marker` instance is unset\n     * @returns {Marker} `this`\n     */\n    setPopup(popup: ?Popup) {\n        if (this._popup) {\n            this._popup.remove();\n            this._popup = null;\n        }\n\n        if (popup) {\n            if (!('offset' in popup.options)) {\n                const markerHeight = 41 - (5.8 / 2);\n                const markerRadius = 13.5;\n                const linearOffset = Math.sqrt(Math.pow(markerRadius, 2) / 2);\n                popup.options.offset = this._defaultMarker ? {\n                    'top': [0, 0],\n                    'top-left': [0, 0],\n                    'top-right': [0, 0],\n                    'bottom': [0, -markerHeight],\n                    'bottom-left': [linearOffset, (markerHeight - markerRadius + linearOffset) * -1],\n                    'bottom-right': [-linearOffset, (markerHeight - markerRadius + linearOffset) * -1],\n                    'left': [markerRadius, (markerHeight - markerRadius) * -1],\n                    'right': [-markerRadius, (markerHeight - markerRadius) * -1]\n                } : this._offset;\n            }\n            this._popup = popup;\n            if (this._lngLat) this._popup.setLngLat(this._lngLat);\n        }\n\n        return this;\n    }\n\n    _onMapClick(e: MapMouseEvent) {\n        const targetElement = e.originalEvent.target;\n        const element = this._element;\n\n        if (this._popup && (targetElement === element || element.contains((targetElement: any)))) {\n            this.togglePopup();\n        }\n    }\n\n    /**\n     * Returns the Popup instance that is bound to the Marker\n     * @returns {Popup} popup\n     */\n    getPopup() {\n        return this._popup;\n    }\n\n    /**\n     * Opens or closes the bound popup, depending on the current state\n     * @returns {Marker} `this`\n     */\n    togglePopup() {\n        const popup = this._popup;\n\n        if (!popup) return this;\n        else if (popup.isOpen()) popup.remove();\n        else popup.addTo(this._map);\n        return this;\n    }\n\n    _update(e?: {type: 'move' | 'moveend'}) {\n        if (!this._map) return;\n\n        if (this._map.transform.renderWorldCopies) {\n            this._lngLat = smartWrap(this._lngLat, this._pos, this._map.transform);\n        }\n\n        this._pos = this._map.project(this._lngLat)._add(this._offset);\n\n        // because rounding the coordinates at every `move` event causes stuttered zooming\n        // we only round them when _update is called with `moveend` or when its called with\n        // no arguments (when the Marker is initialized or Marker#setLngLat is invoked).\n        if (!e || e.type === \"moveend\") {\n            this._pos = this._pos.round();\n        }\n\n        DOM.setTransform(this._element, `${anchorTranslate[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px)`);\n        applyAnchorClass(this._element, this._anchor, 'marker');\n    }\n\n    /**\n     * Get the marker's offset.\n     * @returns {Point}\n     */\n    getOffset() {\n        return this._offset;\n    }\n\n    /**\n     * Sets the offset of the marker\n     * @param {PointLike} offset The offset in pixels as a {@link PointLike} object to apply relative to the element's center. Negatives indicate left and up.\n     * @returns {Marker} `this`\n     */\n    setOffset(offset: PointLike) {\n        this._offset = Point.convert(offset);\n        this._update();\n        return this;\n    }\n\n    _onMove(e: MapMouseEvent | MapTouchEvent) {\n        this._pos = e.point.sub(this._positionDelta);\n        this._lngLat = this._map.unproject(this._pos);\n        this.setLngLat(this._lngLat);\n        // suppress click event so that popups don't toggle on drag\n        this._element.style.pointerEvents = 'none';\n\n        // make sure dragstart only fires on the first move event after mousedown.\n        // this can't be on mousedown because that event doesn't necessarily\n        // imply that a drag is about to happen.\n        if (this._state === 'pending') {\n            this._state = 'active';\n\n            /**\n             * Fired when dragging starts\n             *\n             * @event dragstart\n             * @memberof Marker\n             * @instance\n             * @type {Object}\n             * @property {Marker} marker object that is being dragged\n             */\n            this.fire(new Event('dragstart'));\n        }\n\n        /**\n         * Fired while dragging\n         *\n         * @event drag\n         * @memberof Marker\n         * @instance\n         * @type {Object}\n         * @property {Marker} marker object that is being dragged\n         */\n        this.fire(new Event('drag'));\n    }\n\n    _onUp() {\n        // revert to normal pointer event handling\n        this._element.style.pointerEvents = 'auto';\n        this._positionDelta = null;\n        this._map.off('mousemove', this._onMove);\n        this._map.off('touchmove', this._onMove);\n\n        // only fire dragend if it was preceded by at least one drag event\n        if (this._state === 'active') {\n            /**\n            * Fired when the marker is finished being dragged\n            *\n            * @event dragend\n            * @memberof Marker\n            * @instance\n            * @type {Object}\n            * @property {Marker} marker object that was dragged\n            */\n            this.fire(new Event('dragend'));\n        }\n\n        this._state = 'inactive';\n    }\n\n    _addDragHandler(e: MapMouseEvent | MapTouchEvent) {\n        if (this._element.contains((e.originalEvent.target: any))) {\n            e.preventDefault();\n\n            // We need to calculate the pixel distance between the click point\n            // and the marker position, with the offset accounted for. Then we\n            // can subtract this distance from the mousemove event's position\n            // to calculate the new marker position.\n            // If we don't do this, the marker 'jumps' to the click position\n            // creating a jarring UX effect.\n            this._positionDelta = e.point.sub(this._pos).add(this._offset);\n\n            this._state = 'pending';\n            this._map.on('mousemove', this._onMove);\n            this._map.on('touchmove', this._onMove);\n            this._map.once('mouseup', this._onUp);\n            this._map.once('touchend', this._onUp);\n        }\n    }\n\n    /**\n     * Sets the `draggable` property and functionality of the marker\n     * @param {boolean} [shouldBeDraggable=false] Turns drag functionality on/off\n     * @returns {Marker} `this`\n     */\n    setDraggable(shouldBeDraggable: boolean) {\n        this._draggable = !!shouldBeDraggable; // convert possible undefined value to false\n\n        // handle case where map may not exist yet\n        // e.g. when setDraggable is called before addTo\n        if (this._map) {\n            if (shouldBeDraggable) {\n                this._map.on('mousedown', this._addDragHandler);\n                this._map.on('touchstart', this._addDragHandler);\n            } else {\n                this._map.off('mousedown', this._addDragHandler);\n                this._map.off('touchstart', this._addDragHandler);\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Returns true if the marker can be dragged\n     * @returns {boolean}\n     */\n    isDraggable() {\n        return this._draggable;\n    }\n}\n","// @flow\n\nimport { Event, Evented } from '../../util/evented';\nimport DOM from '../../util/dom';\nimport window from '../../util/window';\nimport { extend, bindAll, warnOnce } from '../../util/util';\nimport assert from 'assert';\nimport LngLat from '../../geo/lng_lat';\nimport Marker from '../marker';\n\nimport type Map from '../map';\nimport type { AnimationOptions, CameraOptions } from '../camera';\n\ntype Options = {\n    positionOptions?: PositionOptions,\n    fitBoundsOptions?: AnimationOptions & CameraOptions,\n    trackUserLocation?: boolean,\n    showUserLocation?: boolean\n};\n\nconst defaultOptions: Options = {\n    positionOptions: {\n        enableHighAccuracy: false,\n        maximumAge: 0,\n        timeout: 6000 /* 6 sec */\n    },\n    fitBoundsOptions: {\n        maxZoom: 15\n    },\n    trackUserLocation: false,\n    showUserLocation: true\n};\nconst className = 'mapboxgl-ctrl';\n\nlet supportsGeolocation;\n\nfunction checkGeolocationSupport(callback) {\n    if (supportsGeolocation !== undefined) {\n        callback(supportsGeolocation);\n\n    } else if (window.navigator.permissions !== undefined) {\n        // navigator.permissions has incomplete browser support\n        // http://caniuse.com/#feat=permissions-api\n        // Test for the case where a browser disables Geolocation because of an\n        // insecure origin\n        window.navigator.permissions.query({ name: 'geolocation' }).then((p) => {\n            supportsGeolocation = p.state !== 'denied';\n            callback(supportsGeolocation);\n        });\n\n    } else {\n        supportsGeolocation = !!window.navigator.geolocation;\n        callback(supportsGeolocation);\n    }\n}\n\n/**\n * A `GeolocateControl` control provides a button that uses the browser's geolocation\n * API to locate the user on the map.\n *\n * Not all browsers support geolocation,\n * and some users may disable the feature. Geolocation support for modern\n * browsers including Chrome requires sites to be served over HTTPS. If\n * geolocation support is not available, the GeolocateControl will not\n * be visible.\n *\n * The zoom level applied will depend on the accuracy of the geolocation provided by the device.\n *\n * The GeolocateControl has two modes. If `trackUserLocation` is `false` (default) the control acts as a button, which when pressed will set the map's camera to target the user location. If the user moves, the map won't update. This is most suited for the desktop. If `trackUserLocation` is `true` the control acts as a toggle button that when active the user's location is actively monitored for changes. In this mode the GeolocateControl has three states:\n * * active - the map's camera automatically updates as the user's location changes, keeping the location dot in the center.\n * * passive - the user's location dot automatically updates, but the map's camera does not.\n * * disabled\n *\n * @implements {IControl}\n * @param {Object} [options]\n * @param {Object} [options.positionOptions={enableHighAccuracy: false, timeout: 6000}] A Geolocation API [PositionOptions](https://developer.mozilla.org/en-US/docs/Web/API/PositionOptions) object.\n * @param {Object} [options.fitBoundsOptions={maxZoom: 15}] A [`fitBounds`](#Map#fitBounds) options object to use when the map is panned and zoomed to the user's location. The default is to use a `maxZoom` of 15 to limit how far the map will zoom in for very accurate locations.\n * @param {Object} [options.trackUserLocation=false] If `true` the Geolocate Control becomes a toggle button and when active the map will receive updates to the user's location as it changes.\n * @param {Object} [options.showUserLocation=true] By default a dot will be shown on the map at the user's location. Set to `false` to disable.\n *\n * @example\n * map.addControl(new mapboxgl.GeolocateControl({\n *     positionOptions: {\n *         enableHighAccuracy: true\n *     },\n *     trackUserLocation: true\n * }));\n * @see [Locate the user](https://www.mapbox.com/mapbox-gl-js/example/locate-user/)\n */\nclass GeolocateControl extends Evented {\n    _map: Map;\n    options: Options;\n    _container: HTMLElement;\n    _dotElement: HTMLElement;\n    _geolocateButton: HTMLElement;\n    _geolocationWatchID: number;\n    _timeoutId: ?TimeoutID;\n    _watchState: string;\n    _lastKnownPosition: any;\n    _userLocationDotMarker: Marker;\n    _setup: boolean; // set to true once the control has been setup\n\n    constructor(options: Options) {\n        super();\n        this.options = extend({}, defaultOptions, options);\n\n        bindAll([\n            '_onSuccess',\n            '_onError',\n            '_finish',\n            '_setupUI',\n            '_updateCamera',\n            '_updateMarker'\n        ], this);\n    }\n\n    onAdd(map: Map) {\n        this._map = map;\n        this._container = DOM.create('div', `${className} ${className}-group`);\n        checkGeolocationSupport(this._setupUI);\n        return this._container;\n    }\n\n    onRemove() {\n        // clear the geolocation watch if exists\n        if (this._geolocationWatchID !== undefined) {\n            window.navigator.geolocation.clearWatch(this._geolocationWatchID);\n            this._geolocationWatchID = (undefined: any);\n        }\n\n        // clear the marker from the map\n        if (this.options.showUserLocation && this._userLocationDotMarker) {\n            this._userLocationDotMarker.remove();\n        }\n\n        DOM.remove(this._container);\n        this._map = (undefined: any);\n    }\n\n    _onSuccess(position: Position) {\n        if (this.options.trackUserLocation) {\n            // keep a record of the position so that if the state is BACKGROUND and the user\n            // clicks the button, we can move to ACTIVE_LOCK immediately without waiting for\n            // watchPosition to trigger _onSuccess\n            this._lastKnownPosition = position;\n\n            switch (this._watchState) {\n            case 'WAITING_ACTIVE':\n            case 'ACTIVE_LOCK':\n            case 'ACTIVE_ERROR':\n                this._watchState = 'ACTIVE_LOCK';\n                this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-waiting');\n                this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-active-error');\n                this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-active');\n                break;\n            case 'BACKGROUND':\n            case 'BACKGROUND_ERROR':\n                this._watchState = 'BACKGROUND';\n                this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-waiting');\n                this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-background-error');\n                this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-background');\n                break;\n            default:\n                assert(false, `Unexpected watchState ${this._watchState}`);\n            }\n        }\n\n        // if showUserLocation and the watch state isn't off then update the marker location\n        if (this.options.showUserLocation && this._watchState !== 'OFF') {\n            this._updateMarker(position);\n        }\n\n        // if in normal mode (not watch mode), or if in watch mode and the state is active watch\n        // then update the camera\n        if (!this.options.trackUserLocation || this._watchState === 'ACTIVE_LOCK') {\n            this._updateCamera(position);\n        }\n\n        if (this.options.showUserLocation) {\n            this._dotElement.classList.remove('mapboxgl-user-location-dot-stale');\n        }\n\n        this.fire(new Event('geolocate', position));\n        this._finish();\n    }\n\n    _updateCamera(position: Position) {\n        const center = new LngLat(position.coords.longitude, position.coords.latitude);\n        const radius = position.coords.accuracy;\n\n        this._map.fitBounds(center.toBounds(radius), this.options.fitBoundsOptions, {\n            geolocateSource: true // tag this camera change so it won't cause the control to change to background state\n        });\n    }\n\n    _updateMarker(position: ?Position) {\n        if (position) {\n            this._userLocationDotMarker.setLngLat([position.coords.longitude, position.coords.latitude]).addTo(this._map);\n        } else {\n            this._userLocationDotMarker.remove();\n        }\n    }\n\n    _onError(error: PositionError) {\n        if (this.options.trackUserLocation) {\n            if (error.code === 1) {\n                // PERMISSION_DENIED\n                this._watchState = 'OFF';\n                this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-waiting');\n                this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-active');\n                this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-active-error');\n                this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-background');\n                this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-background-error');\n\n                if (this._geolocationWatchID !== undefined) {\n                    this._clearWatch();\n                }\n            } else {\n                switch (this._watchState) {\n                case 'WAITING_ACTIVE':\n                    this._watchState = 'ACTIVE_ERROR';\n                    this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-active');\n                    this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-active-error');\n                    break;\n                case 'ACTIVE_LOCK':\n                    this._watchState = 'ACTIVE_ERROR';\n                    this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-active');\n                    this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-active-error');\n                    this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-waiting');\n                    // turn marker grey\n                    break;\n                case 'BACKGROUND':\n                    this._watchState = 'BACKGROUND_ERROR';\n                    this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-background');\n                    this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-background-error');\n                    this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-waiting');\n                    // turn marker grey\n                    break;\n                case 'ACTIVE_ERROR':\n                    break;\n                default:\n                    assert(false, `Unexpected watchState ${this._watchState}`);\n                }\n            }\n        }\n\n        if (this._watchState !== 'OFF' && this.options.showUserLocation) {\n            this._dotElement.classList.add('mapboxgl-user-location-dot-stale');\n        }\n\n        this.fire(new Event('error', error));\n\n        this._finish();\n    }\n\n    _finish() {\n        if (this._timeoutId) { clearTimeout(this._timeoutId); }\n        this._timeoutId = undefined;\n    }\n\n    _setupUI(supported: boolean) {\n        if (supported === false) {\n            warnOnce('Geolocation support is not available, the GeolocateControl will not be visible.');\n            return;\n        }\n        this._container.addEventListener('contextmenu', (e: MouseEvent) => e.preventDefault());\n        this._geolocateButton = DOM.create('button',\n            `${className}-icon ${className}-geolocate`,\n            this._container);\n        this._geolocateButton.type = 'button';\n        this._geolocateButton.setAttribute('aria-label', 'Geolocate');\n\n        if (this.options.trackUserLocation) {\n            this._geolocateButton.setAttribute('aria-pressed', 'false');\n            this._watchState = 'OFF';\n        }\n\n        // when showUserLocation is enabled, keep the Geolocate button disabled until the device location marker is setup on the map\n        if (this.options.showUserLocation) {\n            this._dotElement = DOM.create('div', 'mapboxgl-user-location-dot');\n\n            this._userLocationDotMarker = new Marker(this._dotElement);\n\n            if (this.options.trackUserLocation) this._watchState = 'OFF';\n        }\n\n        this._geolocateButton.addEventListener('click',\n            this.trigger.bind(this));\n\n        this._setup = true;\n\n        // when the camera is changed (and it's not as a result of the Geolocation Control) change\n        // the watch mode to background watch, so that the marker is updated but not the camera.\n        if (this.options.trackUserLocation) {\n            this._map.on('movestart', (event) => {\n                if (!event.geolocateSource && this._watchState === 'ACTIVE_LOCK') {\n                    this._watchState = 'BACKGROUND';\n                    this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-background');\n                    this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-active');\n\n                    this.fire(new Event('trackuserlocationend'));\n                }\n            });\n        }\n    }\n\n    /**\n     * Trigger a geolocation\n     *\n     * @returns {boolean} Returns `false` if called before control was added to a map, otherwise returns `true`.\n     */\n    trigger() {\n        if (!this._setup) {\n            warnOnce('Geolocate control triggered before added to a map');\n            return false;\n        }\n        if (this.options.trackUserLocation) {\n            // update watchState and do any outgoing state cleanup\n            switch (this._watchState) {\n            case 'OFF':\n                // turn on the Geolocate Control\n                this._watchState = 'WAITING_ACTIVE';\n\n                this.fire(new Event('trackuserlocationstart'));\n                break;\n            case 'WAITING_ACTIVE':\n            case 'ACTIVE_LOCK':\n            case 'ACTIVE_ERROR':\n            case 'BACKGROUND_ERROR':\n                // turn off the Geolocate Control\n                this._watchState = 'OFF';\n                this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-waiting');\n                this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-active');\n                this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-active-error');\n                this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-background');\n                this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-background-error');\n\n                this.fire(new Event('trackuserlocationend'));\n                break;\n            case 'BACKGROUND':\n                this._watchState = 'ACTIVE_LOCK';\n                this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-background');\n                // set camera to last known location\n                if (this._lastKnownPosition) this._updateCamera(this._lastKnownPosition);\n\n                this.fire(new Event('trackuserlocationstart'));\n                break;\n            default:\n                assert(false, `Unexpected watchState ${this._watchState}`);\n            }\n\n            // incoming state setup\n            switch (this._watchState) {\n            case 'WAITING_ACTIVE':\n                this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-waiting');\n                this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-active');\n                break;\n            case 'ACTIVE_LOCK':\n                this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-active');\n                break;\n            case 'ACTIVE_ERROR':\n                this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-waiting');\n                this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-active-error');\n                break;\n            case 'BACKGROUND':\n                this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-background');\n                break;\n            case 'BACKGROUND_ERROR':\n                this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-waiting');\n                this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-background-error');\n                break;\n            case 'OFF':\n                break;\n            default:\n                assert(false, `Unexpected watchState ${this._watchState}`);\n            }\n\n            // manage geolocation.watchPosition / geolocation.clearWatch\n            if (this._watchState === 'OFF' && this._geolocationWatchID !== undefined) {\n                // clear watchPosition as we've changed to an OFF state\n                this._clearWatch();\n            } else if (this._geolocationWatchID === undefined) {\n                // enable watchPosition since watchState is not OFF and there is no watchPosition already running\n\n                this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-waiting');\n                this._geolocateButton.setAttribute('aria-pressed', 'true');\n\n                this._geolocationWatchID = window.navigator.geolocation.watchPosition(\n                    this._onSuccess, this._onError, this.options.positionOptions);\n            }\n        } else {\n            window.navigator.geolocation.getCurrentPosition(\n                this._onSuccess, this._onError, this.options.positionOptions);\n\n            // This timeout ensures that we still call finish() even if\n            // the user declines to share their location in Firefox\n            this._timeoutId = setTimeout(this._finish, 10000 /* 10sec */);\n        }\n\n        return true;\n    }\n\n    _clearWatch() {\n        window.navigator.geolocation.clearWatch(this._geolocationWatchID);\n\n        this._geolocationWatchID = (undefined: any);\n        this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-waiting');\n        this._geolocateButton.setAttribute('aria-pressed', 'false');\n\n        if (this.options.showUserLocation) {\n            this._updateMarker(null);\n        }\n    }\n}\n\nexport default GeolocateControl;\n\n/* Geolocate Control Watch States\n * This is the private state of the control.\n *\n * OFF\n *    off/inactive\n * WAITING_ACTIVE\n *    Geolocate Control was clicked but still waiting for Geolocation API response with user location\n * ACTIVE_LOCK\n *    Showing the user location as a dot AND tracking the camera to be fixed to their location. If their location changes the map moves to follow.\n * ACTIVE_ERROR\n *    There was en error from the Geolocation API while trying to show and track the user location.\n * BACKGROUND\n *    Showing the user location as a dot but the camera doesn't follow their location as it changes.\n * BACKGROUND_ERROR\n *    There was an error from the Geolocation API while trying to show (but not track) the user location.\n */\n\n\n/**\n * Fired on each Geolocation API position update which returned as success.\n *\n * @event geolocate\n * @memberof GeolocateControl\n * @instance\n * @property {Position} data The returned [Position](https://developer.mozilla.org/en-US/docs/Web/API/Position) object from the callback in [Geolocation.getCurrentPosition()](https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/getCurrentPosition) or [Geolocation.watchPosition()](https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/watchPosition).\n *\n */\n\n/**\n * Fired on each Geolocation API position update which returned as an error.\n *\n * @event error\n * @memberof GeolocateControl\n * @instance\n * @property {PositionError} data The returned [PositionError](https://developer.mozilla.org/en-US/docs/Web/API/PositionError) object from the callback in [Geolocation.getCurrentPosition()](https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/getCurrentPosition) or [Geolocation.watchPosition()](https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/watchPosition).\n *\n */\n\n/**\n * Fired when the Geolocate Control changes to the active lock state, which happens either upon first obtaining a successful Geolocation API position for the user (a geolocate event will follow), or the user clicks the geolocate button when in the background state which uses the last known position to recenter the map and enter active lock state (no geolocate event will follow unless the users's location changes).\n *\n * @event trackuserlocationstart\n * @memberof GeolocateControl\n * @instance\n *\n */\n\n/**\n * Fired when the Geolocate Control changes to the background state, which happens when a user changes the camera during an active position lock. This only applies when trackUserLocation is true. In the background state, the dot on the map will update with location updates but the camera will not.\n *\n * @event trackuserlocationend\n * @memberof GeolocateControl\n * @instance\n *\n */\n","// @flow\n\nimport DOM from '../../util/dom';\nimport { extend, bindAll } from '../../util/util';\n\nimport type Map from '../map';\n\ntype Unit = 'imperial' | 'metric' | 'nautical';\n\ntype Options = {\n    maxWidth?: number,\n    unit?: Unit;\n};\n\nconst defaultOptions: Options = {\n    maxWidth: 100,\n    unit: 'metric'\n};\n\n/**\n * A `ScaleControl` control displays the ratio of a distance on the map to the corresponding distance on the ground.\n *\n * @implements {IControl}\n * @param {Object} [options]\n * @param {number} [options.maxWidth='100'] The maximum length of the scale control in pixels.\n * @param {string} [options.unit='metric'] Unit of the distance (`'imperial'`, `'metric'` or `'nautical'`).\n * @example\n * var scale = new mapboxgl.ScaleControl({\n *     maxWidth: 80,\n *     unit: 'imperial'\n * });\n * map.addControl(scale);\n *\n * scale.setUnit('metric');\n */\nclass ScaleControl {\n    _map: Map;\n    _container: HTMLElement;\n    options: Options;\n\n    constructor(options: Options) {\n        this.options = extend({}, defaultOptions, options);\n\n        bindAll([\n            '_onMove',\n            'setUnit'\n        ], this);\n    }\n\n    getDefaultPosition() {\n        return 'bottom-left';\n    }\n\n    _onMove() {\n        updateScale(this._map, this._container, this.options);\n    }\n\n    onAdd(map: Map) {\n        this._map = map;\n        this._container = DOM.create('div', 'mapboxgl-ctrl mapboxgl-ctrl-scale', map.getContainer());\n\n        this._map.on('move', this._onMove);\n        this._onMove();\n\n        return this._container;\n    }\n\n    onRemove() {\n        DOM.remove(this._container);\n        this._map.off('move', this._onMove);\n        this._map = (undefined: any);\n    }\n\n    /**\n     * Set the scale's unit of the distance\n     *\n     * @param unit Unit of the distance (`'imperial'`, `'metric'` or `'nautical'`).\n     */\n    setUnit(unit: Unit) {\n        this.options.unit = unit;\n        updateScale(this._map, this._container, this.options);\n    }\n}\n\nexport default ScaleControl;\n\nfunction updateScale(map, container, options) {\n    // A horizontal scale is imagined to be present at center of the map\n    // container with maximum length (Default) as 100px.\n    // Using spherical law of cosines approximation, the real distance is\n    // found between the two coordinates.\n    const maxWidth = options && options.maxWidth || 100;\n\n    const y = map._container.clientHeight / 2;\n    const maxMeters = getDistance(map.unproject([0, y]), map.unproject([maxWidth, y]));\n    // The real distance corresponding to 100px scale length is rounded off to\n    // near pretty number and the scale length for the same is found out.\n    // Default unit of the scale is based on User's locale.\n    if (options && options.unit === 'imperial') {\n        const maxFeet = 3.2808 * maxMeters;\n        if (maxFeet > 5280) {\n            const maxMiles = maxFeet / 5280;\n            setScale(container, maxWidth, maxMiles, 'mi');\n        } else {\n            setScale(container, maxWidth, maxFeet, 'ft');\n        }\n    } else if (options && options.unit === 'nautical') {\n        const maxNauticals = maxMeters / 1852;\n        setScale(container, maxWidth, maxNauticals, 'nm');\n    } else {\n        setScale(container, maxWidth, maxMeters, 'm');\n    }\n}\n\nfunction setScale(container, maxWidth, maxDistance, unit) {\n    let distance = getRoundNum(maxDistance);\n    const ratio = distance / maxDistance;\n\n    if (unit === 'm' && distance >= 1000) {\n        distance = distance / 1000;\n        unit = 'km';\n    }\n\n    container.style.width = `${maxWidth * ratio}px`;\n    container.innerHTML = distance + unit;\n}\n\nfunction getDistance(latlng1, latlng2) {\n    // Uses spherical law of cosines approximation.\n    const R = 6371000;\n\n    const rad = Math.PI / 180,\n        lat1 = latlng1.lat * rad,\n        lat2 = latlng2.lat * rad,\n        a = Math.sin(lat1) * Math.sin(lat2) +\n          Math.cos(lat1) * Math.cos(lat2) * Math.cos((latlng2.lng - latlng1.lng) * rad);\n\n    const maxMeters = R * Math.acos(Math.min(a, 1));\n    return maxMeters;\n\n}\n\nfunction getDecimalRoundNum(d) {\n    const multiplier = Math.pow(10, Math.ceil(-Math.log(d) / Math.LN10));\n    return Math.round(d * multiplier) / multiplier;\n}\n\nfunction getRoundNum(num) {\n    const pow10 = Math.pow(10, (`${Math.floor(num)}`).length - 1);\n    let d = num / pow10;\n\n    d = d >= 10 ? 10 :\n        d >= 5 ? 5 :\n        d >= 3 ? 3 :\n        d >= 2 ? 2 :\n        d >= 1 ? 1 : getDecimalRoundNum(d);\n\n    return pow10 * d;\n}\n","// @flow\n\nimport DOM from '../../util/dom';\n\nimport { bindAll, warnOnce } from '../../util/util';\nimport window from '../../util/window';\n\nimport type Map from '../map';\n\ntype Options = {\n    container?: HTMLElement\n};\n\n/**\n * A `FullscreenControl` control contains a button for toggling the map in and out of fullscreen mode.\n *\n * @implements {IControl}\n * @param {Object} [options]\n * @param {HTMLElement} [options.container] `container` is the [compatible DOM element](https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen#Compatible_elements) which should be made full screen. By default, the map container element will be made full screen.\n *\n * @example\n * map.addControl(new mapboxgl.FullscreenControl({container: document.querySelector('body')}));\n * @see [View a fullscreen map](https://www.mapbox.com/mapbox-gl-js/example/fullscreen/)\n */\n\nclass FullscreenControl {\n    _map: Map;\n    _controlContainer: HTMLElement;\n    _fullscreen: boolean;\n    _fullscreenchange: string;\n    _fullscreenButton: HTMLElement;\n    _className: string;\n    _container: HTMLElement;\n\n    constructor(options: Options) {\n        this._fullscreen = false;\n        if (options && options.container) {\n            if (options.container instanceof window.HTMLElement) {\n                this._container = options.container;\n            } else {\n                warnOnce('Full screen control \\'container\\' must be a DOM element.');\n            }\n        }\n        bindAll([\n            '_onClickFullscreen',\n            '_changeIcon'\n        ], this);\n        if ('onfullscreenchange' in window.document) {\n            this._fullscreenchange = 'fullscreenchange';\n        } else if ('onmozfullscreenchange' in window.document) {\n            this._fullscreenchange = 'mozfullscreenchange';\n        } else if ('onwebkitfullscreenchange' in window.document) {\n            this._fullscreenchange = 'webkitfullscreenchange';\n        } else if ('onmsfullscreenchange' in window.document) {\n            this._fullscreenchange = 'MSFullscreenChange';\n        }\n        this._className = 'mapboxgl-ctrl';\n    }\n\n    onAdd(map: Map) {\n        this._map = map;\n        if (!this._container) this._container = this._map.getContainer();\n        this._controlContainer = DOM.create('div', `${this._className} mapboxgl-ctrl-group`);\n        if (this._checkFullscreenSupport()) {\n            this._setupUI();\n        } else {\n            this._controlContainer.style.display = 'none';\n            warnOnce('This device does not support fullscreen mode.');\n        }\n        return this._controlContainer;\n    }\n\n    onRemove() {\n        DOM.remove(this._controlContainer);\n        this._map = (null: any);\n        window.document.removeEventListener(this._fullscreenchange, this._changeIcon);\n    }\n\n    _checkFullscreenSupport() {\n        return !!(\n            window.document.fullscreenEnabled ||\n            (window.document: any).mozFullScreenEnabled ||\n            (window.document: any).msFullscreenEnabled ||\n            (window.document: any).webkitFullscreenEnabled\n        );\n    }\n\n    _setupUI() {\n        const button = this._fullscreenButton = DOM.create('button', (`${this._className}-icon ${this._className}-fullscreen`), this._controlContainer);\n        button.setAttribute(\"aria-label\", \"Toggle fullscreen\");\n        button.type = 'button';\n        this._fullscreenButton.addEventListener('click', this._onClickFullscreen);\n        window.document.addEventListener(this._fullscreenchange, this._changeIcon);\n    }\n\n    _isFullscreen() {\n        return this._fullscreen;\n    }\n\n    _changeIcon() {\n        const fullscreenElement =\n            window.document.fullscreenElement ||\n            (window.document: any).mozFullScreenElement ||\n            (window.document: any).webkitFullscreenElement ||\n            (window.document: any).msFullscreenElement;\n\n        if ((fullscreenElement === this._container) !== this._fullscreen) {\n            this._fullscreen = !this._fullscreen;\n            this._fullscreenButton.classList.toggle(`${this._className}-shrink`);\n            this._fullscreenButton.classList.toggle(`${this._className}-fullscreen`);\n        }\n    }\n\n    _onClickFullscreen() {\n        if (this._isFullscreen()) {\n            if (window.document.exitFullscreen) {\n                (window.document: any).exitFullscreen();\n            } else if (window.document.mozCancelFullScreen) {\n                (window.document: any).mozCancelFullScreen();\n            } else if (window.document.msExitFullscreen) {\n                (window.document: any).msExitFullscreen();\n            } else if (window.document.webkitCancelFullScreen) {\n                (window.document: any).webkitCancelFullScreen();\n            }\n        } else if (this._container.requestFullscreen) {\n            this._container.requestFullscreen();\n        } else if ((this._container: any).mozRequestFullScreen) {\n            (this._container: any).mozRequestFullScreen();\n        } else if ((this._container: any).msRequestFullscreen) {\n            (this._container: any).msRequestFullscreen();\n        } else if ((this._container: any).webkitRequestFullscreen) {\n            (this._container: any).webkitRequestFullscreen();\n        }\n    }\n}\n\nexport default FullscreenControl;\n","//\n// Our custom intro provides a specialized \"define()\" function, called by the\n// AMD modules below, that sets up the worker blob URL and then executes the\n// main module, storing its exported value as 'mapboxgl'\n\n// The three \"chunks\" imported here are produced by a first Rollup pass,\n// which outputs them as AMD modules.\n\n// Shared dependencies, i.e.:\n/*\ndefine(['exports'], function (exports) {\n    // Code for all common dependencies\n    // Each module's exports are attached attached to 'exports' (with\n    // names rewritten to avoid collisions, etc.)\n})\n*/\nimport './build/thinknetmaps/shared';\n\n// Worker and its unique dependencies, i.e.:\n/*\ndefine(['./shared.js'], function (__shared__js) {\n    //  Code for worker script and its unique dependencies.\n    //  Expects the output of 'shared' module to be passed in as an argument,\n    //  since all references to common deps look like, e.g.,\n    //  __shared__js.shapeText().\n});\n*/\n// When this wrapper function is passed to our custom define() above,\n// it gets stringified, together with the shared wrapper (using\n// Function.toString()), and the resulting string of code is made into a\n// Blob URL that gets used by the main module to create the web workers.\nimport './build/thinknetmaps/worker';\n\n// Main module and its unique dependencies\n/*\ndefine(['./shared.js'], function (__shared__js) {\n    //  Code for main GL JS module and its unique dependencies.\n    //  Expects the output of 'shared' module to be passed in as an argument,\n    //  since all references to common deps look like, e.g.,\n    //  __shared__js.shapeText().\n    //\n    //  Returns the actual mapboxgl (i.e. src/index.js)\n});\n*/\nimport './build/thinknetmaps/index';\n\nexport default mapboxgl;\n"],"names":["this","makeRoomForExtraLength","pos","buf","val","realloc","ieee754","buffer","length","writeVarint","len","i","startPos","fn","writeMessage","tag","obj","writeRawMessage","arr","writePackedBoolean","writePackedDouble","writePackedSFixed32","writePackedFixed64","writeBytesField","writeTag","Bytes","writeFixed32Field","Pbf","Fixed32","writeSFixed32Field","writeFixed64Field","writeFixed64","Varint","str","writeString","writeFloat","writeDouble","writeVarintField","border","readFontstacks","readFontstack","readMessage","readGlyph","left","advance","AlphaImage","width","height","bitmap","metrics","pbf","glyph","readVarint","readSVarint","top","parent","mapId","callbacks","target","receive","z","PI","Math","resolution","y","type","targetMapId","const","callback","sourceMapId","id","data","serialize","buffers","Actor","message","done","String","deserialize","error","keys","getWorkerSource","remove","LngLatBounds","constructor","sw","ne","setSouthWest","setNorthEast","_ne","LngLat","lng","sw2","ne2","Array","isArray","extend","convert","min","lat","max","_sw","getSouthWest","getNorthEast","getNorth","getSouth","toString","isNaN","Error","circumferenceAtLatitude","exp","wrap","toBounds","lngAccuracy","input","lon","lngLat","mercatorYfromLat","MercatorCoordinate","x","key","url","let","mask","quadkey","urls","replace","bbox","coord","tilesAtZoom","UnwrappedTileID","canonical","calculateKey","overscaledZ","dim","OverscaledTileID","targetZ","zDifference","sourceMaxZoom","rhs","wrapped","unwrapTo","overscaleFactor","getTilePoint","omit","uid","encoding","warnOnce","stride","_unpackTerrarium","j","set","unpack","pixels","get","value","DEMData","r","g","b","getPixels","backfillBorder","dx","xMax","yMin","oy","ox","strings","_stringToNumber","_numberToString","string","n","vectorTileFeature","_vectorTileFeature","_x","_geometry","json","stateChanges","sourceLayer","feature","state","featureId","base","changes","painter","setFeatureState","SourceFeatureState","coalesceChanges","tiles","layerStates","grid","featureIndexArray","minX","Infinity","minY","p","maxX","featureIndex","sourceLayerIndex","bucketIndex","is3D","geometry","ring","EXTENT","insert","FeatureIndex","vtLayers","Protobuf","DictionaryCoder","Object","sort","query","sourceFeatureState","params","pixelsToTileUnits","featureFilter","queryGeometry","bounds","getBounds","queryPadding","cameraBounds","grid3D","bx1","by1","bx2","matching","push","topDownFeatureComparator","previousIndex","result","index","match","featureGeometry","layers","styleLayers","loadGeometry","featureState","k","filter","filterLayerIDs","bucketLayerIDs","l","arraysIntersect","decode","sourceLayerName","tileID","layerID","intersectionZ","geojsonFeature","GeoJSONFeature","styleLayer","lookupSymbolFeatures","symbolFeatureIndexes","loadMatchingFeature","uniqueId","tileSize","size","registerFadeDuration","duration","fadeEndTime","timeAdded","loadVectorData","justReloaded","unloadVectorData","rawTileData","latestFeatureIndex","latestRawTileData","collisionBoxArray","buckets","output","bucket","stateDependentLayers","deserializeBucket","style","glyphAtlasImage","Tile","imageAtlas","glyphAtlasTexture","destroy","unloadDEMData","context","imageAtlasTexture","Texture","gl","uploaded","queryRenderedFeatures","maxPitchScaleFactor","scale","pixelPosMatrix","transform","layer","clearMask","maskedBoundsBuffer","maskedIndexBuffer","0","prepareSegment","maskedBoundsArray","maskArray","vertexExtent","maskCoord","tlVertex","indexArray","brVertex","emplaceBack","segment","offset","vertexLength","members","$2","$3","header","parseInt","cacheControl","Date","expirationTime","now","expiredRequestCount","getExpiryTimeout","states","sourceLayerId","sourceLayerStates","holdingForFade","symbolFadeHoldUntil","clearFadeHold","setHoldDuration","horizontalOnly","sections","TaggedString","section","fontStack","sectionIndex","nextCharCode","charCodeAt","prevCharCode","charHasRotatedVerticalOrientation","verticalizedCharacterMap","text","substring","trailingWhitespace","start","slice","end","breakable","lineWidth","targetWidth","raggedness","abs","calculatePenalty","codePoint","potentialBreaks","bestBreakBadness","calculateBadness","breakBadness","badness","determineLineBreaks","glyphMap","logicalInput","maxWidth","positions","ceil","spacing","char","isChar","getCharCode","lastLineBreak","horizontalAlign","verticalAlign","justify","positionedGlyphs","lastPositionedGlyph","requestParameters","isMapboxURL","makeAPIURL","urlObject","path","formatUrl","parseUrl","array","remaining","ref","polar","azimuthal","properties","src","accessToken","sourceURL","tileJSON","tileURL","suffix","supported","a","document","createElement","video","onloadstart","s","protocol","host","appendChild","glMatrix","out","a03","a11","a23","a33","b00","a01","a00","a12","a10","b02","b04","a02","a13","a31","a20","a22","a30","b09","a21","a32","b11","b08","b06","det","b03","b01","b10","b0","b3","b1","b2","stringify","JSON","getKey","refProperties","StyleLayerIndex","layerConfigs","checkMaxAngle","line","anchor","labelLength","windowSize","maxAngle","undefined","anchorDistance","dist","recentCorners","recentAngleDelta","prev","current","next","angleDelta","angleTo","distance","shift","getLineLength","lineLength","getAngleWindowSize","shapedText","glyphSize","boxScale","getShapedLabelLength","shapedIcon","right","getCenterAnchor","angleWindowSize","prevDistance","centerDistance","segmentDistance","t","interpolate","Anchor","_round","getAnchors","overscaling","tileExtent","shapedLabelLength","isLineContinued","resample","placeAtMiddle","halfLabelLength","markedDistance","anchors","segmentDist","angle","_layerConfigs","_layers","update","removedIds","layerConfig","createStyleLayer","_featureFilter","familiesBySource","groups","group","groupByLayout","values","map","visibility","sourceId","source","sourceGroup","sourceLayerFamilies","CollisionFeature","shaped","padding","alignLine","rotate","y1","y2","bottom","x1","x2","boxStartIndex","_addLineCollisionCircles","tl","Point","tr","bl","br","rotateRadians","_rotate","boxEndIndex","boxSize","step","nBoxes","floor","overscalingPaddingFactor","log","LN2","nPitchPaddingBoxes","firstBoxOffset","labelStartDistance","paddingStartDistance","segmentLength","boxOffset","boxDistanceToAnchor","segmentBoxDistance","p0","boxAnchorPoint","sub","_unit","_mult","_add","paddedAnchorDistance","module","TinyQueue","compare","defaultCompare","_down","polygon","area","points","f","Cell","compareMax","h","d","inside","minDistSq","distToSegmentSquared","sqrt","pointToPolygonDist","SQRT2","prototype","item","_up","pop","peek","halfLength","best","seed","remainder","bytes","h1","h1b","c1","c2","k1","murmur3","murmur2","performSymbolLayout","glyphPositions","imageMap","imagePositions","showCollisionBoxes","createArrays","tilePixelRatio","compareText","iconsNeedLinear","layout","unevaluatedLayoutValues","_unevaluatedLayout","_values","sizes","textSizeData","functionType","zoomRange","compositeTextSizes","possiblyEvaluate","EvaluationParameters","iconSizeData","compositeIconSizes","layoutTextSize","zoom","layoutIconSize","textMaxSize","lineHeight","textAlongLine","keepUpright","features","fontstack","evaluate","join","glyphPositionMap","shapedTextOrientations","unformattedText","textOffset","spacingIfAllowed","allowsLetterSpacing","textAnchor","textJustify","horizontal","shapeText","WritingMode","allowsVerticalWritingMode","vertical","icon","image","shapeIcon","sdfIcons","sdf","pixelRatio","constantOr","addFeature","generateCollisionDebugBuffers","iconOffset","fontScale","textBoxScale","textMaxBoxScale","iconBoxScale","symbolMinDistance","textPadding","iconPadding","textMaxAngle","iconAlongLine","symbolPlacement","textRepeatDistance","addSymbolAtAnchor","textCollisionFeature","iconCollisionFeature","lineArray","addToLineVertexArray","numIconVertices","numGlyphVertices","numVerticalGlyphVertices","placedTextSymbolIndices","textRotate","addTextVertices","textBoxStartIndex","textBoxEndIndex","iconQuads","alongLine","iconWidth","iconHeight","textLeft","textRight","textTop","textWidth","textHeight","padT","padR","padB","padL","offsetY","offsetX","sin","cos","matrix","_matMult","tex","paddedRect","writingMode","glyphOffset","getIconQuads","iconRotate","sizeData","SIZE_PACK_FACTOR","MAX_PACKED_SIZE","layerIds","addSymbols","lineStartIndex","iconBoxStartIndex","iconBoxEndIndex","glyphOffsetArray","SymbolBucket","MAX_GLYPHS","symbolInstances","addSymbol","lines","clippedLines","clippedLine","p1","equals","clipLine","anchorIsTooClose","classifyRings","poi","findPoleOfInaccessibility","point","glyphQuads","shaping","quads","positionedGlyph","rect","rectBuffer","GLYPH_PBF_BORDER","halfAdvance","builtInOffset","w","center","verticalRotation","xOffsetCorrection","_rotateAround","getGlyphQuads","placedSymbolArray","repeatDistance","otherAnchors","GlyphAtlas","stacks","bins","stack","glyphs","stackPositions","bin","potpack","copy","register","WorkerTile","collectResourceTiming","returnDependencies","recalculateLayers","parameters","recalculate","parse","layerIndex","actor","status","CollisionBoxArray","sourceLayerCoder","iconMap","patternMap","options","layerFamilies","version","encode","family","minzoom","maxzoom","createBucket","sourceID","populate","mapObject","glyphDependencies","Number","send","err","maybePrepare","call","icons","iconDependencies","patterns","patternDependencies","glyphAtlas","ImageAtlas","iconPositions","hasPattern","LineBucket","FillBucket","FillExtrusionBucket","addFeatures","patternPositions","isEmpty","performanceExists","performance","wrapper","getEntriesByName","name","mark","startMark","endMark","measure","clearMarks","clearMeasures","Performance","request","_marks","loadVectorTile","getArrayBuffer","expires","vectorTile","vt","VectorTile","rawData","cancel","finish","resourceTimingData","VectorTileWorkerSource","loading","loaded","loadTile","perf","workerTile","abort","response","resourceTiming","reloadTile","vtSource","reloadCallback","abortTile","removeTile","RasterDEMTileWorkerSource","rawImageData","dem","polygonArea","coords","ringArea","p2","lowerIndex","middleIndex","upperIndex","coordsLength","rad","wgs84","RADIUS","_","coordinates","geometries","rewind","gj","outer","curryOuter","correctRings","correct","wind","dir","geojsonArea","cw","reverse","toGeoJSON","mvt","VectorTileFeature","FeatureWrapper","_feature","extent","tags","newRing","GeoJSONWrapper","_geojsonTileLayer","_features","require","rawGeometry","rings","fromVectorTileJs","tile","writeLayer","writeTile","writeStringField","keycache","valuecache","writeFeature","pow","tileSpaceBounds","tileResults","symbolLayer","getRenderableIds","_source","_tiles","getState","isRasterType","SourceCache","maxOverzooming","active","_logoRequired","LogoControl","_map","sourceCaches","mapbox_logo","_updateCompact","offsetWidth","add","_cleared","TaskQueue","_queue","running","run","queue","task","cancelled","_currentlyRunning","HTMLElement","keyboard","touchZoomRotate","bearingSnap","clickTolerance","preserveDrawingBuffer","renderWorldCopies","refreshExpiredTiles","maxTileCacheSize","maxZoom","minZoom","super","interactive","_maxTileCacheSize","_preserveDrawingBuffer","fadeDuration","_crossFadingFactor","_collectResourceTiming","_renderTaskQueue","transformRequest","transformRequestFn","_container","container","maxBounds","bindAll","on","_update","window","addEventListener","el","enable","e","MapMouseEvent","mousePos","mapEvent","doubleClickZoom","isActive","onMouseDown","dragPan","boxZoom","DOM","dragRotate","contextMenuEvent","rotating","mouseDown","fire","parentNode","onTouchStart","defaultPrevented","onDblClick","isEnabled","listens","preventDefault","stop","scrollZoom","onWheel","bindHandlers","Hash","_hash","bearing","pitch","resize","localIdeographFontFamily","AttributionControl","customAttribution","addControl","logoPosition","unmodified","jumpTo","stylesheet","event","dataType","_getMapId","control","position","controlElement","onAdd","_controls","_controlPositions","indexOf","positionContainer","removeControl","ErrorEvent","ci","Event","eventData","getMaxBounds","setMaxBounds","setMinZoom","getMinZoom","setMaxZoom","getZoom","setZoom","setRenderWorldCopies","lnglat","unproject","isMoving","_moving","_zooming","listener","getLayer","mousein","delegates","_delegatedListeners","delegatedListener","off","listeners","querySourceFeatures","setStyle","diff","_diffStyle","setEventedParent","_transformRequest","getJSON","_updateDiff","setState","_updateStyle","areTilesLoaded","sources","addSourceType","SourceType","removeSource","getSource","addImage","browser","Uint8Array","hasImage","Image","listImages","before","addLayer","moveLayer","setFilter","setLayerZoomRange","layerId","setPaintProperty","setLayoutProperty","setLight","light","getLight","getCanvasContainer","_canvasContainer","_canvas","_containerDimensions","_missingCSSCanary","_detectMissingCSS","canvasContainer","create","_interactive","top-left","linearOffset","_popup","setLngLat","originalEvent","contains","popup","addTo","_pos","setTransform","_element","anchorTranslate","applyAnchorClass","_anchor","setOffset","_offset","_positionDelta","_lngLat","_state","_onMove","once","setDraggable","_addDragHandler","isDraggable","Evented","defaultOptions","positionOptions","enableHighAccuracy","maximumAge","fitBoundsOptions","showUserLocation","_setupUI","supportsGeolocation","permissions","navigator","_geolocationWatchID","_userLocationDotMarker","_onSuccess","classList","_geolocateButton","_watchState","_updateCamera","radius","accuracy","geolocateSource","longitude","latitude","_finish","_timeoutId","trigger","_setup","trackUserLocation","_lastKnownPosition","getCurrentPosition","_onError","geolocation","_updateMarker","lat2","maxMeters","latlng1","latlng2","lat1","unit","setScale","num","maxDistance","pow10","multiplier","ratio","getDefaultPosition","ScaleControl","getContainer","FullscreenControl","_fullscreen","_fullscreenchange","_controlContainer","removeEventListener","_changeIcon","button","mozFullScreenElement"],"mappings":"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"}